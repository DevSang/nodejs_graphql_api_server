// Code generated by Prisma (prisma@1.35.0-beta). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  answerType: (where?: AnswerTypeWhereInput) => Promise<boolean>;
  appServerSync: (where?: AppServerSyncWhereInput) => Promise<boolean>;
  authToken: (where?: AuthTokenWhereInput) => Promise<boolean>;
  calibration: (where?: CalibrationWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  cup: (where?: CupWhereInput) => Promise<boolean>;
  cupAppSync: (where?: CupAppSyncWhereInput) => Promise<boolean>;
  cupDataAnswer: (where?: CupDataAnswerWhereInput) => Promise<boolean>;
  cupDataColourCalc: (where?: CupDataColourCalcWhereInput) => Promise<boolean>;
  cupDataColourCalib: (
    where?: CupDataColourCalibWhereInput
  ) => Promise<boolean>;
  cupDataManMdate: (where?: CupDataManMdateWhereInput) => Promise<boolean>;
  cupDataProcFlow: (where?: CupDataProcFlowWhereInput) => Promise<boolean>;
  cupDataProcMdate: (where?: CupDataProcMdateWhereInput) => Promise<boolean>;
  cupDataProcVolume: (where?: CupDataProcVolumeWhereInput) => Promise<boolean>;
  cupDataQaResponse: (where?: CupDataQaResponseWhereInput) => Promise<boolean>;
  cupDataQuestion: (where?: CupDataQuestionWhereInput) => Promise<boolean>;
  cupDataRaw: (where?: CupDataRawWhereInput) => Promise<boolean>;
  cupDataRejection: (where?: CupDataRejectionWhereInput) => Promise<boolean>;
  cupDataUserRemove: (where?: CupDataUserRemoveWhereInput) => Promise<boolean>;
  cupDataUserRemoveExplain: (
    where?: CupDataUserRemoveExplainWhereInput
  ) => Promise<boolean>;
  cupDatum: (where?: CupDatumWhereInput) => Promise<boolean>;
  ethnicity: (where?: EthnicityWhereInput) => Promise<boolean>;
  firmware: (where?: FirmwareWhereInput) => Promise<boolean>;
  hardware: (where?: HardwareWhereInput) => Promise<boolean>;
  platformComp: (where?: PlatformCompWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userCoinHistory: (where?: UserCoinHistoryWhereInput) => Promise<boolean>;
  userInterviewDatum: (
    where?: UserInterviewDatumWhereInput
  ) => Promise<boolean>;
  userInterviewQuestion: (
    where?: UserInterviewQuestionWhereInput
  ) => Promise<boolean>;
  userRecordDataByDay: (
    where?: UserRecordDataByDayWhereInput
  ) => Promise<boolean>;
  userRecordDataByPeriod: (
    where?: UserRecordDataByPeriodWhereInput
  ) => Promise<boolean>;
  userRecordDataByTime: (
    where?: UserRecordDataByTimeWhereInput
  ) => Promise<boolean>;
  usersDataAnalysis: (where?: UsersDataAnalysisWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  answerType: (where: AnswerTypeWhereUniqueInput) => AnswerTypeNullablePromise;
  answerTypes: (args?: {
    where?: AnswerTypeWhereInput;
    orderBy?: AnswerTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AnswerType>;
  answerTypesConnection: (args?: {
    where?: AnswerTypeWhereInput;
    orderBy?: AnswerTypeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AnswerTypeConnectionPromise;
  appServerSync: (
    where: AppServerSyncWhereUniqueInput
  ) => AppServerSyncNullablePromise;
  appServerSyncs: (args?: {
    where?: AppServerSyncWhereInput;
    orderBy?: AppServerSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AppServerSync>;
  appServerSyncsConnection: (args?: {
    where?: AppServerSyncWhereInput;
    orderBy?: AppServerSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppServerSyncConnectionPromise;
  authToken: (where: AuthTokenWhereUniqueInput) => AuthTokenNullablePromise;
  authTokens: (args?: {
    where?: AuthTokenWhereInput;
    orderBy?: AuthTokenOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AuthToken>;
  authTokensConnection: (args?: {
    where?: AuthTokenWhereInput;
    orderBy?: AuthTokenOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthTokenConnectionPromise;
  calibration: (
    where: CalibrationWhereUniqueInput
  ) => CalibrationNullablePromise;
  calibrations: (args?: {
    where?: CalibrationWhereInput;
    orderBy?: CalibrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Calibration>;
  calibrationsConnection: (args?: {
    where?: CalibrationWhereInput;
    orderBy?: CalibrationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CalibrationConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryNullablePromise;
  countries: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Country>;
  countriesConnection: (args?: {
    where?: CountryWhereInput;
    orderBy?: CountryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CountryConnectionPromise;
  cup: (where: CupWhereUniqueInput) => CupNullablePromise;
  cups: (args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Cup>;
  cupsConnection: (args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupConnectionPromise;
  cupAppSync: (where: CupAppSyncWhereUniqueInput) => CupAppSyncNullablePromise;
  cupAppSyncs: (args?: {
    where?: CupAppSyncWhereInput;
    orderBy?: CupAppSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupAppSync>;
  cupAppSyncsConnection: (args?: {
    where?: CupAppSyncWhereInput;
    orderBy?: CupAppSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupAppSyncConnectionPromise;
  cupDataAnswer: (
    where: CupDataAnswerWhereUniqueInput
  ) => CupDataAnswerNullablePromise;
  cupDataAnswers: (args?: {
    where?: CupDataAnswerWhereInput;
    orderBy?: CupDataAnswerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataAnswer>;
  cupDataAnswersConnection: (args?: {
    where?: CupDataAnswerWhereInput;
    orderBy?: CupDataAnswerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataAnswerConnectionPromise;
  cupDataColourCalc: (
    where: CupDataColourCalcWhereUniqueInput
  ) => CupDataColourCalcNullablePromise;
  cupDataColourCalcs: (args?: {
    where?: CupDataColourCalcWhereInput;
    orderBy?: CupDataColourCalcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataColourCalc>;
  cupDataColourCalcsConnection: (args?: {
    where?: CupDataColourCalcWhereInput;
    orderBy?: CupDataColourCalcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataColourCalcConnectionPromise;
  cupDataColourCalib: (
    where: CupDataColourCalibWhereUniqueInput
  ) => CupDataColourCalibNullablePromise;
  cupDataColourCalibs: (args?: {
    where?: CupDataColourCalibWhereInput;
    orderBy?: CupDataColourCalibOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataColourCalib>;
  cupDataColourCalibsConnection: (args?: {
    where?: CupDataColourCalibWhereInput;
    orderBy?: CupDataColourCalibOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataColourCalibConnectionPromise;
  cupDataManMdate: (
    where: CupDataManMdateWhereUniqueInput
  ) => CupDataManMdateNullablePromise;
  cupDataManMdates: (args?: {
    where?: CupDataManMdateWhereInput;
    orderBy?: CupDataManMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataManMdate>;
  cupDataManMdatesConnection: (args?: {
    where?: CupDataManMdateWhereInput;
    orderBy?: CupDataManMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataManMdateConnectionPromise;
  cupDataProcFlow: (
    where: CupDataProcFlowWhereUniqueInput
  ) => CupDataProcFlowNullablePromise;
  cupDataProcFlows: (args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataProcFlow>;
  cupDataProcFlowsConnection: (args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataProcFlowConnectionPromise;
  cupDataProcMdate: (
    where: CupDataProcMdateWhereUniqueInput
  ) => CupDataProcMdateNullablePromise;
  cupDataProcMdates: (args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataProcMdate>;
  cupDataProcMdatesConnection: (args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataProcMdateConnectionPromise;
  cupDataProcVolume: (
    where: CupDataProcVolumeWhereUniqueInput
  ) => CupDataProcVolumeNullablePromise;
  cupDataProcVolumes: (args?: {
    where?: CupDataProcVolumeWhereInput;
    orderBy?: CupDataProcVolumeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataProcVolume>;
  cupDataProcVolumesConnection: (args?: {
    where?: CupDataProcVolumeWhereInput;
    orderBy?: CupDataProcVolumeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataProcVolumeConnectionPromise;
  cupDataQaResponse: (
    where: CupDataQaResponseWhereUniqueInput
  ) => CupDataQaResponseNullablePromise;
  cupDataQaResponses: (args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataQaResponse>;
  cupDataQaResponsesConnection: (args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataQaResponseConnectionPromise;
  cupDataQuestion: (
    where: CupDataQuestionWhereUniqueInput
  ) => CupDataQuestionNullablePromise;
  cupDataQuestions: (args?: {
    where?: CupDataQuestionWhereInput;
    orderBy?: CupDataQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataQuestion>;
  cupDataQuestionsConnection: (args?: {
    where?: CupDataQuestionWhereInput;
    orderBy?: CupDataQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataQuestionConnectionPromise;
  cupDataRaw: (where: CupDataRawWhereUniqueInput) => CupDataRawNullablePromise;
  cupDataRaws: (args?: {
    where?: CupDataRawWhereInput;
    orderBy?: CupDataRawOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataRaw>;
  cupDataRawsConnection: (args?: {
    where?: CupDataRawWhereInput;
    orderBy?: CupDataRawOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataRawConnectionPromise;
  cupDataRejection: (
    where: CupDataRejectionWhereUniqueInput
  ) => CupDataRejectionNullablePromise;
  cupDataRejections: (args?: {
    where?: CupDataRejectionWhereInput;
    orderBy?: CupDataRejectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataRejection>;
  cupDataRejectionsConnection: (args?: {
    where?: CupDataRejectionWhereInput;
    orderBy?: CupDataRejectionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataRejectionConnectionPromise;
  cupDataUserRemove: (
    where: CupDataUserRemoveWhereUniqueInput
  ) => CupDataUserRemoveNullablePromise;
  cupDataUserRemoves: (args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataUserRemove>;
  cupDataUserRemovesConnection: (args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataUserRemoveConnectionPromise;
  cupDataUserRemoveExplain: (
    where: CupDataUserRemoveExplainWhereUniqueInput
  ) => CupDataUserRemoveExplainNullablePromise;
  cupDataUserRemoveExplains: (args?: {
    where?: CupDataUserRemoveExplainWhereInput;
    orderBy?: CupDataUserRemoveExplainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDataUserRemoveExplain>;
  cupDataUserRemoveExplainsConnection: (args?: {
    where?: CupDataUserRemoveExplainWhereInput;
    orderBy?: CupDataUserRemoveExplainOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDataUserRemoveExplainConnectionPromise;
  cupDatum: (where: CupDatumWhereUniqueInput) => CupDatumNullablePromise;
  cupData: (args?: {
    where?: CupDatumWhereInput;
    orderBy?: CupDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CupDatum>;
  cupDataConnection: (args?: {
    where?: CupDatumWhereInput;
    orderBy?: CupDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CupDatumConnectionPromise;
  ethnicity: (where: EthnicityWhereUniqueInput) => EthnicityNullablePromise;
  ethnicities: (args?: {
    where?: EthnicityWhereInput;
    orderBy?: EthnicityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ethnicity>;
  ethnicitiesConnection: (args?: {
    where?: EthnicityWhereInput;
    orderBy?: EthnicityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EthnicityConnectionPromise;
  firmware: (where: FirmwareWhereUniqueInput) => FirmwareNullablePromise;
  firmwares: (args?: {
    where?: FirmwareWhereInput;
    orderBy?: FirmwareOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Firmware>;
  firmwaresConnection: (args?: {
    where?: FirmwareWhereInput;
    orderBy?: FirmwareOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FirmwareConnectionPromise;
  hardware: (where: HardwareWhereUniqueInput) => HardwareNullablePromise;
  hardwares: (args?: {
    where?: HardwareWhereInput;
    orderBy?: HardwareOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Hardware>;
  hardwaresConnection: (args?: {
    where?: HardwareWhereInput;
    orderBy?: HardwareOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HardwareConnectionPromise;
  platformComp: (
    where: PlatformCompWhereUniqueInput
  ) => PlatformCompNullablePromise;
  platformComps: (args?: {
    where?: PlatformCompWhereInput;
    orderBy?: PlatformCompOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<PlatformComp>;
  platformCompsConnection: (args?: {
    where?: PlatformCompWhereInput;
    orderBy?: PlatformCompOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PlatformCompConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  userCoinHistory: (
    where: UserCoinHistoryWhereUniqueInput
  ) => UserCoinHistoryNullablePromise;
  userCoinHistories: (args?: {
    where?: UserCoinHistoryWhereInput;
    orderBy?: UserCoinHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserCoinHistory>;
  userCoinHistoriesConnection: (args?: {
    where?: UserCoinHistoryWhereInput;
    orderBy?: UserCoinHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserCoinHistoryConnectionPromise;
  userInterviewDatum: (
    where: UserInterviewDatumWhereUniqueInput
  ) => UserInterviewDatumNullablePromise;
  userInterviewData: (args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserInterviewDatum>;
  userInterviewDataConnection: (args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserInterviewDatumConnectionPromise;
  userInterviewQuestion: (
    where: UserInterviewQuestionWhereUniqueInput
  ) => UserInterviewQuestionNullablePromise;
  userInterviewQuestions: (args?: {
    where?: UserInterviewQuestionWhereInput;
    orderBy?: UserInterviewQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserInterviewQuestion>;
  userInterviewQuestionsConnection: (args?: {
    where?: UserInterviewQuestionWhereInput;
    orderBy?: UserInterviewQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserInterviewQuestionConnectionPromise;
  userRecordDataByDay: (
    where: UserRecordDataByDayWhereUniqueInput
  ) => UserRecordDataByDayNullablePromise;
  userRecordDataByDays: (args?: {
    where?: UserRecordDataByDayWhereInput;
    orderBy?: UserRecordDataByDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserRecordDataByDay>;
  userRecordDataByDaysConnection: (args?: {
    where?: UserRecordDataByDayWhereInput;
    orderBy?: UserRecordDataByDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserRecordDataByDayConnectionPromise;
  userRecordDataByPeriod: (
    where: UserRecordDataByPeriodWhereUniqueInput
  ) => UserRecordDataByPeriodNullablePromise;
  userRecordDataByPeriods: (args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserRecordDataByPeriod>;
  userRecordDataByPeriodsConnection: (args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserRecordDataByPeriodConnectionPromise;
  userRecordDataByTime: (
    where: UserRecordDataByTimeWhereUniqueInput
  ) => UserRecordDataByTimeNullablePromise;
  userRecordDataByTimes: (args?: {
    where?: UserRecordDataByTimeWhereInput;
    orderBy?: UserRecordDataByTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UserRecordDataByTime>;
  userRecordDataByTimesConnection: (args?: {
    where?: UserRecordDataByTimeWhereInput;
    orderBy?: UserRecordDataByTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserRecordDataByTimeConnectionPromise;
  usersDataAnalysis: (
    where: UsersDataAnalysisWhereUniqueInput
  ) => UsersDataAnalysisNullablePromise;
  usersDataAnalyses: (args?: {
    where?: UsersDataAnalysisWhereInput;
    orderBy?: UsersDataAnalysisOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<UsersDataAnalysis>;
  usersDataAnalysesConnection: (args?: {
    where?: UsersDataAnalysisWhereInput;
    orderBy?: UsersDataAnalysisOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UsersDataAnalysisConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAnswerType: (data: AnswerTypeCreateInput) => AnswerTypePromise;
  updateAnswerType: (args: {
    data: AnswerTypeUpdateInput;
    where: AnswerTypeWhereUniqueInput;
  }) => AnswerTypePromise;
  updateManyAnswerTypes: (args: {
    data: AnswerTypeUpdateManyMutationInput;
    where?: AnswerTypeWhereInput;
  }) => BatchPayloadPromise;
  upsertAnswerType: (args: {
    where: AnswerTypeWhereUniqueInput;
    create: AnswerTypeCreateInput;
    update: AnswerTypeUpdateInput;
  }) => AnswerTypePromise;
  deleteAnswerType: (where: AnswerTypeWhereUniqueInput) => AnswerTypePromise;
  deleteManyAnswerTypes: (where?: AnswerTypeWhereInput) => BatchPayloadPromise;
  createAppServerSync: (data: AppServerSyncCreateInput) => AppServerSyncPromise;
  updateAppServerSync: (args: {
    data: AppServerSyncUpdateInput;
    where: AppServerSyncWhereUniqueInput;
  }) => AppServerSyncPromise;
  updateManyAppServerSyncs: (args: {
    data: AppServerSyncUpdateManyMutationInput;
    where?: AppServerSyncWhereInput;
  }) => BatchPayloadPromise;
  upsertAppServerSync: (args: {
    where: AppServerSyncWhereUniqueInput;
    create: AppServerSyncCreateInput;
    update: AppServerSyncUpdateInput;
  }) => AppServerSyncPromise;
  deleteAppServerSync: (
    where: AppServerSyncWhereUniqueInput
  ) => AppServerSyncPromise;
  deleteManyAppServerSyncs: (
    where?: AppServerSyncWhereInput
  ) => BatchPayloadPromise;
  createAuthToken: (data: AuthTokenCreateInput) => AuthTokenPromise;
  deleteAuthToken: (where: AuthTokenWhereUniqueInput) => AuthTokenPromise;
  deleteManyAuthTokens: (where?: AuthTokenWhereInput) => BatchPayloadPromise;
  createCalibration: (data: CalibrationCreateInput) => CalibrationPromise;
  updateCalibration: (args: {
    data: CalibrationUpdateInput;
    where: CalibrationWhereUniqueInput;
  }) => CalibrationPromise;
  updateManyCalibrations: (args: {
    data: CalibrationUpdateManyMutationInput;
    where?: CalibrationWhereInput;
  }) => BatchPayloadPromise;
  upsertCalibration: (args: {
    where: CalibrationWhereUniqueInput;
    create: CalibrationCreateInput;
    update: CalibrationUpdateInput;
  }) => CalibrationPromise;
  deleteCalibration: (where: CalibrationWhereUniqueInput) => CalibrationPromise;
  deleteManyCalibrations: (
    where?: CalibrationWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (args: {
    data: CountryUpdateInput;
    where: CountryWhereUniqueInput;
  }) => CountryPromise;
  updateManyCountries: (args: {
    data: CountryUpdateManyMutationInput;
    where?: CountryWhereInput;
  }) => BatchPayloadPromise;
  upsertCountry: (args: {
    where: CountryWhereUniqueInput;
    create: CountryCreateInput;
    update: CountryUpdateInput;
  }) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createCup: (data: CupCreateInput) => CupPromise;
  updateCup: (args: {
    data: CupUpdateInput;
    where: CupWhereUniqueInput;
  }) => CupPromise;
  updateManyCups: (args: {
    data: CupUpdateManyMutationInput;
    where?: CupWhereInput;
  }) => BatchPayloadPromise;
  upsertCup: (args: {
    where: CupWhereUniqueInput;
    create: CupCreateInput;
    update: CupUpdateInput;
  }) => CupPromise;
  deleteCup: (where: CupWhereUniqueInput) => CupPromise;
  deleteManyCups: (where?: CupWhereInput) => BatchPayloadPromise;
  createCupAppSync: (data: CupAppSyncCreateInput) => CupAppSyncPromise;
  updateCupAppSync: (args: {
    data: CupAppSyncUpdateInput;
    where: CupAppSyncWhereUniqueInput;
  }) => CupAppSyncPromise;
  updateManyCupAppSyncs: (args: {
    data: CupAppSyncUpdateManyMutationInput;
    where?: CupAppSyncWhereInput;
  }) => BatchPayloadPromise;
  upsertCupAppSync: (args: {
    where: CupAppSyncWhereUniqueInput;
    create: CupAppSyncCreateInput;
    update: CupAppSyncUpdateInput;
  }) => CupAppSyncPromise;
  deleteCupAppSync: (where: CupAppSyncWhereUniqueInput) => CupAppSyncPromise;
  deleteManyCupAppSyncs: (where?: CupAppSyncWhereInput) => BatchPayloadPromise;
  createCupDataAnswer: (data: CupDataAnswerCreateInput) => CupDataAnswerPromise;
  updateCupDataAnswer: (args: {
    data: CupDataAnswerUpdateInput;
    where: CupDataAnswerWhereUniqueInput;
  }) => CupDataAnswerPromise;
  updateManyCupDataAnswers: (args: {
    data: CupDataAnswerUpdateManyMutationInput;
    where?: CupDataAnswerWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataAnswer: (args: {
    where: CupDataAnswerWhereUniqueInput;
    create: CupDataAnswerCreateInput;
    update: CupDataAnswerUpdateInput;
  }) => CupDataAnswerPromise;
  deleteCupDataAnswer: (
    where: CupDataAnswerWhereUniqueInput
  ) => CupDataAnswerPromise;
  deleteManyCupDataAnswers: (
    where?: CupDataAnswerWhereInput
  ) => BatchPayloadPromise;
  createCupDataColourCalc: (
    data: CupDataColourCalcCreateInput
  ) => CupDataColourCalcPromise;
  updateCupDataColourCalc: (args: {
    data: CupDataColourCalcUpdateInput;
    where: CupDataColourCalcWhereUniqueInput;
  }) => CupDataColourCalcPromise;
  updateManyCupDataColourCalcs: (args: {
    data: CupDataColourCalcUpdateManyMutationInput;
    where?: CupDataColourCalcWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataColourCalc: (args: {
    where: CupDataColourCalcWhereUniqueInput;
    create: CupDataColourCalcCreateInput;
    update: CupDataColourCalcUpdateInput;
  }) => CupDataColourCalcPromise;
  deleteCupDataColourCalc: (
    where: CupDataColourCalcWhereUniqueInput
  ) => CupDataColourCalcPromise;
  deleteManyCupDataColourCalcs: (
    where?: CupDataColourCalcWhereInput
  ) => BatchPayloadPromise;
  createCupDataColourCalib: (
    data: CupDataColourCalibCreateInput
  ) => CupDataColourCalibPromise;
  updateCupDataColourCalib: (args: {
    data: CupDataColourCalibUpdateInput;
    where: CupDataColourCalibWhereUniqueInput;
  }) => CupDataColourCalibPromise;
  updateManyCupDataColourCalibs: (args: {
    data: CupDataColourCalibUpdateManyMutationInput;
    where?: CupDataColourCalibWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataColourCalib: (args: {
    where: CupDataColourCalibWhereUniqueInput;
    create: CupDataColourCalibCreateInput;
    update: CupDataColourCalibUpdateInput;
  }) => CupDataColourCalibPromise;
  deleteCupDataColourCalib: (
    where: CupDataColourCalibWhereUniqueInput
  ) => CupDataColourCalibPromise;
  deleteManyCupDataColourCalibs: (
    where?: CupDataColourCalibWhereInput
  ) => BatchPayloadPromise;
  createCupDataManMdate: (
    data: CupDataManMdateCreateInput
  ) => CupDataManMdatePromise;
  updateCupDataManMdate: (args: {
    data: CupDataManMdateUpdateInput;
    where: CupDataManMdateWhereUniqueInput;
  }) => CupDataManMdatePromise;
  updateManyCupDataManMdates: (args: {
    data: CupDataManMdateUpdateManyMutationInput;
    where?: CupDataManMdateWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataManMdate: (args: {
    where: CupDataManMdateWhereUniqueInput;
    create: CupDataManMdateCreateInput;
    update: CupDataManMdateUpdateInput;
  }) => CupDataManMdatePromise;
  deleteCupDataManMdate: (
    where: CupDataManMdateWhereUniqueInput
  ) => CupDataManMdatePromise;
  deleteManyCupDataManMdates: (
    where?: CupDataManMdateWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcFlow: (
    data: CupDataProcFlowCreateInput
  ) => CupDataProcFlowPromise;
  updateCupDataProcFlow: (args: {
    data: CupDataProcFlowUpdateInput;
    where: CupDataProcFlowWhereUniqueInput;
  }) => CupDataProcFlowPromise;
  updateManyCupDataProcFlows: (args: {
    data: CupDataProcFlowUpdateManyMutationInput;
    where?: CupDataProcFlowWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataProcFlow: (args: {
    where: CupDataProcFlowWhereUniqueInput;
    create: CupDataProcFlowCreateInput;
    update: CupDataProcFlowUpdateInput;
  }) => CupDataProcFlowPromise;
  deleteCupDataProcFlow: (
    where: CupDataProcFlowWhereUniqueInput
  ) => CupDataProcFlowPromise;
  deleteManyCupDataProcFlows: (
    where?: CupDataProcFlowWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcMdate: (
    data: CupDataProcMdateCreateInput
  ) => CupDataProcMdatePromise;
  updateCupDataProcMdate: (args: {
    data: CupDataProcMdateUpdateInput;
    where: CupDataProcMdateWhereUniqueInput;
  }) => CupDataProcMdatePromise;
  updateManyCupDataProcMdates: (args: {
    data: CupDataProcMdateUpdateManyMutationInput;
    where?: CupDataProcMdateWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataProcMdate: (args: {
    where: CupDataProcMdateWhereUniqueInput;
    create: CupDataProcMdateCreateInput;
    update: CupDataProcMdateUpdateInput;
  }) => CupDataProcMdatePromise;
  deleteCupDataProcMdate: (
    where: CupDataProcMdateWhereUniqueInput
  ) => CupDataProcMdatePromise;
  deleteManyCupDataProcMdates: (
    where?: CupDataProcMdateWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcVolume: (
    data: CupDataProcVolumeCreateInput
  ) => CupDataProcVolumePromise;
  updateCupDataProcVolume: (args: {
    data: CupDataProcVolumeUpdateInput;
    where: CupDataProcVolumeWhereUniqueInput;
  }) => CupDataProcVolumePromise;
  updateManyCupDataProcVolumes: (args: {
    data: CupDataProcVolumeUpdateManyMutationInput;
    where?: CupDataProcVolumeWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataProcVolume: (args: {
    where: CupDataProcVolumeWhereUniqueInput;
    create: CupDataProcVolumeCreateInput;
    update: CupDataProcVolumeUpdateInput;
  }) => CupDataProcVolumePromise;
  deleteCupDataProcVolume: (
    where: CupDataProcVolumeWhereUniqueInput
  ) => CupDataProcVolumePromise;
  deleteManyCupDataProcVolumes: (
    where?: CupDataProcVolumeWhereInput
  ) => BatchPayloadPromise;
  createCupDataQaResponse: (
    data: CupDataQaResponseCreateInput
  ) => CupDataQaResponsePromise;
  updateCupDataQaResponse: (args: {
    data: CupDataQaResponseUpdateInput;
    where: CupDataQaResponseWhereUniqueInput;
  }) => CupDataQaResponsePromise;
  updateManyCupDataQaResponses: (args: {
    data: CupDataQaResponseUpdateManyMutationInput;
    where?: CupDataQaResponseWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataQaResponse: (args: {
    where: CupDataQaResponseWhereUniqueInput;
    create: CupDataQaResponseCreateInput;
    update: CupDataQaResponseUpdateInput;
  }) => CupDataQaResponsePromise;
  deleteCupDataQaResponse: (
    where: CupDataQaResponseWhereUniqueInput
  ) => CupDataQaResponsePromise;
  deleteManyCupDataQaResponses: (
    where?: CupDataQaResponseWhereInput
  ) => BatchPayloadPromise;
  createCupDataQuestion: (
    data: CupDataQuestionCreateInput
  ) => CupDataQuestionPromise;
  updateCupDataQuestion: (args: {
    data: CupDataQuestionUpdateInput;
    where: CupDataQuestionWhereUniqueInput;
  }) => CupDataQuestionPromise;
  updateManyCupDataQuestions: (args: {
    data: CupDataQuestionUpdateManyMutationInput;
    where?: CupDataQuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataQuestion: (args: {
    where: CupDataQuestionWhereUniqueInput;
    create: CupDataQuestionCreateInput;
    update: CupDataQuestionUpdateInput;
  }) => CupDataQuestionPromise;
  deleteCupDataQuestion: (
    where: CupDataQuestionWhereUniqueInput
  ) => CupDataQuestionPromise;
  deleteManyCupDataQuestions: (
    where?: CupDataQuestionWhereInput
  ) => BatchPayloadPromise;
  createCupDataRaw: (data: CupDataRawCreateInput) => CupDataRawPromise;
  updateCupDataRaw: (args: {
    data: CupDataRawUpdateInput;
    where: CupDataRawWhereUniqueInput;
  }) => CupDataRawPromise;
  updateManyCupDataRaws: (args: {
    data: CupDataRawUpdateManyMutationInput;
    where?: CupDataRawWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataRaw: (args: {
    where: CupDataRawWhereUniqueInput;
    create: CupDataRawCreateInput;
    update: CupDataRawUpdateInput;
  }) => CupDataRawPromise;
  deleteCupDataRaw: (where: CupDataRawWhereUniqueInput) => CupDataRawPromise;
  deleteManyCupDataRaws: (where?: CupDataRawWhereInput) => BatchPayloadPromise;
  createCupDataRejection: (
    data: CupDataRejectionCreateInput
  ) => CupDataRejectionPromise;
  updateCupDataRejection: (args: {
    data: CupDataRejectionUpdateInput;
    where: CupDataRejectionWhereUniqueInput;
  }) => CupDataRejectionPromise;
  updateManyCupDataRejections: (args: {
    data: CupDataRejectionUpdateManyMutationInput;
    where?: CupDataRejectionWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataRejection: (args: {
    where: CupDataRejectionWhereUniqueInput;
    create: CupDataRejectionCreateInput;
    update: CupDataRejectionUpdateInput;
  }) => CupDataRejectionPromise;
  deleteCupDataRejection: (
    where: CupDataRejectionWhereUniqueInput
  ) => CupDataRejectionPromise;
  deleteManyCupDataRejections: (
    where?: CupDataRejectionWhereInput
  ) => BatchPayloadPromise;
  createCupDataUserRemove: (
    data: CupDataUserRemoveCreateInput
  ) => CupDataUserRemovePromise;
  updateCupDataUserRemove: (args: {
    data: CupDataUserRemoveUpdateInput;
    where: CupDataUserRemoveWhereUniqueInput;
  }) => CupDataUserRemovePromise;
  updateManyCupDataUserRemoves: (args: {
    data: CupDataUserRemoveUpdateManyMutationInput;
    where?: CupDataUserRemoveWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataUserRemove: (args: {
    where: CupDataUserRemoveWhereUniqueInput;
    create: CupDataUserRemoveCreateInput;
    update: CupDataUserRemoveUpdateInput;
  }) => CupDataUserRemovePromise;
  deleteCupDataUserRemove: (
    where: CupDataUserRemoveWhereUniqueInput
  ) => CupDataUserRemovePromise;
  deleteManyCupDataUserRemoves: (
    where?: CupDataUserRemoveWhereInput
  ) => BatchPayloadPromise;
  createCupDataUserRemoveExplain: (
    data: CupDataUserRemoveExplainCreateInput
  ) => CupDataUserRemoveExplainPromise;
  updateCupDataUserRemoveExplain: (args: {
    data: CupDataUserRemoveExplainUpdateInput;
    where: CupDataUserRemoveExplainWhereUniqueInput;
  }) => CupDataUserRemoveExplainPromise;
  updateManyCupDataUserRemoveExplains: (args: {
    data: CupDataUserRemoveExplainUpdateManyMutationInput;
    where?: CupDataUserRemoveExplainWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDataUserRemoveExplain: (args: {
    where: CupDataUserRemoveExplainWhereUniqueInput;
    create: CupDataUserRemoveExplainCreateInput;
    update: CupDataUserRemoveExplainUpdateInput;
  }) => CupDataUserRemoveExplainPromise;
  deleteCupDataUserRemoveExplain: (
    where: CupDataUserRemoveExplainWhereUniqueInput
  ) => CupDataUserRemoveExplainPromise;
  deleteManyCupDataUserRemoveExplains: (
    where?: CupDataUserRemoveExplainWhereInput
  ) => BatchPayloadPromise;
  createCupDatum: (data: CupDatumCreateInput) => CupDatumPromise;
  updateCupDatum: (args: {
    data: CupDatumUpdateInput;
    where: CupDatumWhereUniqueInput;
  }) => CupDatumPromise;
  updateManyCupData: (args: {
    data: CupDatumUpdateManyMutationInput;
    where?: CupDatumWhereInput;
  }) => BatchPayloadPromise;
  upsertCupDatum: (args: {
    where: CupDatumWhereUniqueInput;
    create: CupDatumCreateInput;
    update: CupDatumUpdateInput;
  }) => CupDatumPromise;
  deleteCupDatum: (where: CupDatumWhereUniqueInput) => CupDatumPromise;
  deleteManyCupData: (where?: CupDatumWhereInput) => BatchPayloadPromise;
  createEthnicity: (data: EthnicityCreateInput) => EthnicityPromise;
  updateEthnicity: (args: {
    data: EthnicityUpdateInput;
    where: EthnicityWhereUniqueInput;
  }) => EthnicityPromise;
  updateManyEthnicities: (args: {
    data: EthnicityUpdateManyMutationInput;
    where?: EthnicityWhereInput;
  }) => BatchPayloadPromise;
  upsertEthnicity: (args: {
    where: EthnicityWhereUniqueInput;
    create: EthnicityCreateInput;
    update: EthnicityUpdateInput;
  }) => EthnicityPromise;
  deleteEthnicity: (where: EthnicityWhereUniqueInput) => EthnicityPromise;
  deleteManyEthnicities: (where?: EthnicityWhereInput) => BatchPayloadPromise;
  createFirmware: (data: FirmwareCreateInput) => FirmwarePromise;
  updateFirmware: (args: {
    data: FirmwareUpdateInput;
    where: FirmwareWhereUniqueInput;
  }) => FirmwarePromise;
  updateManyFirmwares: (args: {
    data: FirmwareUpdateManyMutationInput;
    where?: FirmwareWhereInput;
  }) => BatchPayloadPromise;
  upsertFirmware: (args: {
    where: FirmwareWhereUniqueInput;
    create: FirmwareCreateInput;
    update: FirmwareUpdateInput;
  }) => FirmwarePromise;
  deleteFirmware: (where: FirmwareWhereUniqueInput) => FirmwarePromise;
  deleteManyFirmwares: (where?: FirmwareWhereInput) => BatchPayloadPromise;
  createHardware: (data: HardwareCreateInput) => HardwarePromise;
  updateHardware: (args: {
    data: HardwareUpdateInput;
    where: HardwareWhereUniqueInput;
  }) => HardwarePromise;
  updateManyHardwares: (args: {
    data: HardwareUpdateManyMutationInput;
    where?: HardwareWhereInput;
  }) => BatchPayloadPromise;
  upsertHardware: (args: {
    where: HardwareWhereUniqueInput;
    create: HardwareCreateInput;
    update: HardwareUpdateInput;
  }) => HardwarePromise;
  deleteHardware: (where: HardwareWhereUniqueInput) => HardwarePromise;
  deleteManyHardwares: (where?: HardwareWhereInput) => BatchPayloadPromise;
  createPlatformComp: (data: PlatformCompCreateInput) => PlatformCompPromise;
  updatePlatformComp: (args: {
    data: PlatformCompUpdateInput;
    where: PlatformCompWhereUniqueInput;
  }) => PlatformCompPromise;
  updateManyPlatformComps: (args: {
    data: PlatformCompUpdateManyMutationInput;
    where?: PlatformCompWhereInput;
  }) => BatchPayloadPromise;
  upsertPlatformComp: (args: {
    where: PlatformCompWhereUniqueInput;
    create: PlatformCompCreateInput;
    update: PlatformCompUpdateInput;
  }) => PlatformCompPromise;
  deletePlatformComp: (
    where: PlatformCompWhereUniqueInput
  ) => PlatformCompPromise;
  deleteManyPlatformComps: (
    where?: PlatformCompWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserCoinHistory: (
    data: UserCoinHistoryCreateInput
  ) => UserCoinHistoryPromise;
  updateUserCoinHistory: (args: {
    data: UserCoinHistoryUpdateInput;
    where: UserCoinHistoryWhereUniqueInput;
  }) => UserCoinHistoryPromise;
  updateManyUserCoinHistories: (args: {
    data: UserCoinHistoryUpdateManyMutationInput;
    where?: UserCoinHistoryWhereInput;
  }) => BatchPayloadPromise;
  upsertUserCoinHistory: (args: {
    where: UserCoinHistoryWhereUniqueInput;
    create: UserCoinHistoryCreateInput;
    update: UserCoinHistoryUpdateInput;
  }) => UserCoinHistoryPromise;
  deleteUserCoinHistory: (
    where: UserCoinHistoryWhereUniqueInput
  ) => UserCoinHistoryPromise;
  deleteManyUserCoinHistories: (
    where?: UserCoinHistoryWhereInput
  ) => BatchPayloadPromise;
  createUserInterviewDatum: (
    data: UserInterviewDatumCreateInput
  ) => UserInterviewDatumPromise;
  updateUserInterviewDatum: (args: {
    data: UserInterviewDatumUpdateInput;
    where: UserInterviewDatumWhereUniqueInput;
  }) => UserInterviewDatumPromise;
  updateManyUserInterviewData: (args: {
    data: UserInterviewDatumUpdateManyMutationInput;
    where?: UserInterviewDatumWhereInput;
  }) => BatchPayloadPromise;
  upsertUserInterviewDatum: (args: {
    where: UserInterviewDatumWhereUniqueInput;
    create: UserInterviewDatumCreateInput;
    update: UserInterviewDatumUpdateInput;
  }) => UserInterviewDatumPromise;
  deleteUserInterviewDatum: (
    where: UserInterviewDatumWhereUniqueInput
  ) => UserInterviewDatumPromise;
  deleteManyUserInterviewData: (
    where?: UserInterviewDatumWhereInput
  ) => BatchPayloadPromise;
  createUserInterviewQuestion: (
    data: UserInterviewQuestionCreateInput
  ) => UserInterviewQuestionPromise;
  updateUserInterviewQuestion: (args: {
    data: UserInterviewQuestionUpdateInput;
    where: UserInterviewQuestionWhereUniqueInput;
  }) => UserInterviewQuestionPromise;
  updateManyUserInterviewQuestions: (args: {
    data: UserInterviewQuestionUpdateManyMutationInput;
    where?: UserInterviewQuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertUserInterviewQuestion: (args: {
    where: UserInterviewQuestionWhereUniqueInput;
    create: UserInterviewQuestionCreateInput;
    update: UserInterviewQuestionUpdateInput;
  }) => UserInterviewQuestionPromise;
  deleteUserInterviewQuestion: (
    where: UserInterviewQuestionWhereUniqueInput
  ) => UserInterviewQuestionPromise;
  deleteManyUserInterviewQuestions: (
    where?: UserInterviewQuestionWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByDay: (
    data: UserRecordDataByDayCreateInput
  ) => UserRecordDataByDayPromise;
  updateUserRecordDataByDay: (args: {
    data: UserRecordDataByDayUpdateInput;
    where: UserRecordDataByDayWhereUniqueInput;
  }) => UserRecordDataByDayPromise;
  updateManyUserRecordDataByDays: (args: {
    data: UserRecordDataByDayUpdateManyMutationInput;
    where?: UserRecordDataByDayWhereInput;
  }) => BatchPayloadPromise;
  upsertUserRecordDataByDay: (args: {
    where: UserRecordDataByDayWhereUniqueInput;
    create: UserRecordDataByDayCreateInput;
    update: UserRecordDataByDayUpdateInput;
  }) => UserRecordDataByDayPromise;
  deleteUserRecordDataByDay: (
    where: UserRecordDataByDayWhereUniqueInput
  ) => UserRecordDataByDayPromise;
  deleteManyUserRecordDataByDays: (
    where?: UserRecordDataByDayWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByPeriod: (
    data: UserRecordDataByPeriodCreateInput
  ) => UserRecordDataByPeriodPromise;
  updateUserRecordDataByPeriod: (args: {
    data: UserRecordDataByPeriodUpdateInput;
    where: UserRecordDataByPeriodWhereUniqueInput;
  }) => UserRecordDataByPeriodPromise;
  updateManyUserRecordDataByPeriods: (args: {
    data: UserRecordDataByPeriodUpdateManyMutationInput;
    where?: UserRecordDataByPeriodWhereInput;
  }) => BatchPayloadPromise;
  upsertUserRecordDataByPeriod: (args: {
    where: UserRecordDataByPeriodWhereUniqueInput;
    create: UserRecordDataByPeriodCreateInput;
    update: UserRecordDataByPeriodUpdateInput;
  }) => UserRecordDataByPeriodPromise;
  deleteUserRecordDataByPeriod: (
    where: UserRecordDataByPeriodWhereUniqueInput
  ) => UserRecordDataByPeriodPromise;
  deleteManyUserRecordDataByPeriods: (
    where?: UserRecordDataByPeriodWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByTime: (
    data: UserRecordDataByTimeCreateInput
  ) => UserRecordDataByTimePromise;
  updateUserRecordDataByTime: (args: {
    data: UserRecordDataByTimeUpdateInput;
    where: UserRecordDataByTimeWhereUniqueInput;
  }) => UserRecordDataByTimePromise;
  updateManyUserRecordDataByTimes: (args: {
    data: UserRecordDataByTimeUpdateManyMutationInput;
    where?: UserRecordDataByTimeWhereInput;
  }) => BatchPayloadPromise;
  upsertUserRecordDataByTime: (args: {
    where: UserRecordDataByTimeWhereUniqueInput;
    create: UserRecordDataByTimeCreateInput;
    update: UserRecordDataByTimeUpdateInput;
  }) => UserRecordDataByTimePromise;
  deleteUserRecordDataByTime: (
    where: UserRecordDataByTimeWhereUniqueInput
  ) => UserRecordDataByTimePromise;
  deleteManyUserRecordDataByTimes: (
    where?: UserRecordDataByTimeWhereInput
  ) => BatchPayloadPromise;
  createUsersDataAnalysis: (
    data: UsersDataAnalysisCreateInput
  ) => UsersDataAnalysisPromise;
  updateUsersDataAnalysis: (args: {
    data: UsersDataAnalysisUpdateInput;
    where: UsersDataAnalysisWhereUniqueInput;
  }) => UsersDataAnalysisPromise;
  updateManyUsersDataAnalyses: (args: {
    data: UsersDataAnalysisUpdateManyMutationInput;
    where?: UsersDataAnalysisWhereInput;
  }) => BatchPayloadPromise;
  upsertUsersDataAnalysis: (args: {
    where: UsersDataAnalysisWhereUniqueInput;
    create: UsersDataAnalysisCreateInput;
    update: UsersDataAnalysisUpdateInput;
  }) => UsersDataAnalysisPromise;
  deleteUsersDataAnalysis: (
    where: UsersDataAnalysisWhereUniqueInput
  ) => UsersDataAnalysisPromise;
  deleteManyUsersDataAnalyses: (
    where?: UsersDataAnalysisWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  answerType: (
    where?: AnswerTypeSubscriptionWhereInput
  ) => AnswerTypeSubscriptionPayloadSubscription;
  appServerSync: (
    where?: AppServerSyncSubscriptionWhereInput
  ) => AppServerSyncSubscriptionPayloadSubscription;
  authToken: (
    where?: AuthTokenSubscriptionWhereInput
  ) => AuthTokenSubscriptionPayloadSubscription;
  calibration: (
    where?: CalibrationSubscriptionWhereInput
  ) => CalibrationSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  cup: (
    where?: CupSubscriptionWhereInput
  ) => CupSubscriptionPayloadSubscription;
  cupAppSync: (
    where?: CupAppSyncSubscriptionWhereInput
  ) => CupAppSyncSubscriptionPayloadSubscription;
  cupDataAnswer: (
    where?: CupDataAnswerSubscriptionWhereInput
  ) => CupDataAnswerSubscriptionPayloadSubscription;
  cupDataColourCalc: (
    where?: CupDataColourCalcSubscriptionWhereInput
  ) => CupDataColourCalcSubscriptionPayloadSubscription;
  cupDataColourCalib: (
    where?: CupDataColourCalibSubscriptionWhereInput
  ) => CupDataColourCalibSubscriptionPayloadSubscription;
  cupDataManMdate: (
    where?: CupDataManMdateSubscriptionWhereInput
  ) => CupDataManMdateSubscriptionPayloadSubscription;
  cupDataProcFlow: (
    where?: CupDataProcFlowSubscriptionWhereInput
  ) => CupDataProcFlowSubscriptionPayloadSubscription;
  cupDataProcMdate: (
    where?: CupDataProcMdateSubscriptionWhereInput
  ) => CupDataProcMdateSubscriptionPayloadSubscription;
  cupDataProcVolume: (
    where?: CupDataProcVolumeSubscriptionWhereInput
  ) => CupDataProcVolumeSubscriptionPayloadSubscription;
  cupDataQaResponse: (
    where?: CupDataQaResponseSubscriptionWhereInput
  ) => CupDataQaResponseSubscriptionPayloadSubscription;
  cupDataQuestion: (
    where?: CupDataQuestionSubscriptionWhereInput
  ) => CupDataQuestionSubscriptionPayloadSubscription;
  cupDataRaw: (
    where?: CupDataRawSubscriptionWhereInput
  ) => CupDataRawSubscriptionPayloadSubscription;
  cupDataRejection: (
    where?: CupDataRejectionSubscriptionWhereInput
  ) => CupDataRejectionSubscriptionPayloadSubscription;
  cupDataUserRemove: (
    where?: CupDataUserRemoveSubscriptionWhereInput
  ) => CupDataUserRemoveSubscriptionPayloadSubscription;
  cupDataUserRemoveExplain: (
    where?: CupDataUserRemoveExplainSubscriptionWhereInput
  ) => CupDataUserRemoveExplainSubscriptionPayloadSubscription;
  cupDatum: (
    where?: CupDatumSubscriptionWhereInput
  ) => CupDatumSubscriptionPayloadSubscription;
  ethnicity: (
    where?: EthnicitySubscriptionWhereInput
  ) => EthnicitySubscriptionPayloadSubscription;
  firmware: (
    where?: FirmwareSubscriptionWhereInput
  ) => FirmwareSubscriptionPayloadSubscription;
  hardware: (
    where?: HardwareSubscriptionWhereInput
  ) => HardwareSubscriptionPayloadSubscription;
  platformComp: (
    where?: PlatformCompSubscriptionWhereInput
  ) => PlatformCompSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userCoinHistory: (
    where?: UserCoinHistorySubscriptionWhereInput
  ) => UserCoinHistorySubscriptionPayloadSubscription;
  userInterviewDatum: (
    where?: UserInterviewDatumSubscriptionWhereInput
  ) => UserInterviewDatumSubscriptionPayloadSubscription;
  userInterviewQuestion: (
    where?: UserInterviewQuestionSubscriptionWhereInput
  ) => UserInterviewQuestionSubscriptionPayloadSubscription;
  userRecordDataByDay: (
    where?: UserRecordDataByDaySubscriptionWhereInput
  ) => UserRecordDataByDaySubscriptionPayloadSubscription;
  userRecordDataByPeriod: (
    where?: UserRecordDataByPeriodSubscriptionWhereInput
  ) => UserRecordDataByPeriodSubscriptionPayloadSubscription;
  userRecordDataByTime: (
    where?: UserRecordDataByTimeSubscriptionWhereInput
  ) => UserRecordDataByTimeSubscriptionPayloadSubscription;
  usersDataAnalysis: (
    where?: UsersDataAnalysisSubscriptionWhereInput
  ) => UsersDataAnalysisSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserCoinHistoryOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "coin_ASC"
  | "coin_DESC"
  | "contents_ASC"
  | "contents_DESC"
  | "date_ASC"
  | "date_DESC"
  | "txhash_ASC"
  | "txhash_DESC";

export type UserInterviewQuestionOrderByInput =
  | "question_id_ASC"
  | "question_id_DESC"
  | "question_ASC"
  | "question_DESC";

export type UserCupOrderByInput = "row_id_ASC" | "row_id_DESC";

export type UsersDataAnalysisOrderByInput =
  | "idx_ASC"
  | "idx_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "password_ASC"
  | "password_DESC"
  | "userId_ASC"
  | "userId_DESC";

export type CupDataRawOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "pageData_ASC"
  | "pageData_DESC";

export type HardwareOrderByInput =
  | "hw_id_ASC"
  | "hw_id_DESC"
  | "hwVersion_ASC"
  | "hwVersion_DESC";

export type CupDataColourCalibOrderByInput =
  | "cup_data_colour_calib_id_ASC"
  | "cup_data_colour_calib_id_DESC"
  | "blue_ASC"
  | "blue_DESC"
  | "c_ASC"
  | "c_DESC"
  | "green_ASC"
  | "green_DESC"
  | "red_ASC"
  | "red_DESC";

export type EthnicityOrderByInput =
  | "ethnicity_id_ASC"
  | "ethnicity_id_DESC"
  | "ethnicity_ASC"
  | "ethnicity_DESC";

export type CupDataProcVolumeOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "confidenceL_ASC"
  | "confidenceL_DESC"
  | "confidenceR_ASC"
  | "confidenceR_DESC"
  | "inVitro_ASC"
  | "inVitro_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "volumeAdj_ASC"
  | "volumeAdj_DESC"
  | "volumeL_ASC"
  | "volumeL_DESC"
  | "volumeR_ASC"
  | "volumeR_DESC";

export type CupDataRejectionOrderByInput =
  | "reject_id_ASC"
  | "reject_id_DESC"
  | "rejectionDescription_ASC"
  | "rejectionDescription_DESC";

export type CupDataColourCalcOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "blue_ASC"
  | "blue_DESC"
  | "green_ASC"
  | "green_DESC"
  | "red_ASC"
  | "red_DESC";

export type CountryOrderByInput =
  | "country_id_ASC"
  | "country_id_DESC"
  | "countryName_ASC"
  | "countryName_DESC";

export type CupDatumOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "battery_ASC"
  | "battery_DESC"
  | "calibFlag_ASC"
  | "calibFlag_DESC"
  | "ch1_ASC"
  | "ch1_DESC"
  | "ch10_ASC"
  | "ch10_DESC"
  | "ch11_ASC"
  | "ch11_DESC"
  | "ch12_ASC"
  | "ch12_DESC"
  | "ch13_ASC"
  | "ch13_DESC"
  | "ch14_ASC"
  | "ch14_DESC"
  | "ch2_ASC"
  | "ch2_DESC"
  | "ch3_ASC"
  | "ch3_DESC"
  | "ch4_ASC"
  | "ch4_DESC"
  | "ch5_ASC"
  | "ch5_DESC"
  | "ch6_ASC"
  | "ch6_DESC"
  | "ch7_ASC"
  | "ch7_DESC"
  | "ch8_ASC"
  | "ch8_DESC"
  | "ch9_ASC"
  | "ch9_DESC"
  | "colourB_ASC"
  | "colourB_DESC"
  | "colourC_ASC"
  | "colourC_DESC"
  | "colourG_ASC"
  | "colourG_DESC"
  | "colourR_ASC"
  | "colourR_DESC"
  | "date_ASC"
  | "date_DESC"
  | "day_ASC"
  | "day_DESC"
  | "hour_ASC"
  | "hour_DESC"
  | "line_ASC"
  | "line_DESC"
  | "minute_ASC"
  | "minute_DESC"
  | "month_ASC"
  | "month_DESC"
  | "page_ASC"
  | "page_DESC"
  | "rawTotalVolume_ASC"
  | "rawTotalVolume_DESC"
  | "rawVolumeL_ASC"
  | "rawVolumeL_DESC"
  | "rawVolumeR_ASC"
  | "rawVolumeR_DESC"
  | "temperature_ASC"
  | "temperature_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "year_ASC"
  | "year_DESC"
  | "z_ASC"
  | "z_DESC";

export type CalibrationOrderByInput =
  | "calib_id_ASC"
  | "calib_id_DESC"
  | "calibVersion_ASC"
  | "calibVersion_DESC";

export type CupAppSyncOrderByInput =
  | "cup_app_sync_id_ASC"
  | "cup_app_sync_id_DESC"
  | "appSynchTime_ASC"
  | "appSynchTime_DESC";

export type AnswerTypeOrderByInput =
  | "answer_type_id_ASC"
  | "answer_type_id_DESC"
  | "answerType_ASC"
  | "answerType_DESC";

export type CupOrderByInput =
  | "serial_number_ASC"
  | "serial_number_DESC"
  | "anonSerialNumber_ASC"
  | "anonSerialNumber_DESC"
  | "encryptionKey_ASC"
  | "encryptionKey_DESC";

export type UserRecordDataByDayOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "crampsLevel_ASC"
  | "crampsLevel_DESC"
  | "recordDate_ASC"
  | "recordDate_DESC";

export type CupDataUserRemoveOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "changeTime_ASC"
  | "changeTime_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CupDataAnswerOrderByInput =
  | "answer_id_ASC"
  | "answer_id_DESC"
  | "answerText_ASC"
  | "answerText_DESC";

export type FirmwareOrderByInput =
  | "fw_id_ASC"
  | "fw_id_DESC"
  | "fwVersion_ASC"
  | "fwVersion_DESC";

export type CupDataQaResponseOrderByInput =
  | "cup_data_qa_response_id_ASC"
  | "cup_data_qa_response_id_DESC"
  | "qaDate_ASC"
  | "qaDate_DESC";

export type CupDataQuestionOrderByInput =
  | "question_id_ASC"
  | "question_id_DESC"
  | "questionText_ASC"
  | "questionText_DESC";

export type CupDataProcMdateOrderByInput =
  | "mdate_row_id_ASC"
  | "mdate_row_id_DESC"
  | "dataRejected_ASC"
  | "dataRejected_DESC"
  | "dataVerified_ASC"
  | "dataVerified_DESC"
  | "menFinish_ASC"
  | "menFinish_DESC"
  | "menStart_ASC"
  | "menStart_DESC"
  | "rewardAmount_ASC"
  | "rewardAmount_DESC";

export type AuthTokenOrderByInput = "user_id_ASC" | "user_id_DESC";

export type CupDataManMdateOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "menFinish_ASC"
  | "menFinish_DESC"
  | "menStart_ASC"
  | "menStart_DESC";

export type UserRecordDataByPeriodOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "isTakePill_ASC"
  | "isTakePill_DESC"
  | "mensFinish_ASC"
  | "mensFinish_DESC"
  | "mensStart_ASC"
  | "mensStart_DESC";

export type UserInterviewDatumOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "answerRange_ASC"
  | "answerRange_DESC"
  | "answerText_ASC"
  | "answerText_DESC"
  | "answerYn_ASC"
  | "answerYn_DESC"
  | "date_ASC"
  | "date_DESC";

export type AppServerSyncOrderByInput =
  | "app_server_sync_id_ASC"
  | "app_server_sync_id_DESC"
  | "serverSynchTime_ASC"
  | "serverSynchTime_DESC";

export type UserOrderByInput =
  | "user_id_ASC"
  | "user_id_DESC"
  | "anonUserId_ASC"
  | "anonUserId_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "email_ASC"
  | "email_DESC"
  | "encryptSaltString_ASC"
  | "encryptSaltString_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "givenBirth_ASC"
  | "givenBirth_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "password_ASC"
  | "password_DESC";

export type CupDataProcFlowOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "hourlyFlow_ASC"
  | "hourlyFlow_DESC";

export type PlatformCompOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "phoneId_ASC"
  | "phoneId_DESC"
  | "platformId_ASC"
  | "platformId_DESC"
  | "problemHistory_ASC"
  | "problemHistory_DESC"
  | "softwareId_ASC"
  | "softwareId_DESC"
  | "successHistory_ASC"
  | "successHistory_DESC";

export type UserRecordDataByTimeOrderByInput =
  | "row_id_ASC"
  | "row_id_DESC"
  | "changeTime_ASC"
  | "changeTime_DESC"
  | "colorB_ASC"
  | "colorB_DESC"
  | "colorG_ASC"
  | "colorG_DESC"
  | "colorR_ASC"
  | "colorR_DESC"
  | "leakage_ASC"
  | "leakage_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "volume_ASC"
  | "volume_DESC";

export type CompanyOrderByInput =
  | "company_id_ASC"
  | "company_id_DESC"
  | "companyName_ASC"
  | "companyName_DESC";

export type CupDataUserRemoveExplainOrderByInput =
  | "explain_id_ASC"
  | "explain_id_DESC"
  | "explain_ASC"
  | "explain_DESC";

export interface CupDatumUpdateManyDataInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export type AnswerTypeWhereUniqueInput = AtLeastOne<{
  answer_type_id: Maybe<Int>;
  answerType?: Maybe<String>;
}>;

export interface AppServerSyncUpdateWithWhereUniqueWithoutUserInput {
  where: AppServerSyncWhereUniqueInput;
  data: AppServerSyncUpdateWithoutUserDataInput;
}

export interface CupDataProcMdateUpdateManyMutationInput {
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  rewardAmount?: Maybe<Int>;
}

export interface AppServerSyncUpdateWithoutUserDataInput {
  serverSynchTime?: Maybe<DateTimeInput>;
}

export interface HardwareUpdateWithoutCupDataInput {
  hwVersion?: Maybe<String>;
}

export interface AppServerSyncUpsertWithWhereUniqueWithoutUserInput {
  where: AppServerSyncWhereUniqueInput;
  update: AppServerSyncUpdateWithoutUserDataInput;
  create: AppServerSyncCreateWithoutUserInput;
}

export interface UserRecordDataByDayWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  crampsLevel?: Maybe<Int>;
  crampsLevel_not?: Maybe<Int>;
  crampsLevel_in?: Maybe<Int[] | Int>;
  crampsLevel_not_in?: Maybe<Int[] | Int>;
  crampsLevel_lt?: Maybe<Int>;
  crampsLevel_lte?: Maybe<Int>;
  crampsLevel_gt?: Maybe<Int>;
  crampsLevel_gte?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
  recordDate_not?: Maybe<DateTimeInput>;
  recordDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  recordDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  recordDate_lt?: Maybe<DateTimeInput>;
  recordDate_lte?: Maybe<DateTimeInput>;
  recordDate_gt?: Maybe<DateTimeInput>;
  recordDate_gte?: Maybe<DateTimeInput>;
  recordPeriodRow?: Maybe<UserRecordDataByPeriodWhereInput>;
  userRecordDataByTime_every?: Maybe<UserRecordDataByTimeWhereInput>;
  userRecordDataByTime_some?: Maybe<UserRecordDataByTimeWhereInput>;
  userRecordDataByTime_none?: Maybe<UserRecordDataByTimeWhereInput>;
  AND?: Maybe<UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput>;
  OR?: Maybe<UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput>;
  NOT?: Maybe<UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput>;
}

export interface AppServerSyncScalarWhereInput {
  app_server_sync_id?: Maybe<Int>;
  app_server_sync_id_not?: Maybe<Int>;
  app_server_sync_id_in?: Maybe<Int[] | Int>;
  app_server_sync_id_not_in?: Maybe<Int[] | Int>;
  app_server_sync_id_lt?: Maybe<Int>;
  app_server_sync_id_lte?: Maybe<Int>;
  app_server_sync_id_gt?: Maybe<Int>;
  app_server_sync_id_gte?: Maybe<Int>;
  serverSynchTime?: Maybe<DateTimeInput>;
  serverSynchTime_not?: Maybe<DateTimeInput>;
  serverSynchTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  serverSynchTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  serverSynchTime_lt?: Maybe<DateTimeInput>;
  serverSynchTime_lte?: Maybe<DateTimeInput>;
  serverSynchTime_gt?: Maybe<DateTimeInput>;
  serverSynchTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput>;
  OR?: Maybe<AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput>;
  NOT?: Maybe<AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput>;
}

export interface UserRecordDataByPeriodSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserRecordDataByPeriodWhereInput>;
  AND?: Maybe<
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput
  >;
}

export interface AppServerSyncUpdateManyWithWhereNestedInput {
  where: AppServerSyncScalarWhereInput;
  data: AppServerSyncUpdateManyDataInput;
}

export interface UserRecordDataByDaySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserRecordDataByDayWhereInput>;
  AND?: Maybe<
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput
  >;
}

export interface AppServerSyncUpdateManyDataInput {
  serverSynchTime?: Maybe<DateTimeInput>;
}

export interface UserCoinHistoryWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  coin?: Maybe<Int>;
  coin_not?: Maybe<Int>;
  coin_in?: Maybe<Int[] | Int>;
  coin_not_in?: Maybe<Int[] | Int>;
  coin_lt?: Maybe<Int>;
  coin_lte?: Maybe<Int>;
  coin_gt?: Maybe<Int>;
  coin_gte?: Maybe<Int>;
  contents?: Maybe<String>;
  contents_not?: Maybe<String>;
  contents_in?: Maybe<String[] | String>;
  contents_not_in?: Maybe<String[] | String>;
  contents_lt?: Maybe<String>;
  contents_lte?: Maybe<String>;
  contents_gt?: Maybe<String>;
  contents_gte?: Maybe<String>;
  contents_contains?: Maybe<String>;
  contents_not_contains?: Maybe<String>;
  contents_starts_with?: Maybe<String>;
  contents_not_starts_with?: Maybe<String>;
  contents_ends_with?: Maybe<String>;
  contents_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
  txhash_not?: Maybe<String>;
  txhash_in?: Maybe<String[] | String>;
  txhash_not_in?: Maybe<String[] | String>;
  txhash_lt?: Maybe<String>;
  txhash_lte?: Maybe<String>;
  txhash_gt?: Maybe<String>;
  txhash_gte?: Maybe<String>;
  txhash_contains?: Maybe<String>;
  txhash_not_contains?: Maybe<String>;
  txhash_starts_with?: Maybe<String>;
  txhash_not_starts_with?: Maybe<String>;
  txhash_ends_with?: Maybe<String>;
  txhash_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  userRecordDataByPeriod_every?: Maybe<UserRecordDataByPeriodWhereInput>;
  userRecordDataByPeriod_some?: Maybe<UserRecordDataByPeriodWhereInput>;
  userRecordDataByPeriod_none?: Maybe<UserRecordDataByPeriodWhereInput>;
  AND?: Maybe<UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput>;
  OR?: Maybe<UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput>;
  NOT?: Maybe<UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput>;
}

export interface CountryUpdateOneWithoutUsersInput {
  create?: Maybe<CountryCreateWithoutUsersInput>;
  update?: Maybe<CountryUpdateWithoutUsersDataInput>;
  upsert?: Maybe<CountryUpsertWithoutUsersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface UserInterviewDatumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserInterviewDatumWhereInput>;
  AND?: Maybe<
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput
  >;
}

export interface CountryUpdateWithoutUsersDataInput {
  countryName?: Maybe<String>;
}

export interface UserCupWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  serialNumber?: Maybe<CupWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<UserCupWhereInput[] | UserCupWhereInput>;
  OR?: Maybe<UserCupWhereInput[] | UserCupWhereInput>;
  NOT?: Maybe<UserCupWhereInput[] | UserCupWhereInput>;
}

export interface CountryUpsertWithoutUsersInput {
  update: CountryUpdateWithoutUsersDataInput;
  create: CountryCreateWithoutUsersInput;
}

export interface PlatformCompSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PlatformCompWhereInput>;
  AND?: Maybe<
    PlatformCompSubscriptionWhereInput[] | PlatformCompSubscriptionWhereInput
  >;
  OR?: Maybe<
    PlatformCompSubscriptionWhereInput[] | PlatformCompSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PlatformCompSubscriptionWhereInput[] | PlatformCompSubscriptionWhereInput
  >;
}

export interface CupDataProcFlowUpdateManyWithoutUserInput {
  create?: Maybe<
    | CupDataProcFlowCreateWithoutUserInput[]
    | CupDataProcFlowCreateWithoutUserInput
  >;
  delete?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  set?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataProcFlowUpdateWithWhereUniqueWithoutUserInput[]
    | CupDataProcFlowUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CupDataProcFlowUpsertWithWhereUniqueWithoutUserInput[]
    | CupDataProcFlowUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataProcFlowUpdateManyWithWhereNestedInput[]
    | CupDataProcFlowUpdateManyWithWhereNestedInput
  >;
}

export interface FirmwareWhereInput {
  fw_id?: Maybe<Int>;
  fw_id_not?: Maybe<Int>;
  fw_id_in?: Maybe<Int[] | Int>;
  fw_id_not_in?: Maybe<Int[] | Int>;
  fw_id_lt?: Maybe<Int>;
  fw_id_lte?: Maybe<Int>;
  fw_id_gt?: Maybe<Int>;
  fw_id_gte?: Maybe<Int>;
  cup_every?: Maybe<CupWhereInput>;
  cup_some?: Maybe<CupWhereInput>;
  cup_none?: Maybe<CupWhereInput>;
  fwVersion?: Maybe<String>;
  fwVersion_not?: Maybe<String>;
  fwVersion_in?: Maybe<String[] | String>;
  fwVersion_not_in?: Maybe<String[] | String>;
  fwVersion_lt?: Maybe<String>;
  fwVersion_lte?: Maybe<String>;
  fwVersion_gt?: Maybe<String>;
  fwVersion_gte?: Maybe<String>;
  fwVersion_contains?: Maybe<String>;
  fwVersion_not_contains?: Maybe<String>;
  fwVersion_starts_with?: Maybe<String>;
  fwVersion_not_starts_with?: Maybe<String>;
  fwVersion_ends_with?: Maybe<String>;
  fwVersion_not_ends_with?: Maybe<String>;
  AND?: Maybe<FirmwareWhereInput[] | FirmwareWhereInput>;
  OR?: Maybe<FirmwareWhereInput[] | FirmwareWhereInput>;
  NOT?: Maybe<FirmwareWhereInput[] | FirmwareWhereInput>;
}

export interface CupDataProcFlowUpdateWithWhereUniqueWithoutUserInput {
  where: CupDataProcFlowWhereUniqueInput;
  data: CupDataProcFlowUpdateWithoutUserDataInput;
}

export interface FirmwareSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FirmwareWhereInput>;
  AND?: Maybe<
    FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput
  >;
  OR?: Maybe<FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput>;
  NOT?: Maybe<
    FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput
  >;
}

export interface CupDataProcFlowUpdateWithoutUserDataInput {
  date?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
  mdateRow?: Maybe<
    CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput
  >;
}

export interface CupDataRawWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  pageData?: Maybe<String>;
  pageData_not?: Maybe<String>;
  pageData_in?: Maybe<String[] | String>;
  pageData_not_in?: Maybe<String[] | String>;
  pageData_lt?: Maybe<String>;
  pageData_lte?: Maybe<String>;
  pageData_gt?: Maybe<String>;
  pageData_gte?: Maybe<String>;
  pageData_contains?: Maybe<String>;
  pageData_not_contains?: Maybe<String>;
  pageData_starts_with?: Maybe<String>;
  pageData_not_starts_with?: Maybe<String>;
  pageData_ends_with?: Maybe<String>;
  pageData_not_ends_with?: Maybe<String>;
  serialNumber?: Maybe<CupWhereInput>;
  AND?: Maybe<CupDataRawWhereInput[] | CupDataRawWhereInput>;
  OR?: Maybe<CupDataRawWhereInput[] | CupDataRawWhereInput>;
  NOT?: Maybe<CupDataRawWhereInput[] | CupDataRawWhereInput>;
}

export interface CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput {
  create?: Maybe<CupDataProcMdateCreateWithoutCupDataProcFlowInput>;
  update?: Maybe<CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput>;
  upsert?: Maybe<CupDataProcMdateUpsertWithoutCupDataProcFlowInput>;
  connect?: Maybe<CupDataProcMdateWhereUniqueInput>;
}

export interface CupDatumSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDatumWhereInput>;
  AND?: Maybe<
    CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput
  >;
  OR?: Maybe<CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput>;
  NOT?: Maybe<
    CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput
  >;
}

export interface CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput {
  cupDataManMdates?: Maybe<CupDataManMdateUpdateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  reject?: Maybe<CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcMdatesInput>;
}

export interface CupDataUserRemoveSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataUserRemoveWhereInput>;
  AND?: Maybe<
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput
  >;
}

export interface CupDataManMdateUpdateManyWithoutMdateRowInput {
  create?: Maybe<
    | CupDataManMdateCreateWithoutMdateRowInput[]
    | CupDataManMdateCreateWithoutMdateRowInput
  >;
  delete?: Maybe<
    CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput
  >;
  set?: Maybe<
    CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowInput[]
    | CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowInput
  >;
  upsert?: Maybe<
    | CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowInput[]
    | CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowInput
  >;
  deleteMany?: Maybe<
    CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataManMdateUpdateManyWithWhereNestedInput[]
    | CupDataManMdateUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataProcVolumeWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  confidenceL?: Maybe<Int>;
  confidenceL_not?: Maybe<Int>;
  confidenceL_in?: Maybe<Int[] | Int>;
  confidenceL_not_in?: Maybe<Int[] | Int>;
  confidenceL_lt?: Maybe<Int>;
  confidenceL_lte?: Maybe<Int>;
  confidenceL_gt?: Maybe<Int>;
  confidenceL_gte?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  confidenceR_not?: Maybe<Int>;
  confidenceR_in?: Maybe<Int[] | Int>;
  confidenceR_not_in?: Maybe<Int[] | Int>;
  confidenceR_lt?: Maybe<Int>;
  confidenceR_lte?: Maybe<Int>;
  confidenceR_gt?: Maybe<Int>;
  confidenceR_gte?: Maybe<Int>;
  cupDataRow?: Maybe<CupDatumWhereInput>;
  inVitro?: Maybe<Boolean>;
  inVitro_not?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeAdj_not?: Maybe<Int>;
  volumeAdj_in?: Maybe<Int[] | Int>;
  volumeAdj_not_in?: Maybe<Int[] | Int>;
  volumeAdj_lt?: Maybe<Int>;
  volumeAdj_lte?: Maybe<Int>;
  volumeAdj_gt?: Maybe<Int>;
  volumeAdj_gte?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeL_not?: Maybe<Int>;
  volumeL_in?: Maybe<Int[] | Int>;
  volumeL_not_in?: Maybe<Int[] | Int>;
  volumeL_lt?: Maybe<Int>;
  volumeL_lte?: Maybe<Int>;
  volumeL_gt?: Maybe<Int>;
  volumeL_gte?: Maybe<Int>;
  volumeR?: Maybe<Int>;
  volumeR_not?: Maybe<Int>;
  volumeR_in?: Maybe<Int[] | Int>;
  volumeR_not_in?: Maybe<Int[] | Int>;
  volumeR_lt?: Maybe<Int>;
  volumeR_lte?: Maybe<Int>;
  volumeR_gt?: Maybe<Int>;
  volumeR_gte?: Maybe<Int>;
  AND?: Maybe<CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput>;
  OR?: Maybe<CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput>;
  NOT?: Maybe<CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput>;
}

export interface CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowInput {
  where: CupDataManMdateWhereUniqueInput;
  data: CupDataManMdateUpdateWithoutMdateRowDataInput;
}

export interface CupDataColourCalcWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  blue?: Maybe<Int>;
  blue_not?: Maybe<Int>;
  blue_in?: Maybe<Int[] | Int>;
  blue_not_in?: Maybe<Int[] | Int>;
  blue_lt?: Maybe<Int>;
  blue_lte?: Maybe<Int>;
  blue_gt?: Maybe<Int>;
  blue_gte?: Maybe<Int>;
  cupDataRow?: Maybe<CupDatumWhereInput>;
  green?: Maybe<Int>;
  green_not?: Maybe<Int>;
  green_in?: Maybe<Int[] | Int>;
  green_not_in?: Maybe<Int[] | Int>;
  green_lt?: Maybe<Int>;
  green_lte?: Maybe<Int>;
  green_gt?: Maybe<Int>;
  green_gte?: Maybe<Int>;
  red?: Maybe<Int>;
  red_not?: Maybe<Int>;
  red_in?: Maybe<Int[] | Int>;
  red_not_in?: Maybe<Int[] | Int>;
  red_lt?: Maybe<Int>;
  red_lte?: Maybe<Int>;
  red_gt?: Maybe<Int>;
  red_gte?: Maybe<Int>;
  AND?: Maybe<CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput>;
  OR?: Maybe<CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput>;
  NOT?: Maybe<CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput>;
}

export interface CupDataManMdateUpdateWithoutMdateRowDataInput {
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface CupDatumWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  battery?: Maybe<Int>;
  battery_not?: Maybe<Int>;
  battery_in?: Maybe<Int[] | Int>;
  battery_not_in?: Maybe<Int[] | Int>;
  battery_lt?: Maybe<Int>;
  battery_lte?: Maybe<Int>;
  battery_gt?: Maybe<Int>;
  battery_gte?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  calibFlag_not?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch1_not?: Maybe<Int>;
  ch1_in?: Maybe<Int[] | Int>;
  ch1_not_in?: Maybe<Int[] | Int>;
  ch1_lt?: Maybe<Int>;
  ch1_lte?: Maybe<Int>;
  ch1_gt?: Maybe<Int>;
  ch1_gte?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch10_not?: Maybe<Int>;
  ch10_in?: Maybe<Int[] | Int>;
  ch10_not_in?: Maybe<Int[] | Int>;
  ch10_lt?: Maybe<Int>;
  ch10_lte?: Maybe<Int>;
  ch10_gt?: Maybe<Int>;
  ch10_gte?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch11_not?: Maybe<Int>;
  ch11_in?: Maybe<Int[] | Int>;
  ch11_not_in?: Maybe<Int[] | Int>;
  ch11_lt?: Maybe<Int>;
  ch11_lte?: Maybe<Int>;
  ch11_gt?: Maybe<Int>;
  ch11_gte?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch12_not?: Maybe<Int>;
  ch12_in?: Maybe<Int[] | Int>;
  ch12_not_in?: Maybe<Int[] | Int>;
  ch12_lt?: Maybe<Int>;
  ch12_lte?: Maybe<Int>;
  ch12_gt?: Maybe<Int>;
  ch12_gte?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch13_not?: Maybe<Int>;
  ch13_in?: Maybe<Int[] | Int>;
  ch13_not_in?: Maybe<Int[] | Int>;
  ch13_lt?: Maybe<Int>;
  ch13_lte?: Maybe<Int>;
  ch13_gt?: Maybe<Int>;
  ch13_gte?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch14_not?: Maybe<Int>;
  ch14_in?: Maybe<Int[] | Int>;
  ch14_not_in?: Maybe<Int[] | Int>;
  ch14_lt?: Maybe<Int>;
  ch14_lte?: Maybe<Int>;
  ch14_gt?: Maybe<Int>;
  ch14_gte?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch2_not?: Maybe<Int>;
  ch2_in?: Maybe<Int[] | Int>;
  ch2_not_in?: Maybe<Int[] | Int>;
  ch2_lt?: Maybe<Int>;
  ch2_lte?: Maybe<Int>;
  ch2_gt?: Maybe<Int>;
  ch2_gte?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch3_not?: Maybe<Int>;
  ch3_in?: Maybe<Int[] | Int>;
  ch3_not_in?: Maybe<Int[] | Int>;
  ch3_lt?: Maybe<Int>;
  ch3_lte?: Maybe<Int>;
  ch3_gt?: Maybe<Int>;
  ch3_gte?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch4_not?: Maybe<Int>;
  ch4_in?: Maybe<Int[] | Int>;
  ch4_not_in?: Maybe<Int[] | Int>;
  ch4_lt?: Maybe<Int>;
  ch4_lte?: Maybe<Int>;
  ch4_gt?: Maybe<Int>;
  ch4_gte?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch5_not?: Maybe<Int>;
  ch5_in?: Maybe<Int[] | Int>;
  ch5_not_in?: Maybe<Int[] | Int>;
  ch5_lt?: Maybe<Int>;
  ch5_lte?: Maybe<Int>;
  ch5_gt?: Maybe<Int>;
  ch5_gte?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch6_not?: Maybe<Int>;
  ch6_in?: Maybe<Int[] | Int>;
  ch6_not_in?: Maybe<Int[] | Int>;
  ch6_lt?: Maybe<Int>;
  ch6_lte?: Maybe<Int>;
  ch6_gt?: Maybe<Int>;
  ch6_gte?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch7_not?: Maybe<Int>;
  ch7_in?: Maybe<Int[] | Int>;
  ch7_not_in?: Maybe<Int[] | Int>;
  ch7_lt?: Maybe<Int>;
  ch7_lte?: Maybe<Int>;
  ch7_gt?: Maybe<Int>;
  ch7_gte?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch8_not?: Maybe<Int>;
  ch8_in?: Maybe<Int[] | Int>;
  ch8_not_in?: Maybe<Int[] | Int>;
  ch8_lt?: Maybe<Int>;
  ch8_lte?: Maybe<Int>;
  ch8_gt?: Maybe<Int>;
  ch8_gte?: Maybe<Int>;
  ch9?: Maybe<Int>;
  ch9_not?: Maybe<Int>;
  ch9_in?: Maybe<Int[] | Int>;
  ch9_not_in?: Maybe<Int[] | Int>;
  ch9_lt?: Maybe<Int>;
  ch9_lte?: Maybe<Int>;
  ch9_gt?: Maybe<Int>;
  ch9_gte?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourB_not?: Maybe<Int>;
  colourB_in?: Maybe<Int[] | Int>;
  colourB_not_in?: Maybe<Int[] | Int>;
  colourB_lt?: Maybe<Int>;
  colourB_lte?: Maybe<Int>;
  colourB_gt?: Maybe<Int>;
  colourB_gte?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourC_not?: Maybe<Int>;
  colourC_in?: Maybe<Int[] | Int>;
  colourC_not_in?: Maybe<Int[] | Int>;
  colourC_lt?: Maybe<Int>;
  colourC_lte?: Maybe<Int>;
  colourC_gt?: Maybe<Int>;
  colourC_gte?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourG_not?: Maybe<Int>;
  colourG_in?: Maybe<Int[] | Int>;
  colourG_not_in?: Maybe<Int[] | Int>;
  colourG_lt?: Maybe<Int>;
  colourG_lte?: Maybe<Int>;
  colourG_gt?: Maybe<Int>;
  colourG_gte?: Maybe<Int>;
  colourR?: Maybe<Int>;
  colourR_not?: Maybe<Int>;
  colourR_in?: Maybe<Int[] | Int>;
  colourR_not_in?: Maybe<Int[] | Int>;
  colourR_lt?: Maybe<Int>;
  colourR_lte?: Maybe<Int>;
  colourR_gt?: Maybe<Int>;
  colourR_gte?: Maybe<Int>;
  cupDataColourCalc_every?: Maybe<CupDataColourCalcWhereInput>;
  cupDataColourCalc_some?: Maybe<CupDataColourCalcWhereInput>;
  cupDataColourCalc_none?: Maybe<CupDataColourCalcWhereInput>;
  cupDataProcVolume_every?: Maybe<CupDataProcVolumeWhereInput>;
  cupDataProcVolume_some?: Maybe<CupDataProcVolumeWhereInput>;
  cupDataProcVolume_none?: Maybe<CupDataProcVolumeWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  day_not?: Maybe<Int>;
  day_in?: Maybe<Int[] | Int>;
  day_not_in?: Maybe<Int[] | Int>;
  day_lt?: Maybe<Int>;
  day_lte?: Maybe<Int>;
  day_gt?: Maybe<Int>;
  day_gte?: Maybe<Int>;
  hour?: Maybe<Int>;
  hour_not?: Maybe<Int>;
  hour_in?: Maybe<Int[] | Int>;
  hour_not_in?: Maybe<Int[] | Int>;
  hour_lt?: Maybe<Int>;
  hour_lte?: Maybe<Int>;
  hour_gt?: Maybe<Int>;
  hour_gte?: Maybe<Int>;
  line?: Maybe<Int>;
  line_not?: Maybe<Int>;
  line_in?: Maybe<Int[] | Int>;
  line_not_in?: Maybe<Int[] | Int>;
  line_lt?: Maybe<Int>;
  line_lte?: Maybe<Int>;
  line_gt?: Maybe<Int>;
  line_gte?: Maybe<Int>;
  minute?: Maybe<Int>;
  minute_not?: Maybe<Int>;
  minute_in?: Maybe<Int[] | Int>;
  minute_not_in?: Maybe<Int[] | Int>;
  minute_lt?: Maybe<Int>;
  minute_lte?: Maybe<Int>;
  minute_gt?: Maybe<Int>;
  minute_gte?: Maybe<Int>;
  month?: Maybe<Int>;
  month_not?: Maybe<Int>;
  month_in?: Maybe<Int[] | Int>;
  month_not_in?: Maybe<Int[] | Int>;
  month_lt?: Maybe<Int>;
  month_lte?: Maybe<Int>;
  month_gt?: Maybe<Int>;
  month_gte?: Maybe<Int>;
  page?: Maybe<Int>;
  page_not?: Maybe<Int>;
  page_in?: Maybe<Int[] | Int>;
  page_not_in?: Maybe<Int[] | Int>;
  page_lt?: Maybe<Int>;
  page_lte?: Maybe<Int>;
  page_gt?: Maybe<Int>;
  page_gte?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawTotalVolume_not?: Maybe<Int>;
  rawTotalVolume_in?: Maybe<Int[] | Int>;
  rawTotalVolume_not_in?: Maybe<Int[] | Int>;
  rawTotalVolume_lt?: Maybe<Int>;
  rawTotalVolume_lte?: Maybe<Int>;
  rawTotalVolume_gt?: Maybe<Int>;
  rawTotalVolume_gte?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeL_not?: Maybe<Int>;
  rawVolumeL_in?: Maybe<Int[] | Int>;
  rawVolumeL_not_in?: Maybe<Int[] | Int>;
  rawVolumeL_lt?: Maybe<Int>;
  rawVolumeL_lte?: Maybe<Int>;
  rawVolumeL_gt?: Maybe<Int>;
  rawVolumeL_gte?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  rawVolumeR_not?: Maybe<Int>;
  rawVolumeR_in?: Maybe<Int[] | Int>;
  rawVolumeR_not_in?: Maybe<Int[] | Int>;
  rawVolumeR_lt?: Maybe<Int>;
  rawVolumeR_lte?: Maybe<Int>;
  rawVolumeR_gt?: Maybe<Int>;
  rawVolumeR_gte?: Maybe<Int>;
  serialNumber?: Maybe<CupWhereInput>;
  temperature?: Maybe<Int>;
  temperature_not?: Maybe<Int>;
  temperature_in?: Maybe<Int[] | Int>;
  temperature_not_in?: Maybe<Int[] | Int>;
  temperature_lt?: Maybe<Int>;
  temperature_lte?: Maybe<Int>;
  temperature_gt?: Maybe<Int>;
  temperature_gte?: Maybe<Int>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  AND?: Maybe<CupDatumWhereInput[] | CupDatumWhereInput>;
  OR?: Maybe<CupDatumWhereInput[] | CupDatumWhereInput>;
  NOT?: Maybe<CupDatumWhereInput[] | CupDatumWhereInput>;
}

export interface CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowInput {
  where: CupDataManMdateWhereUniqueInput;
  update: CupDataManMdateUpdateWithoutMdateRowDataInput;
  create: CupDataManMdateCreateWithoutMdateRowInput;
}

export interface CupAppSyncWhereInput {
  cup_app_sync_id?: Maybe<Int>;
  cup_app_sync_id_not?: Maybe<Int>;
  cup_app_sync_id_in?: Maybe<Int[] | Int>;
  cup_app_sync_id_not_in?: Maybe<Int[] | Int>;
  cup_app_sync_id_lt?: Maybe<Int>;
  cup_app_sync_id_lte?: Maybe<Int>;
  cup_app_sync_id_gt?: Maybe<Int>;
  cup_app_sync_id_gte?: Maybe<Int>;
  appSynchTime?: Maybe<DateTimeInput>;
  appSynchTime_not?: Maybe<DateTimeInput>;
  appSynchTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  appSynchTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  appSynchTime_lt?: Maybe<DateTimeInput>;
  appSynchTime_lte?: Maybe<DateTimeInput>;
  appSynchTime_gt?: Maybe<DateTimeInput>;
  appSynchTime_gte?: Maybe<DateTimeInput>;
  serialNumber?: Maybe<CupWhereInput>;
  AND?: Maybe<CupAppSyncWhereInput[] | CupAppSyncWhereInput>;
  OR?: Maybe<CupAppSyncWhereInput[] | CupAppSyncWhereInput>;
  NOT?: Maybe<CupAppSyncWhereInput[] | CupAppSyncWhereInput>;
}

export interface CupDataManMdateScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  menFinish?: Maybe<DateTimeInput>;
  menFinish_not?: Maybe<DateTimeInput>;
  menFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_lt?: Maybe<DateTimeInput>;
  menFinish_lte?: Maybe<DateTimeInput>;
  menFinish_gt?: Maybe<DateTimeInput>;
  menFinish_gte?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  menStart_not?: Maybe<DateTimeInput>;
  menStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_lt?: Maybe<DateTimeInput>;
  menStart_lte?: Maybe<DateTimeInput>;
  menStart_gt?: Maybe<DateTimeInput>;
  menStart_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput
  >;
  OR?: Maybe<
    CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput
  >;
}

export interface CompanyWhereInput {
  company_id?: Maybe<Int>;
  company_id_not?: Maybe<Int>;
  company_id_in?: Maybe<Int[] | Int>;
  company_id_not_in?: Maybe<Int[] | Int>;
  company_id_lt?: Maybe<Int>;
  company_id_lte?: Maybe<Int>;
  company_id_gt?: Maybe<Int>;
  company_id_gte?: Maybe<Int>;
  companyName?: Maybe<String>;
  companyName_not?: Maybe<String>;
  companyName_in?: Maybe<String[] | String>;
  companyName_not_in?: Maybe<String[] | String>;
  companyName_lt?: Maybe<String>;
  companyName_lte?: Maybe<String>;
  companyName_gt?: Maybe<String>;
  companyName_gte?: Maybe<String>;
  companyName_contains?: Maybe<String>;
  companyName_not_contains?: Maybe<String>;
  companyName_starts_with?: Maybe<String>;
  companyName_not_starts_with?: Maybe<String>;
  companyName_ends_with?: Maybe<String>;
  companyName_not_ends_with?: Maybe<String>;
  cup_every?: Maybe<CupWhereInput>;
  cup_some?: Maybe<CupWhereInput>;
  cup_none?: Maybe<CupWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface CupDataManMdateUpdateManyWithWhereNestedInput {
  where: CupDataManMdateScalarWhereInput;
  data: CupDataManMdateUpdateManyDataInput;
}

export interface CalibrationWhereInput {
  calib_id?: Maybe<Int>;
  calib_id_not?: Maybe<Int>;
  calib_id_in?: Maybe<Int[] | Int>;
  calib_id_not_in?: Maybe<Int[] | Int>;
  calib_id_lt?: Maybe<Int>;
  calib_id_lte?: Maybe<Int>;
  calib_id_gt?: Maybe<Int>;
  calib_id_gte?: Maybe<Int>;
  calibVersion?: Maybe<String>;
  calibVersion_not?: Maybe<String>;
  calibVersion_in?: Maybe<String[] | String>;
  calibVersion_not_in?: Maybe<String[] | String>;
  calibVersion_lt?: Maybe<String>;
  calibVersion_lte?: Maybe<String>;
  calibVersion_gt?: Maybe<String>;
  calibVersion_gte?: Maybe<String>;
  calibVersion_contains?: Maybe<String>;
  calibVersion_not_contains?: Maybe<String>;
  calibVersion_starts_with?: Maybe<String>;
  calibVersion_not_starts_with?: Maybe<String>;
  calibVersion_ends_with?: Maybe<String>;
  calibVersion_not_ends_with?: Maybe<String>;
  cup_every?: Maybe<CupWhereInput>;
  cup_some?: Maybe<CupWhereInput>;
  cup_none?: Maybe<CupWhereInput>;
  AND?: Maybe<CalibrationWhereInput[] | CalibrationWhereInput>;
  OR?: Maybe<CalibrationWhereInput[] | CalibrationWhereInput>;
  NOT?: Maybe<CalibrationWhereInput[] | CalibrationWhereInput>;
}

export interface CupDataManMdateUpdateManyDataInput {
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface CupWhereInput {
  serial_number?: Maybe<Int>;
  serial_number_not?: Maybe<Int>;
  serial_number_in?: Maybe<Int[] | Int>;
  serial_number_not_in?: Maybe<Int[] | Int>;
  serial_number_lt?: Maybe<Int>;
  serial_number_lte?: Maybe<Int>;
  serial_number_gt?: Maybe<Int>;
  serial_number_gte?: Maybe<Int>;
  anonSerialNumber?: Maybe<Int>;
  anonSerialNumber_not?: Maybe<Int>;
  anonSerialNumber_in?: Maybe<Int[] | Int>;
  anonSerialNumber_not_in?: Maybe<Int[] | Int>;
  anonSerialNumber_lt?: Maybe<Int>;
  anonSerialNumber_lte?: Maybe<Int>;
  anonSerialNumber_gt?: Maybe<Int>;
  anonSerialNumber_gte?: Maybe<Int>;
  calib?: Maybe<CalibrationWhereInput>;
  company?: Maybe<CompanyWhereInput>;
  cupAppSync_every?: Maybe<CupAppSyncWhereInput>;
  cupAppSync_some?: Maybe<CupAppSyncWhereInput>;
  cupAppSync_none?: Maybe<CupAppSyncWhereInput>;
  cupData_every?: Maybe<CupDatumWhereInput>;
  cupData_some?: Maybe<CupDatumWhereInput>;
  cupData_none?: Maybe<CupDatumWhereInput>;
  cupDataColourCalib_every?: Maybe<CupDataColourCalibWhereInput>;
  cupDataColourCalib_some?: Maybe<CupDataColourCalibWhereInput>;
  cupDataColourCalib_none?: Maybe<CupDataColourCalibWhereInput>;
  cupDataRaw_every?: Maybe<CupDataRawWhereInput>;
  cupDataRaw_some?: Maybe<CupDataRawWhereInput>;
  cupDataRaw_none?: Maybe<CupDataRawWhereInput>;
  cupDataUserRemove_every?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_some?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_none?: Maybe<CupDataUserRemoveWhereInput>;
  encryptionKey?: Maybe<Int>;
  encryptionKey_not?: Maybe<Int>;
  encryptionKey_in?: Maybe<Int[] | Int>;
  encryptionKey_not_in?: Maybe<Int[] | Int>;
  encryptionKey_lt?: Maybe<Int>;
  encryptionKey_lte?: Maybe<Int>;
  encryptionKey_gt?: Maybe<Int>;
  encryptionKey_gte?: Maybe<Int>;
  fw?: Maybe<FirmwareWhereInput>;
  hw?: Maybe<HardwareWhereInput>;
  userCups_every?: Maybe<UserCupWhereInput>;
  userCups_some?: Maybe<UserCupWhereInput>;
  userCups_none?: Maybe<UserCupWhereInput>;
  AND?: Maybe<CupWhereInput[] | CupWhereInput>;
  OR?: Maybe<CupWhereInput[] | CupWhereInput>;
  NOT?: Maybe<CupWhereInput[] | CupWhereInput>;
}

export interface CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput {
  create?: Maybe<CupDataRejectionCreateWithoutCupDataProcMdatesInput>;
  update?: Maybe<CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput>;
  upsert?: Maybe<CupDataRejectionUpsertWithoutCupDataProcMdatesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CupDataRejectionWhereUniqueInput>;
}

export interface CupDataColourCalibSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataColourCalibWhereInput>;
  AND?: Maybe<
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput
  >;
}

export interface CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput {
  rejectionDescription?: Maybe<String>;
}

export interface CupDataUserRemoveExplainWhereInput {
  explain_id?: Maybe<Int>;
  explain_id_not?: Maybe<Int>;
  explain_id_in?: Maybe<Int[] | Int>;
  explain_id_not_in?: Maybe<Int[] | Int>;
  explain_id_lt?: Maybe<Int>;
  explain_id_lte?: Maybe<Int>;
  explain_id_gt?: Maybe<Int>;
  explain_id_gte?: Maybe<Int>;
  cupDataUserRemove_every?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_some?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_none?: Maybe<CupDataUserRemoveWhereInput>;
  explain?: Maybe<String>;
  explain_not?: Maybe<String>;
  explain_in?: Maybe<String[] | String>;
  explain_not_in?: Maybe<String[] | String>;
  explain_lt?: Maybe<String>;
  explain_lte?: Maybe<String>;
  explain_gt?: Maybe<String>;
  explain_gte?: Maybe<String>;
  explain_contains?: Maybe<String>;
  explain_not_contains?: Maybe<String>;
  explain_starts_with?: Maybe<String>;
  explain_not_starts_with?: Maybe<String>;
  explain_ends_with?: Maybe<String>;
  explain_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    CupDataUserRemoveExplainWhereInput[] | CupDataUserRemoveExplainWhereInput
  >;
  OR?: Maybe<
    CupDataUserRemoveExplainWhereInput[] | CupDataUserRemoveExplainWhereInput
  >;
  NOT?: Maybe<
    CupDataUserRemoveExplainWhereInput[] | CupDataUserRemoveExplainWhereInput
  >;
}

export interface CupDataRejectionUpsertWithoutCupDataProcMdatesInput {
  update: CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput;
  create: CupDataRejectionCreateWithoutCupDataProcMdatesInput;
}

export interface CupAppSyncSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupAppSyncWhereInput>;
  AND?: Maybe<
    CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput
  >;
  OR?: Maybe<
    CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput
  >;
}

export interface UserUpdateOneRequiredWithoutCupDataProcMdatesInput {
  create?: Maybe<UserCreateWithoutCupDataProcMdatesInput>;
  update?: Maybe<UserUpdateWithoutCupDataProcMdatesDataInput>;
  upsert?: Maybe<UserUpsertWithoutCupDataProcMdatesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupWhereInput>;
  AND?: Maybe<CupSubscriptionWhereInput[] | CupSubscriptionWhereInput>;
  OR?: Maybe<CupSubscriptionWhereInput[] | CupSubscriptionWhereInput>;
  NOT?: Maybe<CupSubscriptionWhereInput[] | CupSubscriptionWhereInput>;
}

export interface UserUpdateWithoutCupDataProcMdatesDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CountryWhereInput>;
  AND?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  OR?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
  NOT?: Maybe<CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput>;
}

export interface CupDataQaResponseUpdateManyWithoutUserInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutUserInput[]
    | CupDataQaResponseCreateWithoutUserInput
  >;
  delete?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  set?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataQaResponseUpdateWithWhereUniqueWithoutUserInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CupDataQaResponseUpsertWithWhereUniqueWithoutUserInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput
  >;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutUserInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutUserDataInput;
}

export interface CalibrationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CalibrationWhereInput>;
  AND?: Maybe<
    CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput
  >;
  OR?: Maybe<
    CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput
  >;
}

export interface CupDataQaResponseUpdateWithoutUserDataInput {
  answer?: Maybe<CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput>;
  qaDate?: Maybe<DateTimeInput>;
  question?: Maybe<
    CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput
  >;
}

export interface AuthTokenSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthTokenWhereInput>;
  AND?: Maybe<
    AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput
  >;
  OR?: Maybe<
    AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput
  >;
}

export interface CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: Maybe<CupDataAnswerCreateWithoutCupDataQaResponseInput>;
  update?: Maybe<CupDataAnswerUpdateWithoutCupDataQaResponseDataInput>;
  upsert?: Maybe<CupDataAnswerUpsertWithoutCupDataQaResponseInput>;
  connect?: Maybe<CupDataAnswerWhereUniqueInput>;
}

export interface AnswerTypeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AnswerTypeWhereInput>;
  AND?: Maybe<
    AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput
  >;
  OR?: Maybe<
    AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput
  >;
}

export interface CupDataAnswerUpdateWithoutCupDataQaResponseDataInput {
  answerText?: Maybe<String>;
  question?: Maybe<CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput>;
}

export type AppServerSyncWhereUniqueInput = AtLeastOne<{
  app_server_sync_id: Maybe<Int>;
}>;

export interface CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput {
  create?: Maybe<CupDataQuestionCreateWithoutCupDataAnswerInput>;
  update?: Maybe<CupDataQuestionUpdateWithoutCupDataAnswerDataInput>;
  upsert?: Maybe<CupDataQuestionUpsertWithoutCupDataAnswerInput>;
  connect?: Maybe<CupDataQuestionWhereUniqueInput>;
}

export interface UsersDataAnalysisCreateInput {
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface CupDataQuestionUpdateWithoutCupDataAnswerDataInput {
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutQuestionInput>;
  questionText?: Maybe<String>;
}

export type AuthTokenWhereUniqueInput = AtLeastOne<{
  user_id: Maybe<Int>;
}>;

export interface CupDataQaResponseUpdateManyWithoutQuestionInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutQuestionInput[]
    | CupDataQaResponseCreateWithoutQuestionInput
  >;
  delete?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  set?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionInput
  >;
  upsert?: Maybe<
    | CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionInput
  >;
  deleteMany?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput
  >;
}

export interface AuthTokenWhereInput {
  user_id?: Maybe<Int>;
  user_id_not?: Maybe<Int>;
  user_id_in?: Maybe<Int[] | Int>;
  user_id_not_in?: Maybe<Int[] | Int>;
  user_id_lt?: Maybe<Int>;
  user_id_lte?: Maybe<Int>;
  user_id_gt?: Maybe<Int>;
  user_id_gte?: Maybe<Int>;
  AND?: Maybe<AuthTokenWhereInput[] | AuthTokenWhereInput>;
  OR?: Maybe<AuthTokenWhereInput[] | AuthTokenWhereInput>;
  NOT?: Maybe<AuthTokenWhereInput[] | AuthTokenWhereInput>;
}

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutQuestionDataInput;
}

export interface UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput {
  crampsLevel?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
  recordPeriodRow?: Maybe<
    UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput
  >;
}

export interface CupDataQaResponseUpdateWithoutQuestionDataInput {
  answer?: Maybe<CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput>;
  qaDate?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataQaResponseInput>;
}

export interface UserRecordDataByTimeUpdateInput {
  changeTime?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  recordDayRow?: Maybe<
    UserRecordDataByDayUpdateOneWithoutUserRecordDataByTimeInput
  >;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: Maybe<UserCreateWithoutCupDataQaResponseInput>;
  update?: Maybe<UserUpdateWithoutCupDataQaResponseDataInput>;
  upsert?: Maybe<UserUpsertWithoutCupDataQaResponseInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataProcMdateWhereInput {
  mdate_row_id?: Maybe<Int>;
  mdate_row_id_not?: Maybe<Int>;
  mdate_row_id_in?: Maybe<Int[] | Int>;
  mdate_row_id_not_in?: Maybe<Int[] | Int>;
  mdate_row_id_lt?: Maybe<Int>;
  mdate_row_id_lte?: Maybe<Int>;
  mdate_row_id_gt?: Maybe<Int>;
  mdate_row_id_gte?: Maybe<Int>;
  cupDataManMdates_every?: Maybe<CupDataManMdateWhereInput>;
  cupDataManMdates_some?: Maybe<CupDataManMdateWhereInput>;
  cupDataManMdates_none?: Maybe<CupDataManMdateWhereInput>;
  cupDataProcFlow_every?: Maybe<CupDataProcFlowWhereInput>;
  cupDataProcFlow_some?: Maybe<CupDataProcFlowWhereInput>;
  cupDataProcFlow_none?: Maybe<CupDataProcFlowWhereInput>;
  dataRejected?: Maybe<Boolean>;
  dataRejected_not?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  dataVerified_not?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menFinish_not?: Maybe<DateTimeInput>;
  menFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_lt?: Maybe<DateTimeInput>;
  menFinish_lte?: Maybe<DateTimeInput>;
  menFinish_gt?: Maybe<DateTimeInput>;
  menFinish_gte?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  menStart_not?: Maybe<DateTimeInput>;
  menStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_lt?: Maybe<DateTimeInput>;
  menStart_lte?: Maybe<DateTimeInput>;
  menStart_gt?: Maybe<DateTimeInput>;
  menStart_gte?: Maybe<DateTimeInput>;
  reject?: Maybe<CupDataRejectionWhereInput>;
  rewardAmount?: Maybe<Int>;
  rewardAmount_not?: Maybe<Int>;
  rewardAmount_in?: Maybe<Int[] | Int>;
  rewardAmount_not_in?: Maybe<Int[] | Int>;
  rewardAmount_lt?: Maybe<Int>;
  rewardAmount_lte?: Maybe<Int>;
  rewardAmount_gt?: Maybe<Int>;
  rewardAmount_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput>;
  OR?: Maybe<CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput>;
  NOT?: Maybe<CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput>;
}

export interface UserUpdateWithoutCupDataQaResponseDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface UserRecordDataByDayCreateOneWithoutUserRecordDataByTimeInput {
  create?: Maybe<UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput>;
  connect?: Maybe<UserRecordDataByDayWhereUniqueInput>;
}

export interface CupDataProcMdateUpdateManyWithoutUserInput {
  create?: Maybe<
    | CupDataProcMdateCreateWithoutUserInput[]
    | CupDataProcMdateCreateWithoutUserInput
  >;
  delete?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  set?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataProcMdateUpdateWithWhereUniqueWithoutUserInput[]
    | CupDataProcMdateUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CupDataProcMdateUpsertWithWhereUniqueWithoutUserInput[]
    | CupDataProcMdateUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataProcMdateUpdateManyWithWhereNestedInput[]
    | CupDataProcMdateUpdateManyWithWhereNestedInput
  >;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  company_id: Maybe<Int>;
  companyName?: Maybe<String>;
}>;

export interface CupDataProcMdateUpdateWithWhereUniqueWithoutUserInput {
  where: CupDataProcMdateWhereUniqueInput;
  data: CupDataProcMdateUpdateWithoutUserDataInput;
}

export interface UserRecordDataByPeriodUpdateManyMutationInput {
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
}

export interface CupDataProcMdateUpdateWithoutUserDataInput {
  cupDataManMdates?: Maybe<CupDataManMdateUpdateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  reject?: Maybe<CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
}

export interface UserRecordDataByPeriodCreateInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryCreateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish: DateTimeInput;
  mensStart: DateTimeInput;
  user?: Maybe<UserCreateOneWithoutUserRecordDataByPeriodInput>;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayCreateManyWithoutRecordPeriodRowInput
  >;
}

export interface CupDataProcFlowUpdateManyWithoutMdateRowInput {
  create?: Maybe<
    | CupDataProcFlowCreateWithoutMdateRowInput[]
    | CupDataProcFlowCreateWithoutMdateRowInput
  >;
  delete?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  set?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowInput[]
    | CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowInput
  >;
  upsert?: Maybe<
    | CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowInput[]
    | CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowInput
  >;
  deleteMany?: Maybe<
    CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataProcFlowUpdateManyWithWhereNestedInput[]
    | CupDataProcFlowUpdateManyWithWhereNestedInput
  >;
}

export interface CountryWhereInput {
  country_id?: Maybe<Int>;
  country_id_not?: Maybe<Int>;
  country_id_in?: Maybe<Int[] | Int>;
  country_id_not_in?: Maybe<Int[] | Int>;
  country_id_lt?: Maybe<Int>;
  country_id_lte?: Maybe<Int>;
  country_id_gt?: Maybe<Int>;
  country_id_gte?: Maybe<Int>;
  countryName?: Maybe<String>;
  countryName_not?: Maybe<String>;
  countryName_in?: Maybe<String[] | String>;
  countryName_not_in?: Maybe<String[] | String>;
  countryName_lt?: Maybe<String>;
  countryName_lte?: Maybe<String>;
  countryName_gt?: Maybe<String>;
  countryName_gte?: Maybe<String>;
  countryName_contains?: Maybe<String>;
  countryName_not_contains?: Maybe<String>;
  countryName_starts_with?: Maybe<String>;
  countryName_not_starts_with?: Maybe<String>;
  countryName_ends_with?: Maybe<String>;
  countryName_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  OR?: Maybe<CountryWhereInput[] | CountryWhereInput>;
  NOT?: Maybe<CountryWhereInput[] | CountryWhereInput>;
}

export interface CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowInput {
  where: CupDataProcFlowWhereUniqueInput;
  data: CupDataProcFlowUpdateWithoutMdateRowDataInput;
}

export interface UserRecordDataByPeriodUpsertWithoutUserRecordDataByDayInput {
  update: UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput;
  create: UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput;
}

export interface CupDataProcFlowUpdateWithoutMdateRowDataInput {
  date?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcFlowInput>;
}

export type CupWhereUniqueInput = AtLeastOne<{
  serial_number: Maybe<Int>;
}>;

export interface UserUpdateOneRequiredWithoutCupDataProcFlowInput {
  create?: Maybe<UserCreateWithoutCupDataProcFlowInput>;
  update?: Maybe<UserUpdateWithoutCupDataProcFlowDataInput>;
  upsert?: Maybe<UserUpsertWithoutCupDataProcFlowInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserRecordDataByDayUpdateInput {
  crampsLevel?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
  recordPeriodRow?: Maybe<
    UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput
  >;
  userRecordDataByTime?: Maybe<
    UserRecordDataByTimeUpdateManyWithoutRecordDayRowInput
  >;
}

export interface UserUpdateWithoutCupDataProcFlowDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export type CupAppSyncWhereUniqueInput = AtLeastOne<{
  cup_app_sync_id: Maybe<Int>;
}>;

export interface CupDataUserRemoveUpdateManyWithoutUserInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutUserInput[]
    | CupDataUserRemoveCreateWithoutUserInput
  >;
  delete?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  set?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutUserInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutUserInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput
  >;
}

export interface UserRecordDataByDayCreateInput {
  crampsLevel?: Maybe<Int>;
  recordDate: DateTimeInput;
  recordPeriodRow?: Maybe<
    UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput
  >;
  userRecordDataByTime?: Maybe<
    UserRecordDataByTimeCreateManyWithoutRecordDayRowInput
  >;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutUserInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutUserDataInput;
}

export type CupDataAnswerWhereUniqueInput = AtLeastOne<{
  answer_id: Maybe<Int>;
}>;

export interface CupDataUserRemoveUpdateWithoutUserDataInput {
  changeTime?: Maybe<DateTimeInput>;
  explain?: Maybe<
    CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput
  >;
  serialNumber?: Maybe<CupUpdateOneRequiredWithoutCupDataUserRemoveInput>;
}

export interface UserInterviewQuestionCreateInput {
  answerType: AnswerTypeCreateOneWithoutUserInterviewQuestionsInput;
  question: String;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutQuestionInput>;
}

export interface CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: Maybe<CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput>;
  update?: Maybe<
    CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput
  >;
  upsert?: Maybe<CupDataUserRemoveExplainUpsertWithoutCupDataUserRemoveInput>;
  connect?: Maybe<CupDataUserRemoveExplainWhereUniqueInput>;
}

export type CupDataColourCalcWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput {
  explain?: Maybe<String>;
}

export interface UserInterviewDatumCreateInput {
  row_id?: Maybe<Int>;
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date: DateTimeInput;
  question: UserInterviewQuestionCreateOneWithoutUserInterviewDataInput;
  user: UserCreateOneWithoutUserInterviewDataInput;
}

export interface CupDataUserRemoveExplainUpsertWithoutCupDataUserRemoveInput {
  update: CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput;
  create: CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput;
}

export type CupDataColourCalibWhereUniqueInput = AtLeastOne<{
  cup_data_colour_calib_id: Maybe<Int>;
}>;

export interface CupUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: Maybe<CupCreateWithoutCupDataUserRemoveInput>;
  update?: Maybe<CupUpdateWithoutCupDataUserRemoveDataInput>;
  upsert?: Maybe<CupUpsertWithoutCupDataUserRemoveInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface UserCoinHistoryCreateInput {
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeInput;
  txhash: String;
  user?: Maybe<UserCreateOneWithoutUserCoinHistoryInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutCoinHistoryRowInput
  >;
}

export interface CupUpdateWithoutCupDataUserRemoveDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export type CupDataManMdateWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CalibrationUpdateOneWithoutCupInput {
  create?: Maybe<CalibrationCreateWithoutCupInput>;
  update?: Maybe<CalibrationUpdateWithoutCupDataInput>;
  upsert?: Maybe<CalibrationUpsertWithoutCupInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CalibrationWhereUniqueInput>;
}

export interface UserCreateInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface CalibrationUpdateWithoutCupDataInput {
  calibVersion?: Maybe<String>;
}

export type CupDataProcFlowWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CalibrationUpsertWithoutCupInput {
  update: CalibrationUpdateWithoutCupDataInput;
  create: CalibrationCreateWithoutCupInput;
}

export interface PlatformCompCreateInput {
  row_id?: Maybe<Int>;
  phoneId: Int;
  platformId: Int;
  problemHistory?: Maybe<Boolean>;
  softwareId: Int;
  successHistory?: Maybe<Boolean>;
}

export interface CompanyUpdateOneWithoutCupInput {
  create?: Maybe<CompanyCreateWithoutCupInput>;
  update?: Maybe<CompanyUpdateWithoutCupDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutCupInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export type CupDataProcMdateWhereUniqueInput = AtLeastOne<{
  mdate_row_id: Maybe<Int>;
}>;

export interface CompanyUpdateWithoutCupDataInput {
  companyName?: Maybe<String>;
}

export interface CupUpdateWithoutHwDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface CompanyUpsertWithoutCupInput {
  update: CompanyUpdateWithoutCupDataInput;
  create: CompanyCreateWithoutCupInput;
}

export type CupDataProcVolumeWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupAppSyncUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupAppSyncCreateWithoutSerialNumberInput[]
    | CupAppSyncCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput>;
  connect?: Maybe<CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput>;
  set?: Maybe<CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput>;
  disconnect?: Maybe<CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput>;
  update?: Maybe<
    | CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput>;
  updateMany?: Maybe<
    | CupAppSyncUpdateManyWithWhereNestedInput[]
    | CupAppSyncUpdateManyWithWhereNestedInput
  >;
}

export interface HardwareUpdateInput {
  cup?: Maybe<CupUpdateManyWithoutHwInput>;
  hwVersion?: Maybe<String>;
}

export interface CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupAppSyncWhereUniqueInput;
  data: CupAppSyncUpdateWithoutSerialNumberDataInput;
}

export type CupDataQaResponseWhereUniqueInput = AtLeastOne<{
  cup_data_qa_response_id: Maybe<Int>;
}>;

export interface CupAppSyncUpdateWithoutSerialNumberDataInput {
  appSynchTime?: Maybe<DateTimeInput>;
}

export interface HardwareCreateInput {
  cup?: Maybe<CupCreateManyWithoutHwInput>;
  hwVersion: String;
}

export interface CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupAppSyncWhereUniqueInput;
  update: CupAppSyncUpdateWithoutSerialNumberDataInput;
  create: CupAppSyncCreateWithoutSerialNumberInput;
}

export type CupDataQuestionWhereUniqueInput = AtLeastOne<{
  question_id: Maybe<Int>;
}>;

export interface CupAppSyncScalarWhereInput {
  cup_app_sync_id?: Maybe<Int>;
  cup_app_sync_id_not?: Maybe<Int>;
  cup_app_sync_id_in?: Maybe<Int[] | Int>;
  cup_app_sync_id_not_in?: Maybe<Int[] | Int>;
  cup_app_sync_id_lt?: Maybe<Int>;
  cup_app_sync_id_lte?: Maybe<Int>;
  cup_app_sync_id_gt?: Maybe<Int>;
  cup_app_sync_id_gte?: Maybe<Int>;
  appSynchTime?: Maybe<DateTimeInput>;
  appSynchTime_not?: Maybe<DateTimeInput>;
  appSynchTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  appSynchTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  appSynchTime_lt?: Maybe<DateTimeInput>;
  appSynchTime_lte?: Maybe<DateTimeInput>;
  appSynchTime_gt?: Maybe<DateTimeInput>;
  appSynchTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput>;
  OR?: Maybe<CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput>;
  NOT?: Maybe<CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput>;
}

export interface CupUpsertWithWhereUniqueWithoutFwInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutFwDataInput;
  create: CupCreateWithoutFwInput;
}

export interface CupAppSyncUpdateManyWithWhereNestedInput {
  where: CupAppSyncScalarWhereInput;
  data: CupAppSyncUpdateManyDataInput;
}

export interface CupUpdateWithWhereUniqueWithoutFwInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutFwDataInput;
}

export interface CupAppSyncUpdateManyDataInput {
  appSynchTime?: Maybe<DateTimeInput>;
}

export interface CupUpdateManyWithoutFwInput {
  create?: Maybe<CupCreateWithoutFwInput[] | CupCreateWithoutFwInput>;
  delete?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  set?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  disconnect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  update?: Maybe<
    | CupUpdateWithWhereUniqueWithoutFwInput[]
    | CupUpdateWithWhereUniqueWithoutFwInput
  >;
  upsert?: Maybe<
    | CupUpsertWithWhereUniqueWithoutFwInput[]
    | CupUpsertWithWhereUniqueWithoutFwInput
  >;
  deleteMany?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  updateMany?: Maybe<
    CupUpdateManyWithWhereNestedInput[] | CupUpdateManyWithWhereNestedInput
  >;
}

export interface CupDatumUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDatumCreateWithoutSerialNumberInput[]
    | CupDatumCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput>;
  connect?: Maybe<CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput>;
  set?: Maybe<CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput>;
  disconnect?: Maybe<CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput>;
  update?: Maybe<
    | CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<CupDatumScalarWhereInput[] | CupDatumScalarWhereInput>;
  updateMany?: Maybe<
    | CupDatumUpdateManyWithWhereNestedInput[]
    | CupDatumUpdateManyWithWhereNestedInput
  >;
}

export interface CupCreateWithoutFwInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDatumWhereUniqueInput;
  data: CupDatumUpdateWithoutSerialNumberDataInput;
}

export interface UserWhereInput {
  user_id?: Maybe<Int>;
  user_id_not?: Maybe<Int>;
  user_id_in?: Maybe<Int[] | Int>;
  user_id_not_in?: Maybe<Int[] | Int>;
  user_id_lt?: Maybe<Int>;
  user_id_lte?: Maybe<Int>;
  user_id_gt?: Maybe<Int>;
  user_id_gte?: Maybe<Int>;
  anonUserId?: Maybe<Int>;
  anonUserId_not?: Maybe<Int>;
  anonUserId_in?: Maybe<Int[] | Int>;
  anonUserId_not_in?: Maybe<Int[] | Int>;
  anonUserId_lt?: Maybe<Int>;
  anonUserId_lte?: Maybe<Int>;
  anonUserId_gt?: Maybe<Int>;
  anonUserId_gte?: Maybe<Int>;
  appServerSync_every?: Maybe<AppServerSyncWhereInput>;
  appServerSync_some?: Maybe<AppServerSyncWhereInput>;
  appServerSync_none?: Maybe<AppServerSyncWhereInput>;
  country?: Maybe<CountryWhereInput>;
  cupDataProcFlow_every?: Maybe<CupDataProcFlowWhereInput>;
  cupDataProcFlow_some?: Maybe<CupDataProcFlowWhereInput>;
  cupDataProcFlow_none?: Maybe<CupDataProcFlowWhereInput>;
  cupDataProcMdates_every?: Maybe<CupDataProcMdateWhereInput>;
  cupDataProcMdates_some?: Maybe<CupDataProcMdateWhereInput>;
  cupDataProcMdates_none?: Maybe<CupDataProcMdateWhereInput>;
  cupDataQaResponse_every?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_some?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_none?: Maybe<CupDataQaResponseWhereInput>;
  cupDataUserRemove_every?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_some?: Maybe<CupDataUserRemoveWhereInput>;
  cupDataUserRemove_none?: Maybe<CupDataUserRemoveWhereInput>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  encryptSaltString_not?: Maybe<String>;
  encryptSaltString_in?: Maybe<String[] | String>;
  encryptSaltString_not_in?: Maybe<String[] | String>;
  encryptSaltString_lt?: Maybe<String>;
  encryptSaltString_lte?: Maybe<String>;
  encryptSaltString_gt?: Maybe<String>;
  encryptSaltString_gte?: Maybe<String>;
  encryptSaltString_contains?: Maybe<String>;
  encryptSaltString_not_contains?: Maybe<String>;
  encryptSaltString_starts_with?: Maybe<String>;
  encryptSaltString_not_starts_with?: Maybe<String>;
  encryptSaltString_ends_with?: Maybe<String>;
  encryptSaltString_not_ends_with?: Maybe<String>;
  ethnicity?: Maybe<EthnicityWhereInput>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  givenBirth_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  userCoinHistory_every?: Maybe<UserCoinHistoryWhereInput>;
  userCoinHistory_some?: Maybe<UserCoinHistoryWhereInput>;
  userCoinHistory_none?: Maybe<UserCoinHistoryWhereInput>;
  userCups_every?: Maybe<UserCupWhereInput>;
  userCups_some?: Maybe<UserCupWhereInput>;
  userCups_none?: Maybe<UserCupWhereInput>;
  userInterviewData_every?: Maybe<UserInterviewDatumWhereInput>;
  userInterviewData_some?: Maybe<UserInterviewDatumWhereInput>;
  userInterviewData_none?: Maybe<UserInterviewDatumWhereInput>;
  userRecordDataByPeriod_every?: Maybe<UserRecordDataByPeriodWhereInput>;
  userRecordDataByPeriod_some?: Maybe<UserRecordDataByPeriodWhereInput>;
  userRecordDataByPeriod_none?: Maybe<UserRecordDataByPeriodWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CupDatumUpdateWithoutSerialNumberDataInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  cupDataColourCalc?: Maybe<CupDataColourCalcUpdateManyWithoutCupDataRowInput>;
  cupDataProcVolume?: Maybe<CupDataProcVolumeUpdateManyWithoutCupDataRowInput>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export interface FirmwareCreateInput {
  cup?: Maybe<CupCreateManyWithoutFwInput>;
  fwVersion: String;
}

export interface CupDataColourCalcUpdateManyWithoutCupDataRowInput {
  create?: Maybe<
    | CupDataColourCalcCreateWithoutCupDataRowInput[]
    | CupDataColourCalcCreateWithoutCupDataRowInput
  >;
  delete?: Maybe<
    CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput
  >;
  set?: Maybe<
    CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowInput[]
    | CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowInput
  >;
  upsert?: Maybe<
    | CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowInput[]
    | CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowInput
  >;
  deleteMany?: Maybe<
    CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataColourCalcUpdateManyWithWhereNestedInput[]
    | CupDataColourCalcUpdateManyWithWhereNestedInput
  >;
}

export type CupDataUserRemoveWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowInput {
  where: CupDataColourCalcWhereUniqueInput;
  data: CupDataColourCalcUpdateWithoutCupDataRowDataInput;
}

export interface UserUpdateWithoutEthnicityDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface CupDataColourCalcUpdateWithoutCupDataRowDataInput {
  blue?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export type CupDataUserRemoveExplainWhereUniqueInput = AtLeastOne<{
  explain_id: Maybe<Int>;
}>;

export interface CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowInput {
  where: CupDataColourCalcWhereUniqueInput;
  update: CupDataColourCalcUpdateWithoutCupDataRowDataInput;
  create: CupDataColourCalcCreateWithoutCupDataRowInput;
}

export interface EthnicityUpdateInput {
  ethnicity?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutEthnicityInput>;
}

export interface CupDataColourCalcScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  blue?: Maybe<Int>;
  blue_not?: Maybe<Int>;
  blue_in?: Maybe<Int[] | Int>;
  blue_not_in?: Maybe<Int[] | Int>;
  blue_lt?: Maybe<Int>;
  blue_lte?: Maybe<Int>;
  blue_gt?: Maybe<Int>;
  blue_gte?: Maybe<Int>;
  green?: Maybe<Int>;
  green_not?: Maybe<Int>;
  green_in?: Maybe<Int[] | Int>;
  green_not_in?: Maybe<Int[] | Int>;
  green_lt?: Maybe<Int>;
  green_lte?: Maybe<Int>;
  green_gt?: Maybe<Int>;
  green_gte?: Maybe<Int>;
  red?: Maybe<Int>;
  red_not?: Maybe<Int>;
  red_in?: Maybe<Int[] | Int>;
  red_not_in?: Maybe<Int[] | Int>;
  red_lt?: Maybe<Int>;
  red_lte?: Maybe<Int>;
  red_gt?: Maybe<Int>;
  red_gte?: Maybe<Int>;
  AND?: Maybe<
    CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput
  >;
  OR?: Maybe<
    CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput
  >;
}

export interface UserCreateManyWithoutEthnicityInput {
  create?: Maybe<
    UserCreateWithoutEthnicityInput[] | UserCreateWithoutEthnicityInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface CupDataColourCalcUpdateManyWithWhereNestedInput {
  where: CupDataColourCalcScalarWhereInput;
  data: CupDataColourCalcUpdateManyDataInput;
}

export interface EthnicityCreateInput {
  ethnicity: String;
  users?: Maybe<UserCreateManyWithoutEthnicityInput>;
}

export interface CupDataColourCalcUpdateManyDataInput {
  blue?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface CupDatumUpdateInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  cupDataColourCalc?: Maybe<CupDataColourCalcUpdateManyWithoutCupDataRowInput>;
  cupDataProcVolume?: Maybe<CupDataProcVolumeUpdateManyWithoutCupDataRowInput>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupUpdateOneWithoutCupDataInput>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export interface CupDataProcVolumeUpdateManyWithoutCupDataRowInput {
  create?: Maybe<
    | CupDataProcVolumeCreateWithoutCupDataRowInput[]
    | CupDataProcVolumeCreateWithoutCupDataRowInput
  >;
  delete?: Maybe<
    CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput
  >;
  set?: Maybe<
    CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowInput[]
    | CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowInput
  >;
  upsert?: Maybe<
    | CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowInput[]
    | CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowInput
  >;
  deleteMany?: Maybe<
    CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataProcVolumeUpdateManyWithWhereNestedInput[]
    | CupDataProcVolumeUpdateManyWithWhereNestedInput
  >;
}

export interface CupDatumCreateInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: Maybe<CupDataColourCalcCreateManyWithoutCupDataRowInput>;
  cupDataProcVolume?: Maybe<CupDataProcVolumeCreateManyWithoutCupDataRowInput>;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupCreateOneWithoutCupDataInput>;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowInput {
  where: CupDataProcVolumeWhereUniqueInput;
  data: CupDataProcVolumeUpdateWithoutCupDataRowDataInput;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutExplainDataInput;
  create: CupDataUserRemoveCreateWithoutExplainInput;
}

export interface CupDataProcVolumeUpdateWithoutCupDataRowDataInput {
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export type FirmwareWhereUniqueInput = AtLeastOne<{
  fw_id: Maybe<Int>;
  fwVersion?: Maybe<String>;
}>;

export interface CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowInput {
  where: CupDataProcVolumeWhereUniqueInput;
  update: CupDataProcVolumeUpdateWithoutCupDataRowDataInput;
  create: CupDataProcVolumeCreateWithoutCupDataRowInput;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutExplainDataInput;
}

export interface CupDataProcVolumeScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  confidenceL?: Maybe<Int>;
  confidenceL_not?: Maybe<Int>;
  confidenceL_in?: Maybe<Int[] | Int>;
  confidenceL_not_in?: Maybe<Int[] | Int>;
  confidenceL_lt?: Maybe<Int>;
  confidenceL_lte?: Maybe<Int>;
  confidenceL_gt?: Maybe<Int>;
  confidenceL_gte?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  confidenceR_not?: Maybe<Int>;
  confidenceR_in?: Maybe<Int[] | Int>;
  confidenceR_not_in?: Maybe<Int[] | Int>;
  confidenceR_lt?: Maybe<Int>;
  confidenceR_lte?: Maybe<Int>;
  confidenceR_gt?: Maybe<Int>;
  confidenceR_gte?: Maybe<Int>;
  inVitro?: Maybe<Boolean>;
  inVitro_not?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeAdj_not?: Maybe<Int>;
  volumeAdj_in?: Maybe<Int[] | Int>;
  volumeAdj_not_in?: Maybe<Int[] | Int>;
  volumeAdj_lt?: Maybe<Int>;
  volumeAdj_lte?: Maybe<Int>;
  volumeAdj_gt?: Maybe<Int>;
  volumeAdj_gte?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeL_not?: Maybe<Int>;
  volumeL_in?: Maybe<Int[] | Int>;
  volumeL_not_in?: Maybe<Int[] | Int>;
  volumeL_lt?: Maybe<Int>;
  volumeL_lte?: Maybe<Int>;
  volumeL_gt?: Maybe<Int>;
  volumeL_gte?: Maybe<Int>;
  volumeR?: Maybe<Int>;
  volumeR_not?: Maybe<Int>;
  volumeR_in?: Maybe<Int[] | Int>;
  volumeR_not_in?: Maybe<Int[] | Int>;
  volumeR_lt?: Maybe<Int>;
  volumeR_lte?: Maybe<Int>;
  volumeR_gt?: Maybe<Int>;
  volumeR_gte?: Maybe<Int>;
  AND?: Maybe<
    CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput
  >;
  OR?: Maybe<
    CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput
  >;
}

export interface CupDataUserRemoveExplainUpdateInput {
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutExplainInput>;
  explain?: Maybe<String>;
}

export interface CupDataProcVolumeUpdateManyWithWhereNestedInput {
  where: CupDataProcVolumeScalarWhereInput;
  data: CupDataProcVolumeUpdateManyDataInput;
}

export interface AnswerTypeWhereInput {
  answer_type_id?: Maybe<Int>;
  answer_type_id_not?: Maybe<Int>;
  answer_type_id_in?: Maybe<Int[] | Int>;
  answer_type_id_not_in?: Maybe<Int[] | Int>;
  answer_type_id_lt?: Maybe<Int>;
  answer_type_id_lte?: Maybe<Int>;
  answer_type_id_gt?: Maybe<Int>;
  answer_type_id_gte?: Maybe<Int>;
  answerType?: Maybe<String>;
  answerType_not?: Maybe<String>;
  answerType_in?: Maybe<String[] | String>;
  answerType_not_in?: Maybe<String[] | String>;
  answerType_lt?: Maybe<String>;
  answerType_lte?: Maybe<String>;
  answerType_gt?: Maybe<String>;
  answerType_gte?: Maybe<String>;
  answerType_contains?: Maybe<String>;
  answerType_not_contains?: Maybe<String>;
  answerType_starts_with?: Maybe<String>;
  answerType_not_starts_with?: Maybe<String>;
  answerType_ends_with?: Maybe<String>;
  answerType_not_ends_with?: Maybe<String>;
  userInterviewQuestions_every?: Maybe<UserInterviewQuestionWhereInput>;
  userInterviewQuestions_some?: Maybe<UserInterviewQuestionWhereInput>;
  userInterviewQuestions_none?: Maybe<UserInterviewQuestionWhereInput>;
  AND?: Maybe<AnswerTypeWhereInput[] | AnswerTypeWhereInput>;
  OR?: Maybe<AnswerTypeWhereInput[] | AnswerTypeWhereInput>;
  NOT?: Maybe<AnswerTypeWhereInput[] | AnswerTypeWhereInput>;
}

export interface CupDataProcVolumeUpdateManyDataInput {
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export interface CupDataUserRemoveCreateManyWithoutExplainInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutExplainInput[]
    | CupDataUserRemoveCreateWithoutExplainInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
}

export interface CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDatumWhereUniqueInput;
  update: CupDatumUpdateWithoutSerialNumberDataInput;
  create: CupDatumCreateWithoutSerialNumberInput;
}

export type PlatformCompWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDatumScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  battery?: Maybe<Int>;
  battery_not?: Maybe<Int>;
  battery_in?: Maybe<Int[] | Int>;
  battery_not_in?: Maybe<Int[] | Int>;
  battery_lt?: Maybe<Int>;
  battery_lte?: Maybe<Int>;
  battery_gt?: Maybe<Int>;
  battery_gte?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  calibFlag_not?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch1_not?: Maybe<Int>;
  ch1_in?: Maybe<Int[] | Int>;
  ch1_not_in?: Maybe<Int[] | Int>;
  ch1_lt?: Maybe<Int>;
  ch1_lte?: Maybe<Int>;
  ch1_gt?: Maybe<Int>;
  ch1_gte?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch10_not?: Maybe<Int>;
  ch10_in?: Maybe<Int[] | Int>;
  ch10_not_in?: Maybe<Int[] | Int>;
  ch10_lt?: Maybe<Int>;
  ch10_lte?: Maybe<Int>;
  ch10_gt?: Maybe<Int>;
  ch10_gte?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch11_not?: Maybe<Int>;
  ch11_in?: Maybe<Int[] | Int>;
  ch11_not_in?: Maybe<Int[] | Int>;
  ch11_lt?: Maybe<Int>;
  ch11_lte?: Maybe<Int>;
  ch11_gt?: Maybe<Int>;
  ch11_gte?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch12_not?: Maybe<Int>;
  ch12_in?: Maybe<Int[] | Int>;
  ch12_not_in?: Maybe<Int[] | Int>;
  ch12_lt?: Maybe<Int>;
  ch12_lte?: Maybe<Int>;
  ch12_gt?: Maybe<Int>;
  ch12_gte?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch13_not?: Maybe<Int>;
  ch13_in?: Maybe<Int[] | Int>;
  ch13_not_in?: Maybe<Int[] | Int>;
  ch13_lt?: Maybe<Int>;
  ch13_lte?: Maybe<Int>;
  ch13_gt?: Maybe<Int>;
  ch13_gte?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch14_not?: Maybe<Int>;
  ch14_in?: Maybe<Int[] | Int>;
  ch14_not_in?: Maybe<Int[] | Int>;
  ch14_lt?: Maybe<Int>;
  ch14_lte?: Maybe<Int>;
  ch14_gt?: Maybe<Int>;
  ch14_gte?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch2_not?: Maybe<Int>;
  ch2_in?: Maybe<Int[] | Int>;
  ch2_not_in?: Maybe<Int[] | Int>;
  ch2_lt?: Maybe<Int>;
  ch2_lte?: Maybe<Int>;
  ch2_gt?: Maybe<Int>;
  ch2_gte?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch3_not?: Maybe<Int>;
  ch3_in?: Maybe<Int[] | Int>;
  ch3_not_in?: Maybe<Int[] | Int>;
  ch3_lt?: Maybe<Int>;
  ch3_lte?: Maybe<Int>;
  ch3_gt?: Maybe<Int>;
  ch3_gte?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch4_not?: Maybe<Int>;
  ch4_in?: Maybe<Int[] | Int>;
  ch4_not_in?: Maybe<Int[] | Int>;
  ch4_lt?: Maybe<Int>;
  ch4_lte?: Maybe<Int>;
  ch4_gt?: Maybe<Int>;
  ch4_gte?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch5_not?: Maybe<Int>;
  ch5_in?: Maybe<Int[] | Int>;
  ch5_not_in?: Maybe<Int[] | Int>;
  ch5_lt?: Maybe<Int>;
  ch5_lte?: Maybe<Int>;
  ch5_gt?: Maybe<Int>;
  ch5_gte?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch6_not?: Maybe<Int>;
  ch6_in?: Maybe<Int[] | Int>;
  ch6_not_in?: Maybe<Int[] | Int>;
  ch6_lt?: Maybe<Int>;
  ch6_lte?: Maybe<Int>;
  ch6_gt?: Maybe<Int>;
  ch6_gte?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch7_not?: Maybe<Int>;
  ch7_in?: Maybe<Int[] | Int>;
  ch7_not_in?: Maybe<Int[] | Int>;
  ch7_lt?: Maybe<Int>;
  ch7_lte?: Maybe<Int>;
  ch7_gt?: Maybe<Int>;
  ch7_gte?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch8_not?: Maybe<Int>;
  ch8_in?: Maybe<Int[] | Int>;
  ch8_not_in?: Maybe<Int[] | Int>;
  ch8_lt?: Maybe<Int>;
  ch8_lte?: Maybe<Int>;
  ch8_gt?: Maybe<Int>;
  ch8_gte?: Maybe<Int>;
  ch9?: Maybe<Int>;
  ch9_not?: Maybe<Int>;
  ch9_in?: Maybe<Int[] | Int>;
  ch9_not_in?: Maybe<Int[] | Int>;
  ch9_lt?: Maybe<Int>;
  ch9_lte?: Maybe<Int>;
  ch9_gt?: Maybe<Int>;
  ch9_gte?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourB_not?: Maybe<Int>;
  colourB_in?: Maybe<Int[] | Int>;
  colourB_not_in?: Maybe<Int[] | Int>;
  colourB_lt?: Maybe<Int>;
  colourB_lte?: Maybe<Int>;
  colourB_gt?: Maybe<Int>;
  colourB_gte?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourC_not?: Maybe<Int>;
  colourC_in?: Maybe<Int[] | Int>;
  colourC_not_in?: Maybe<Int[] | Int>;
  colourC_lt?: Maybe<Int>;
  colourC_lte?: Maybe<Int>;
  colourC_gt?: Maybe<Int>;
  colourC_gte?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourG_not?: Maybe<Int>;
  colourG_in?: Maybe<Int[] | Int>;
  colourG_not_in?: Maybe<Int[] | Int>;
  colourG_lt?: Maybe<Int>;
  colourG_lte?: Maybe<Int>;
  colourG_gt?: Maybe<Int>;
  colourG_gte?: Maybe<Int>;
  colourR?: Maybe<Int>;
  colourR_not?: Maybe<Int>;
  colourR_in?: Maybe<Int[] | Int>;
  colourR_not_in?: Maybe<Int[] | Int>;
  colourR_lt?: Maybe<Int>;
  colourR_lte?: Maybe<Int>;
  colourR_gt?: Maybe<Int>;
  colourR_gte?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  day_not?: Maybe<Int>;
  day_in?: Maybe<Int[] | Int>;
  day_not_in?: Maybe<Int[] | Int>;
  day_lt?: Maybe<Int>;
  day_lte?: Maybe<Int>;
  day_gt?: Maybe<Int>;
  day_gte?: Maybe<Int>;
  hour?: Maybe<Int>;
  hour_not?: Maybe<Int>;
  hour_in?: Maybe<Int[] | Int>;
  hour_not_in?: Maybe<Int[] | Int>;
  hour_lt?: Maybe<Int>;
  hour_lte?: Maybe<Int>;
  hour_gt?: Maybe<Int>;
  hour_gte?: Maybe<Int>;
  line?: Maybe<Int>;
  line_not?: Maybe<Int>;
  line_in?: Maybe<Int[] | Int>;
  line_not_in?: Maybe<Int[] | Int>;
  line_lt?: Maybe<Int>;
  line_lte?: Maybe<Int>;
  line_gt?: Maybe<Int>;
  line_gte?: Maybe<Int>;
  minute?: Maybe<Int>;
  minute_not?: Maybe<Int>;
  minute_in?: Maybe<Int[] | Int>;
  minute_not_in?: Maybe<Int[] | Int>;
  minute_lt?: Maybe<Int>;
  minute_lte?: Maybe<Int>;
  minute_gt?: Maybe<Int>;
  minute_gte?: Maybe<Int>;
  month?: Maybe<Int>;
  month_not?: Maybe<Int>;
  month_in?: Maybe<Int[] | Int>;
  month_not_in?: Maybe<Int[] | Int>;
  month_lt?: Maybe<Int>;
  month_lte?: Maybe<Int>;
  month_gt?: Maybe<Int>;
  month_gte?: Maybe<Int>;
  page?: Maybe<Int>;
  page_not?: Maybe<Int>;
  page_in?: Maybe<Int[] | Int>;
  page_not_in?: Maybe<Int[] | Int>;
  page_lt?: Maybe<Int>;
  page_lte?: Maybe<Int>;
  page_gt?: Maybe<Int>;
  page_gte?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawTotalVolume_not?: Maybe<Int>;
  rawTotalVolume_in?: Maybe<Int[] | Int>;
  rawTotalVolume_not_in?: Maybe<Int[] | Int>;
  rawTotalVolume_lt?: Maybe<Int>;
  rawTotalVolume_lte?: Maybe<Int>;
  rawTotalVolume_gt?: Maybe<Int>;
  rawTotalVolume_gte?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeL_not?: Maybe<Int>;
  rawVolumeL_in?: Maybe<Int[] | Int>;
  rawVolumeL_not_in?: Maybe<Int[] | Int>;
  rawVolumeL_lt?: Maybe<Int>;
  rawVolumeL_lte?: Maybe<Int>;
  rawVolumeL_gt?: Maybe<Int>;
  rawVolumeL_gte?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  rawVolumeR_not?: Maybe<Int>;
  rawVolumeR_in?: Maybe<Int[] | Int>;
  rawVolumeR_not_in?: Maybe<Int[] | Int>;
  rawVolumeR_lt?: Maybe<Int>;
  rawVolumeR_lte?: Maybe<Int>;
  rawVolumeR_gt?: Maybe<Int>;
  rawVolumeR_gte?: Maybe<Int>;
  temperature?: Maybe<Int>;
  temperature_not?: Maybe<Int>;
  temperature_in?: Maybe<Int[] | Int>;
  temperature_not_in?: Maybe<Int[] | Int>;
  temperature_lt?: Maybe<Int>;
  temperature_lte?: Maybe<Int>;
  temperature_gt?: Maybe<Int>;
  temperature_gte?: Maybe<Int>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  year?: Maybe<Int>;
  year_not?: Maybe<Int>;
  year_in?: Maybe<Int[] | Int>;
  year_not_in?: Maybe<Int[] | Int>;
  year_lt?: Maybe<Int>;
  year_lte?: Maybe<Int>;
  year_gt?: Maybe<Int>;
  year_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  AND?: Maybe<CupDatumScalarWhereInput[] | CupDatumScalarWhereInput>;
  OR?: Maybe<CupDatumScalarWhereInput[] | CupDatumScalarWhereInput>;
  NOT?: Maybe<CupDatumScalarWhereInput[] | CupDatumScalarWhereInput>;
}

export interface PlatformCompWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  phoneId?: Maybe<Int>;
  phoneId_not?: Maybe<Int>;
  phoneId_in?: Maybe<Int[] | Int>;
  phoneId_not_in?: Maybe<Int[] | Int>;
  phoneId_lt?: Maybe<Int>;
  phoneId_lte?: Maybe<Int>;
  phoneId_gt?: Maybe<Int>;
  phoneId_gte?: Maybe<Int>;
  platformId?: Maybe<Int>;
  platformId_not?: Maybe<Int>;
  platformId_in?: Maybe<Int[] | Int>;
  platformId_not_in?: Maybe<Int[] | Int>;
  platformId_lt?: Maybe<Int>;
  platformId_lte?: Maybe<Int>;
  platformId_gt?: Maybe<Int>;
  platformId_gte?: Maybe<Int>;
  problemHistory?: Maybe<Boolean>;
  problemHistory_not?: Maybe<Boolean>;
  softwareId?: Maybe<Int>;
  softwareId_not?: Maybe<Int>;
  softwareId_in?: Maybe<Int[] | Int>;
  softwareId_not_in?: Maybe<Int[] | Int>;
  softwareId_lt?: Maybe<Int>;
  softwareId_lte?: Maybe<Int>;
  softwareId_gt?: Maybe<Int>;
  softwareId_gte?: Maybe<Int>;
  successHistory?: Maybe<Boolean>;
  successHistory_not?: Maybe<Boolean>;
  AND?: Maybe<PlatformCompWhereInput[] | PlatformCompWhereInput>;
  OR?: Maybe<PlatformCompWhereInput[] | PlatformCompWhereInput>;
  NOT?: Maybe<PlatformCompWhereInput[] | PlatformCompWhereInput>;
}

export interface CupDatumUpdateManyWithWhereNestedInput {
  where: CupDatumScalarWhereInput;
  data: CupDatumUpdateManyDataInput;
}

export interface CupDataUserRemoveUpdateInput {
  changeTime?: Maybe<DateTimeInput>;
  explain?: Maybe<
    CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput
  >;
  serialNumber?: Maybe<CupUpdateOneRequiredWithoutCupDataUserRemoveInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataUserRemoveInput>;
}

export interface CupDatumCreateWithoutCupDataProcVolumeInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: Maybe<CupDataColourCalcCreateManyWithoutCupDataRowInput>;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupCreateOneWithoutCupDataInput>;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDataRejectionUpdateManyMutationInput {
  rejectionDescription?: Maybe<String>;
}

export interface CupDataColourCalibUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataColourCalibCreateWithoutSerialNumberInput[]
    | CupDataColourCalibCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<
    CupDataColourCalibWhereUniqueInput[] | CupDataColourCalibWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataColourCalibWhereUniqueInput[] | CupDataColourCalibWhereUniqueInput
  >;
  set?: Maybe<
    CupDataColourCalibWhereUniqueInput[] | CupDataColourCalibWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataColourCalibWhereUniqueInput[] | CupDataColourCalibWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<
    CupDataColourCalibScalarWhereInput[] | CupDataColourCalibScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataColourCalibUpdateManyWithWhereNestedInput[]
    | CupDataColourCalibUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataProcMdateUpsertWithWhereUniqueWithoutRejectInput {
  where: CupDataProcMdateWhereUniqueInput;
  update: CupDataProcMdateUpdateWithoutRejectDataInput;
  create: CupDataProcMdateCreateWithoutRejectInput;
}

export interface CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataColourCalibWhereUniqueInput;
  data: CupDataColourCalibUpdateWithoutSerialNumberDataInput;
}

export interface CupDataProcMdateUpdateWithWhereUniqueWithoutRejectInput {
  where: CupDataProcMdateWhereUniqueInput;
  data: CupDataProcMdateUpdateWithoutRejectDataInput;
}

export interface CupDataColourCalibUpdateWithoutSerialNumberDataInput {
  blue?: Maybe<Int>;
  c?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface CupDataProcMdateUpdateManyWithoutRejectInput {
  create?: Maybe<
    | CupDataProcMdateCreateWithoutRejectInput[]
    | CupDataProcMdateCreateWithoutRejectInput
  >;
  delete?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  set?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataProcMdateUpdateWithWhereUniqueWithoutRejectInput[]
    | CupDataProcMdateUpdateWithWhereUniqueWithoutRejectInput
  >;
  upsert?: Maybe<
    | CupDataProcMdateUpsertWithWhereUniqueWithoutRejectInput[]
    | CupDataProcMdateUpsertWithWhereUniqueWithoutRejectInput
  >;
  deleteMany?: Maybe<
    CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataProcMdateUpdateManyWithWhereNestedInput[]
    | CupDataProcMdateUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataColourCalibWhereUniqueInput;
  update: CupDataColourCalibUpdateWithoutSerialNumberDataInput;
  create: CupDataColourCalibCreateWithoutSerialNumberInput;
}

export interface CupDataProcMdateCreateWithoutRejectInput {
  cupDataManMdates?: Maybe<CupDataManMdateCreateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rewardAmount?: Maybe<Int>;
  user: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface CupDataColourCalibScalarWhereInput {
  cup_data_colour_calib_id?: Maybe<Int>;
  cup_data_colour_calib_id_not?: Maybe<Int>;
  cup_data_colour_calib_id_in?: Maybe<Int[] | Int>;
  cup_data_colour_calib_id_not_in?: Maybe<Int[] | Int>;
  cup_data_colour_calib_id_lt?: Maybe<Int>;
  cup_data_colour_calib_id_lte?: Maybe<Int>;
  cup_data_colour_calib_id_gt?: Maybe<Int>;
  cup_data_colour_calib_id_gte?: Maybe<Int>;
  blue?: Maybe<Int>;
  blue_not?: Maybe<Int>;
  blue_in?: Maybe<Int[] | Int>;
  blue_not_in?: Maybe<Int[] | Int>;
  blue_lt?: Maybe<Int>;
  blue_lte?: Maybe<Int>;
  blue_gt?: Maybe<Int>;
  blue_gte?: Maybe<Int>;
  c?: Maybe<Int>;
  c_not?: Maybe<Int>;
  c_in?: Maybe<Int[] | Int>;
  c_not_in?: Maybe<Int[] | Int>;
  c_lt?: Maybe<Int>;
  c_lte?: Maybe<Int>;
  c_gt?: Maybe<Int>;
  c_gte?: Maybe<Int>;
  green?: Maybe<Int>;
  green_not?: Maybe<Int>;
  green_in?: Maybe<Int[] | Int>;
  green_not_in?: Maybe<Int[] | Int>;
  green_lt?: Maybe<Int>;
  green_lte?: Maybe<Int>;
  green_gt?: Maybe<Int>;
  green_gte?: Maybe<Int>;
  red?: Maybe<Int>;
  red_not?: Maybe<Int>;
  red_in?: Maybe<Int[] | Int>;
  red_not_in?: Maybe<Int[] | Int>;
  red_lt?: Maybe<Int>;
  red_lte?: Maybe<Int>;
  red_gt?: Maybe<Int>;
  red_gte?: Maybe<Int>;
  AND?: Maybe<
    CupDataColourCalibScalarWhereInput[] | CupDataColourCalibScalarWhereInput
  >;
  OR?: Maybe<
    CupDataColourCalibScalarWhereInput[] | CupDataColourCalibScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataColourCalibScalarWhereInput[] | CupDataColourCalibScalarWhereInput
  >;
}

export interface CupDataProcMdateCreateManyWithoutRejectInput {
  create?: Maybe<
    | CupDataProcMdateCreateWithoutRejectInput[]
    | CupDataProcMdateCreateWithoutRejectInput
  >;
  connect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
}

export interface CupDataColourCalibUpdateManyWithWhereNestedInput {
  where: CupDataColourCalibScalarWhereInput;
  data: CupDataColourCalibUpdateManyDataInput;
}

export interface CupDataRawUpdateManyMutationInput {
  pageData?: Maybe<String>;
}

export interface CupDataColourCalibUpdateManyDataInput {
  blue?: Maybe<Int>;
  c?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface CupUpsertWithoutCupDataRawInput {
  update: CupUpdateWithoutCupDataRawDataInput;
  create: CupCreateWithoutCupDataRawInput;
}

export interface CupDataRawUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataRawCreateWithoutSerialNumberInput[]
    | CupDataRawCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput>;
  connect?: Maybe<CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput>;
  set?: Maybe<CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput>;
  disconnect?: Maybe<CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput>;
  update?: Maybe<
    | CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput>;
  updateMany?: Maybe<
    | CupDataRawUpdateManyWithWhereNestedInput[]
    | CupDataRawUpdateManyWithWhereNestedInput
  >;
}

export interface CupUpdateOneWithoutCupDataRawInput {
  create?: Maybe<CupCreateWithoutCupDataRawInput>;
  update?: Maybe<CupUpdateWithoutCupDataRawDataInput>;
  upsert?: Maybe<CupUpsertWithoutCupDataRawInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataRawWhereUniqueInput;
  data: CupDataRawUpdateWithoutSerialNumberDataInput;
}

export interface CupDataRawUpdateInput {
  pageData?: Maybe<String>;
  serialNumber?: Maybe<CupUpdateOneWithoutCupDataRawInput>;
}

export interface CupDataRawUpdateWithoutSerialNumberDataInput {
  pageData?: Maybe<String>;
}

export interface CupCreateOneWithoutCupDataRawInput {
  create?: Maybe<CupCreateWithoutCupDataRawInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataRawWhereUniqueInput;
  update: CupDataRawUpdateWithoutSerialNumberDataInput;
  create: CupDataRawCreateWithoutSerialNumberInput;
}

export interface CupDataRawCreateInput {
  pageData: String;
  serialNumber?: Maybe<CupCreateOneWithoutCupDataRawInput>;
}

export interface CupDataRawScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  pageData?: Maybe<String>;
  pageData_not?: Maybe<String>;
  pageData_in?: Maybe<String[] | String>;
  pageData_not_in?: Maybe<String[] | String>;
  pageData_lt?: Maybe<String>;
  pageData_lte?: Maybe<String>;
  pageData_gt?: Maybe<String>;
  pageData_gte?: Maybe<String>;
  pageData_contains?: Maybe<String>;
  pageData_not_contains?: Maybe<String>;
  pageData_starts_with?: Maybe<String>;
  pageData_not_starts_with?: Maybe<String>;
  pageData_ends_with?: Maybe<String>;
  pageData_not_ends_with?: Maybe<String>;
  AND?: Maybe<CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput>;
  OR?: Maybe<CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput>;
  NOT?: Maybe<CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput>;
}

export interface CupDataQuestionUpdateInput {
  cupDataAnswer?: Maybe<CupDataAnswerUpdateManyWithoutQuestionInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutQuestionInput>;
  questionText?: Maybe<String>;
}

export interface CupDataRawUpdateManyWithWhereNestedInput {
  where: CupDataRawScalarWhereInput;
  data: CupDataRawUpdateManyDataInput;
}

export interface CupDataQuestionCreateInput {
  cupDataAnswer?: Maybe<CupDataAnswerCreateManyWithoutQuestionInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutQuestionInput>;
  questionText: String;
}

export interface CupDataRawUpdateManyDataInput {
  pageData?: Maybe<String>;
}

export interface CupDataQaResponseUpdateInput {
  answer?: Maybe<CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput>;
  qaDate?: Maybe<DateTimeInput>;
  question?: Maybe<
    CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput
  >;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataQaResponseInput>;
}

export interface FirmwareUpdateOneWithoutCupInput {
  create?: Maybe<FirmwareCreateWithoutCupInput>;
  update?: Maybe<FirmwareUpdateWithoutCupDataInput>;
  upsert?: Maybe<FirmwareUpsertWithoutCupInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FirmwareWhereUniqueInput>;
}

export interface CupDataQaResponseCreateInput {
  answer: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  question: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
  user: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface FirmwareUpdateWithoutCupDataInput {
  fwVersion?: Maybe<String>;
}

export interface CupDataProcVolumeUpdateManyMutationInput {
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export interface FirmwareUpsertWithoutCupInput {
  update: FirmwareUpdateWithoutCupDataInput;
  create: FirmwareCreateWithoutCupInput;
}

export interface CupDatumUpdateWithoutCupDataProcVolumeDataInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  cupDataColourCalc?: Maybe<CupDataColourCalcUpdateManyWithoutCupDataRowInput>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupUpdateOneWithoutCupDataInput>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export interface HardwareUpdateOneWithoutCupInput {
  create?: Maybe<HardwareCreateWithoutCupInput>;
  update?: Maybe<HardwareUpdateWithoutCupDataInput>;
  upsert?: Maybe<HardwareUpsertWithoutCupInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<HardwareWhereUniqueInput>;
}

export interface CupDataProcVolumeUpdateInput {
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  cupDataRow?: Maybe<CupDatumUpdateOneRequiredWithoutCupDataProcVolumeInput>;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export interface UserRecordDataByTimeWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  changeTime?: Maybe<DateTimeInput>;
  changeTime_not?: Maybe<DateTimeInput>;
  changeTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_lt?: Maybe<DateTimeInput>;
  changeTime_lte?: Maybe<DateTimeInput>;
  changeTime_gt?: Maybe<DateTimeInput>;
  changeTime_gte?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorB_not?: Maybe<Int>;
  colorB_in?: Maybe<Int[] | Int>;
  colorB_not_in?: Maybe<Int[] | Int>;
  colorB_lt?: Maybe<Int>;
  colorB_lte?: Maybe<Int>;
  colorB_gt?: Maybe<Int>;
  colorB_gte?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorG_not?: Maybe<Int>;
  colorG_in?: Maybe<Int[] | Int>;
  colorG_not_in?: Maybe<Int[] | Int>;
  colorG_lt?: Maybe<Int>;
  colorG_lte?: Maybe<Int>;
  colorG_gt?: Maybe<Int>;
  colorG_gte?: Maybe<Int>;
  colorR?: Maybe<Int>;
  colorR_not?: Maybe<Int>;
  colorR_in?: Maybe<Int[] | Int>;
  colorR_not_in?: Maybe<Int[] | Int>;
  colorR_lt?: Maybe<Int>;
  colorR_lte?: Maybe<Int>;
  colorR_gt?: Maybe<Int>;
  colorR_gte?: Maybe<Int>;
  leakage?: Maybe<String>;
  leakage_not?: Maybe<String>;
  leakage_in?: Maybe<String[] | String>;
  leakage_not_in?: Maybe<String[] | String>;
  leakage_lt?: Maybe<String>;
  leakage_lte?: Maybe<String>;
  leakage_gt?: Maybe<String>;
  leakage_gte?: Maybe<String>;
  leakage_contains?: Maybe<String>;
  leakage_not_contains?: Maybe<String>;
  leakage_starts_with?: Maybe<String>;
  leakage_not_starts_with?: Maybe<String>;
  leakage_ends_with?: Maybe<String>;
  leakage_not_ends_with?: Maybe<String>;
  recordDayRow?: Maybe<UserRecordDataByDayWhereInput>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
  volume_not?: Maybe<Float>;
  volume_in?: Maybe<Float[] | Float>;
  volume_not_in?: Maybe<Float[] | Float>;
  volume_lt?: Maybe<Float>;
  volume_lte?: Maybe<Float>;
  volume_gt?: Maybe<Float>;
  volume_gte?: Maybe<Float>;
  AND?: Maybe<
    UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput
  >;
  OR?: Maybe<UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput>;
  NOT?: Maybe<
    UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput
  >;
}

export interface AnswerTypeCreateInput {
  answerType: String;
  userInterviewQuestions?: Maybe<
    UserInterviewQuestionCreateManyWithoutAnswerTypeInput
  >;
}

export interface HardwareUpsertWithoutCupInput {
  update: HardwareUpdateWithoutCupDataInput;
  create: HardwareCreateWithoutCupInput;
}

export interface UserInterviewQuestionCreateWithoutAnswerTypeInput {
  question: String;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutQuestionInput>;
}

export interface UserCupUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | UserCupCreateWithoutSerialNumberInput[]
    | UserCupCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  connect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  set?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  disconnect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  update?: Maybe<
    | UserCupUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | UserCupUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | UserCupUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | UserCupUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<UserCupScalarWhereInput[] | UserCupScalarWhereInput>;
}

export interface UserInterviewDatumCreateWithoutQuestionInput {
  row_id?: Maybe<Int>;
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date: DateTimeInput;
  user: UserCreateOneWithoutUserInterviewDataInput;
}

export interface UserCupUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: UserCupWhereUniqueInput;
  data: UserCupUpdateWithoutSerialNumberDataInput;
}

export interface UserCreateWithoutUserInterviewDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserCupUpdateWithoutSerialNumberDataInput {
  user?: Maybe<UserUpdateOneWithoutUserCupsInput>;
}

export interface AppServerSyncCreateWithoutUserInput {
  serverSynchTime: DateTimeInput;
}

export interface UserUpdateOneWithoutUserCupsInput {
  create?: Maybe<UserCreateWithoutUserCupsInput>;
  update?: Maybe<UserUpdateWithoutUserCupsDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserCupsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CountryCreateWithoutUsersInput {
  countryName: String;
}

export interface UserUpdateWithoutUserCupsDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface CupDataProcFlowCreateWithoutUserInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  mdateRow: CupDataProcMdateCreateOneWithoutCupDataProcFlowInput;
}

export interface EthnicityUpdateOneRequiredWithoutUsersInput {
  create?: Maybe<EthnicityCreateWithoutUsersInput>;
  update?: Maybe<EthnicityUpdateWithoutUsersDataInput>;
  upsert?: Maybe<EthnicityUpsertWithoutUsersInput>;
  connect?: Maybe<EthnicityWhereUniqueInput>;
}

export interface CupDataProcMdateCreateWithoutCupDataProcFlowInput {
  cupDataManMdates?: Maybe<CupDataManMdateCreateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  reject?: Maybe<CupDataRejectionCreateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface EthnicityUpdateWithoutUsersDataInput {
  ethnicity?: Maybe<String>;
}

export interface CupDataManMdateCreateWithoutMdateRowInput {
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface EthnicityUpsertWithoutUsersInput {
  update: EthnicityUpdateWithoutUsersDataInput;
  create: EthnicityCreateWithoutUsersInput;
}

export interface CupDataRejectionCreateWithoutCupDataProcMdatesInput {
  rejectionDescription: String;
}

export interface UserCoinHistoryUpdateManyWithoutUserInput {
  create?: Maybe<
    | UserCoinHistoryCreateWithoutUserInput[]
    | UserCoinHistoryCreateWithoutUserInput
  >;
  delete?: Maybe<
    UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput
  >;
  connect?: Maybe<
    UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput
  >;
  set?: Maybe<
    UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput
  >;
  update?: Maybe<
    | UserCoinHistoryUpdateWithWhereUniqueWithoutUserInput[]
    | UserCoinHistoryUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserCoinHistoryUpsertWithWhereUniqueWithoutUserInput[]
    | UserCoinHistoryUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserCoinHistoryUpdateManyWithWhereNestedInput[]
    | UserCoinHistoryUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutCupDataProcMdatesInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserCoinHistoryUpdateWithWhereUniqueWithoutUserInput {
  where: UserCoinHistoryWhereUniqueInput;
  data: UserCoinHistoryUpdateWithoutUserDataInput;
}

export interface CupDataQaResponseCreateWithoutUserInput {
  answer: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  question: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
}

export interface UserCoinHistoryUpdateWithoutUserDataInput {
  category?: Maybe<String>;
  coin?: Maybe<Int>;
  contents?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutCoinHistoryRowInput
  >;
}

export interface CupDataAnswerCreateWithoutCupDataQaResponseInput {
  answerText: String;
  question: CupDataQuestionCreateOneWithoutCupDataAnswerInput;
}

export interface UserRecordDataByPeriodUpdateManyWithoutCoinHistoryRowInput {
  create?: Maybe<
    | UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput[]
    | UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput
  >;
  delete?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  connect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  set?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  disconnect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  update?: Maybe<
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutCoinHistoryRowInput[]
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutCoinHistoryRowInput
  >;
  upsert?: Maybe<
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutCoinHistoryRowInput[]
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutCoinHistoryRowInput
  >;
  deleteMany?: Maybe<
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput[]
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataQuestionCreateWithoutCupDataAnswerInput {
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutQuestionInput>;
  questionText: String;
}

export interface UserRecordDataByPeriodUpdateWithWhereUniqueWithoutCoinHistoryRowInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  data: UserRecordDataByPeriodUpdateWithoutCoinHistoryRowDataInput;
}

export interface CupDataQaResponseCreateWithoutQuestionInput {
  answer: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  user: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface UserRecordDataByPeriodUpdateWithoutCoinHistoryRowDataInput {
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneWithoutUserRecordDataByPeriodInput>;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayUpdateManyWithoutRecordPeriodRowInput
  >;
}

export interface UserCreateWithoutCupDataQaResponseInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserUpdateOneWithoutUserRecordDataByPeriodInput {
  create?: Maybe<UserCreateWithoutUserRecordDataByPeriodInput>;
  update?: Maybe<UserUpdateWithoutUserRecordDataByPeriodDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserRecordDataByPeriodInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataProcMdateCreateWithoutUserInput {
  cupDataManMdates?: Maybe<CupDataManMdateCreateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  reject?: Maybe<CupDataRejectionCreateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
}

export interface UserUpdateWithoutUserRecordDataByPeriodDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
}

export interface CupDataProcFlowCreateWithoutMdateRowInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  user: UserCreateOneWithoutCupDataProcFlowInput;
}

export interface UserCupUpdateManyWithoutUserInput {
  create?: Maybe<
    UserCupCreateWithoutUserInput[] | UserCupCreateWithoutUserInput
  >;
  delete?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  connect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  set?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  disconnect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
  update?: Maybe<
    | UserCupUpdateWithWhereUniqueWithoutUserInput[]
    | UserCupUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserCupUpsertWithWhereUniqueWithoutUserInput[]
    | UserCupUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<UserCupScalarWhereInput[] | UserCupScalarWhereInput>;
}

export interface UserCreateWithoutCupDataProcFlowInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserCupUpdateWithWhereUniqueWithoutUserInput {
  where: UserCupWhereUniqueInput;
  data: UserCupUpdateWithoutUserDataInput;
}

export interface CupDataUserRemoveCreateWithoutUserInput {
  changeTime: DateTimeInput;
  explain: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
}

export interface UserCupUpdateWithoutUserDataInput {
  serialNumber?: Maybe<CupUpdateOneWithoutUserCupsInput>;
}

export interface CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput {
  explain: String;
}

export interface CupUpdateOneWithoutUserCupsInput {
  create?: Maybe<CupCreateWithoutUserCupsInput>;
  update?: Maybe<CupUpdateWithoutUserCupsDataInput>;
  upsert?: Maybe<CupUpsertWithoutUserCupsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupCreateWithoutCupDataUserRemoveInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupUpdateWithoutUserCupsDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
}

export interface CalibrationCreateWithoutCupInput {
  calibVersion: String;
}

export interface CupDataUserRemoveUpdateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutSerialNumberInput[]
    | CupDataUserRemoveCreateWithoutSerialNumberInput
  >;
  delete?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  set?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput
  >;
  upsert?: Maybe<
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput
  >;
  deleteMany?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyCreateWithoutCupInput {
  companyName: String;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutSerialNumberDataInput;
}

export interface CupAppSyncCreateWithoutSerialNumberInput {
  appSynchTime: DateTimeInput;
}

export interface CupDataUserRemoveUpdateWithoutSerialNumberDataInput {
  changeTime?: Maybe<DateTimeInput>;
  explain?: Maybe<
    CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput
  >;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataUserRemoveInput>;
}

export interface CupDatumCreateWithoutSerialNumberInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: Maybe<CupDataColourCalcCreateManyWithoutCupDataRowInput>;
  cupDataProcVolume?: Maybe<CupDataProcVolumeCreateManyWithoutCupDataRowInput>;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface UserUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: Maybe<UserCreateWithoutCupDataUserRemoveInput>;
  update?: Maybe<UserUpdateWithoutCupDataUserRemoveDataInput>;
  upsert?: Maybe<UserUpsertWithoutCupDataUserRemoveInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataColourCalcCreateWithoutCupDataRowInput {
  blue: Int;
  green: Int;
  red: Int;
}

export interface UserUpdateWithoutCupDataUserRemoveDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface CupDataProcVolumeCreateWithoutCupDataRowInput {
  row_id?: Maybe<Int>;
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export interface UserInterviewDatumUpdateManyWithoutUserInput {
  create?: Maybe<
    | UserInterviewDatumCreateWithoutUserInput[]
    | UserInterviewDatumCreateWithoutUserInput
  >;
  delete?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  connect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  set?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  update?: Maybe<
    | UserInterviewDatumUpdateWithWhereUniqueWithoutUserInput[]
    | UserInterviewDatumUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserInterviewDatumUpsertWithWhereUniqueWithoutUserInput[]
    | UserInterviewDatumUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    UserInterviewDatumScalarWhereInput[] | UserInterviewDatumScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserInterviewDatumUpdateManyWithWhereNestedInput[]
    | UserInterviewDatumUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataColourCalibCreateWithoutSerialNumberInput {
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface UserInterviewDatumUpdateWithWhereUniqueWithoutUserInput {
  where: UserInterviewDatumWhereUniqueInput;
  data: UserInterviewDatumUpdateWithoutUserDataInput;
}

export interface CupDataRawCreateWithoutSerialNumberInput {
  pageData: String;
}

export interface UserInterviewDatumUpdateWithoutUserDataInput {
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
  question?: Maybe<
    UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput
  >;
}

export interface FirmwareCreateWithoutCupInput {
  fwVersion: String;
}

export interface UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput {
  create?: Maybe<UserInterviewQuestionCreateWithoutUserInterviewDataInput>;
  update?: Maybe<UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput>;
  upsert?: Maybe<UserInterviewQuestionUpsertWithoutUserInterviewDataInput>;
  connect?: Maybe<UserInterviewQuestionWhereUniqueInput>;
}

export interface HardwareCreateWithoutCupInput {
  hwVersion: String;
}

export interface UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput {
  answerType?: Maybe<
    AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput
  >;
  question?: Maybe<String>;
}

export interface UserCupCreateWithoutSerialNumberInput {
  user?: Maybe<UserCreateOneWithoutUserCupsInput>;
}

export interface AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput {
  create?: Maybe<AnswerTypeCreateWithoutUserInterviewQuestionsInput>;
  update?: Maybe<AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput>;
  upsert?: Maybe<AnswerTypeUpsertWithoutUserInterviewQuestionsInput>;
  connect?: Maybe<AnswerTypeWhereUniqueInput>;
}

export interface UserCreateWithoutUserCupsInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput {
  answerType?: Maybe<String>;
}

export interface EthnicityCreateWithoutUsersInput {
  ethnicity: String;
}

export interface AnswerTypeUpsertWithoutUserInterviewQuestionsInput {
  update: AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput;
  create: AnswerTypeCreateWithoutUserInterviewQuestionsInput;
}

export interface UserCoinHistoryCreateWithoutUserInput {
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeInput;
  txhash: String;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutCoinHistoryRowInput
  >;
}

export interface UserInterviewQuestionUpsertWithoutUserInterviewDataInput {
  update: UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput;
  create: UserInterviewQuestionCreateWithoutUserInterviewDataInput;
}

export interface UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput {
  isTakePill?: Maybe<Boolean>;
  mensFinish: DateTimeInput;
  mensStart: DateTimeInput;
  user?: Maybe<UserCreateOneWithoutUserRecordDataByPeriodInput>;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayCreateManyWithoutRecordPeriodRowInput
  >;
}

export interface UserInterviewDatumUpsertWithWhereUniqueWithoutUserInput {
  where: UserInterviewDatumWhereUniqueInput;
  update: UserInterviewDatumUpdateWithoutUserDataInput;
  create: UserInterviewDatumCreateWithoutUserInput;
}

export interface UserCreateWithoutUserRecordDataByPeriodInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
}

export interface UserInterviewDatumScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  answerRange?: Maybe<Int>;
  answerRange_not?: Maybe<Int>;
  answerRange_in?: Maybe<Int[] | Int>;
  answerRange_not_in?: Maybe<Int[] | Int>;
  answerRange_lt?: Maybe<Int>;
  answerRange_lte?: Maybe<Int>;
  answerRange_gt?: Maybe<Int>;
  answerRange_gte?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerText_not?: Maybe<String>;
  answerText_in?: Maybe<String[] | String>;
  answerText_not_in?: Maybe<String[] | String>;
  answerText_lt?: Maybe<String>;
  answerText_lte?: Maybe<String>;
  answerText_gt?: Maybe<String>;
  answerText_gte?: Maybe<String>;
  answerText_contains?: Maybe<String>;
  answerText_not_contains?: Maybe<String>;
  answerText_starts_with?: Maybe<String>;
  answerText_not_starts_with?: Maybe<String>;
  answerText_ends_with?: Maybe<String>;
  answerText_not_ends_with?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  answerYn_not?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    UserInterviewDatumScalarWhereInput[] | UserInterviewDatumScalarWhereInput
  >;
  OR?: Maybe<
    UserInterviewDatumScalarWhereInput[] | UserInterviewDatumScalarWhereInput
  >;
  NOT?: Maybe<
    UserInterviewDatumScalarWhereInput[] | UserInterviewDatumScalarWhereInput
  >;
}

export interface UserCupCreateWithoutUserInput {
  serialNumber?: Maybe<CupCreateOneWithoutUserCupsInput>;
}

export interface UserInterviewDatumUpdateManyWithWhereNestedInput {
  where: UserInterviewDatumScalarWhereInput;
  data: UserInterviewDatumUpdateManyDataInput;
}

export interface CupCreateWithoutUserCupsInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
}

export interface UserInterviewDatumUpdateManyDataInput {
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
}

export interface CupDataUserRemoveCreateWithoutSerialNumberInput {
  changeTime: DateTimeInput;
  explain: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  user: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface UserRecordDataByPeriodUpdateManyWithoutUserInput {
  create?: Maybe<
    | UserRecordDataByPeriodCreateWithoutUserInput[]
    | UserRecordDataByPeriodCreateWithoutUserInput
  >;
  delete?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  connect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  set?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  disconnect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
  update?: Maybe<
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserInput[]
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserInput[]
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput[]
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutCupDataUserRemoveInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  data: UserRecordDataByPeriodUpdateWithoutUserDataInput;
}

export interface UserInterviewDatumCreateWithoutUserInput {
  row_id?: Maybe<Int>;
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date: DateTimeInput;
  question: UserInterviewQuestionCreateOneWithoutUserInterviewDataInput;
}

export interface UserRecordDataByPeriodUpdateWithoutUserDataInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryUpdateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayUpdateManyWithoutRecordPeriodRowInput
  >;
}

export interface UserInterviewQuestionCreateWithoutUserInterviewDataInput {
  answerType: AnswerTypeCreateOneWithoutUserInterviewQuestionsInput;
  question: String;
}

export interface UserCoinHistoryUpdateOneWithoutUserRecordDataByPeriodInput {
  create?: Maybe<UserCoinHistoryCreateWithoutUserRecordDataByPeriodInput>;
  update?: Maybe<UserCoinHistoryUpdateWithoutUserRecordDataByPeriodDataInput>;
  upsert?: Maybe<UserCoinHistoryUpsertWithoutUserRecordDataByPeriodInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserCoinHistoryWhereUniqueInput>;
}

export interface AnswerTypeCreateWithoutUserInterviewQuestionsInput {
  answerType: String;
}

export interface UserCoinHistoryUpdateWithoutUserRecordDataByPeriodDataInput {
  category?: Maybe<String>;
  coin?: Maybe<Int>;
  contents?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutUserCoinHistoryInput>;
}

export interface UserRecordDataByPeriodCreateWithoutUserInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryCreateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish: DateTimeInput;
  mensStart: DateTimeInput;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayCreateManyWithoutRecordPeriodRowInput
  >;
}

export interface UserUpdateOneWithoutUserCoinHistoryInput {
  create?: Maybe<UserCreateWithoutUserCoinHistoryInput>;
  update?: Maybe<UserUpdateWithoutUserCoinHistoryDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserCoinHistoryInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCoinHistoryCreateWithoutUserRecordDataByPeriodInput {
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeInput;
  txhash: String;
  user?: Maybe<UserCreateOneWithoutUserCoinHistoryInput>;
}

export interface UserUpdateWithoutUserCoinHistoryDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface UserCreateWithoutUserCoinHistoryInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserUpsertWithoutUserCoinHistoryInput {
  update: UserUpdateWithoutUserCoinHistoryDataInput;
  create: UserCreateWithoutUserCoinHistoryInput;
}

export interface UserRecordDataByDayCreateWithoutRecordPeriodRowInput {
  crampsLevel?: Maybe<Int>;
  recordDate: DateTimeInput;
  userRecordDataByTime?: Maybe<
    UserRecordDataByTimeCreateManyWithoutRecordDayRowInput
  >;
}

export interface UserCoinHistoryUpsertWithoutUserRecordDataByPeriodInput {
  update: UserCoinHistoryUpdateWithoutUserRecordDataByPeriodDataInput;
  create: UserCoinHistoryCreateWithoutUserRecordDataByPeriodInput;
}

export interface UserRecordDataByTimeCreateWithoutRecordDayRowInput {
  changeTime: DateTimeInput;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserRecordDataByDayUpdateManyWithoutRecordPeriodRowInput {
  create?: Maybe<
    | UserRecordDataByDayCreateWithoutRecordPeriodRowInput[]
    | UserRecordDataByDayCreateWithoutRecordPeriodRowInput
  >;
  delete?: Maybe<
    UserRecordDataByDayWhereUniqueInput[] | UserRecordDataByDayWhereUniqueInput
  >;
  connect?: Maybe<
    UserRecordDataByDayWhereUniqueInput[] | UserRecordDataByDayWhereUniqueInput
  >;
  set?: Maybe<
    UserRecordDataByDayWhereUniqueInput[] | UserRecordDataByDayWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserRecordDataByDayWhereUniqueInput[] | UserRecordDataByDayWhereUniqueInput
  >;
  update?: Maybe<
    | UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowInput[]
    | UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowInput
  >;
  upsert?: Maybe<
    | UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowInput[]
    | UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowInput
  >;
  deleteMany?: Maybe<
    UserRecordDataByDayScalarWhereInput[] | UserRecordDataByDayScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserRecordDataByDayUpdateManyWithWhereNestedInput[]
    | UserRecordDataByDayUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataQuestionCreateOneWithoutCupDataQaResponseInput {
  create?: Maybe<CupDataQuestionCreateWithoutCupDataQaResponseInput>;
  connect?: Maybe<CupDataQuestionWhereUniqueInput>;
}

export interface UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowInput {
  where: UserRecordDataByDayWhereUniqueInput;
  data: UserRecordDataByDayUpdateWithoutRecordPeriodRowDataInput;
}

export interface CupDataAnswerCreateManyWithoutQuestionInput {
  create?: Maybe<
    | CupDataAnswerCreateWithoutQuestionInput[]
    | CupDataAnswerCreateWithoutQuestionInput
  >;
  connect?: Maybe<
    CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput
  >;
}

export interface UserRecordDataByDayUpdateWithoutRecordPeriodRowDataInput {
  crampsLevel?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
  userRecordDataByTime?: Maybe<
    UserRecordDataByTimeUpdateManyWithoutRecordDayRowInput
  >;
}

export interface CupDataQaResponseCreateManyWithoutAnswerInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutAnswerInput[]
    | CupDataQaResponseCreateWithoutAnswerInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
}

export interface UserRecordDataByTimeUpdateManyWithoutRecordDayRowInput {
  create?: Maybe<
    | UserRecordDataByTimeCreateWithoutRecordDayRowInput[]
    | UserRecordDataByTimeCreateWithoutRecordDayRowInput
  >;
  delete?: Maybe<
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput
  >;
  connect?: Maybe<
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput
  >;
  set?: Maybe<
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput
  >;
  disconnect?: Maybe<
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput
  >;
  update?: Maybe<
    | UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowInput[]
    | UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowInput
  >;
  upsert?: Maybe<
    | UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowInput[]
    | UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowInput
  >;
  deleteMany?: Maybe<
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserRecordDataByTimeUpdateManyWithWhereNestedInput[]
    | UserRecordDataByTimeUpdateManyWithWhereNestedInput
  >;
}

export interface AnswerTypeUpdateInput {
  answerType?: Maybe<String>;
  userInterviewQuestions?: Maybe<
    UserInterviewQuestionUpdateManyWithoutAnswerTypeInput
  >;
}

export interface UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowInput {
  where: UserRecordDataByTimeWhereUniqueInput;
  data: UserRecordDataByTimeUpdateWithoutRecordDayRowDataInput;
}

export interface UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeInput {
  where: UserInterviewQuestionWhereUniqueInput;
  data: UserInterviewQuestionUpdateWithoutAnswerTypeDataInput;
}

export interface UserRecordDataByTimeUpdateWithoutRecordDayRowDataInput {
  changeTime?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserInterviewDatumUpdateManyWithoutQuestionInput {
  create?: Maybe<
    | UserInterviewDatumCreateWithoutQuestionInput[]
    | UserInterviewDatumCreateWithoutQuestionInput
  >;
  delete?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  connect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  set?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  disconnect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
  update?: Maybe<
    | UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionInput[]
    | UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionInput
  >;
  upsert?: Maybe<
    | UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionInput[]
    | UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionInput
  >;
  deleteMany?: Maybe<
    UserInterviewDatumScalarWhereInput[] | UserInterviewDatumScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserInterviewDatumUpdateManyWithWhereNestedInput[]
    | UserInterviewDatumUpdateManyWithWhereNestedInput
  >;
}

export interface UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowInput {
  where: UserRecordDataByTimeWhereUniqueInput;
  update: UserRecordDataByTimeUpdateWithoutRecordDayRowDataInput;
  create: UserRecordDataByTimeCreateWithoutRecordDayRowInput;
}

export interface UserInterviewDatumUpdateWithoutQuestionDataInput {
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutUserInterviewDataInput>;
}

export interface UserRecordDataByTimeScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  changeTime?: Maybe<DateTimeInput>;
  changeTime_not?: Maybe<DateTimeInput>;
  changeTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_lt?: Maybe<DateTimeInput>;
  changeTime_lte?: Maybe<DateTimeInput>;
  changeTime_gt?: Maybe<DateTimeInput>;
  changeTime_gte?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorB_not?: Maybe<Int>;
  colorB_in?: Maybe<Int[] | Int>;
  colorB_not_in?: Maybe<Int[] | Int>;
  colorB_lt?: Maybe<Int>;
  colorB_lte?: Maybe<Int>;
  colorB_gt?: Maybe<Int>;
  colorB_gte?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorG_not?: Maybe<Int>;
  colorG_in?: Maybe<Int[] | Int>;
  colorG_not_in?: Maybe<Int[] | Int>;
  colorG_lt?: Maybe<Int>;
  colorG_lte?: Maybe<Int>;
  colorG_gt?: Maybe<Int>;
  colorG_gte?: Maybe<Int>;
  colorR?: Maybe<Int>;
  colorR_not?: Maybe<Int>;
  colorR_in?: Maybe<Int[] | Int>;
  colorR_not_in?: Maybe<Int[] | Int>;
  colorR_lt?: Maybe<Int>;
  colorR_lte?: Maybe<Int>;
  colorR_gt?: Maybe<Int>;
  colorR_gte?: Maybe<Int>;
  leakage?: Maybe<String>;
  leakage_not?: Maybe<String>;
  leakage_in?: Maybe<String[] | String>;
  leakage_not_in?: Maybe<String[] | String>;
  leakage_lt?: Maybe<String>;
  leakage_lte?: Maybe<String>;
  leakage_gt?: Maybe<String>;
  leakage_gte?: Maybe<String>;
  leakage_contains?: Maybe<String>;
  leakage_not_contains?: Maybe<String>;
  leakage_starts_with?: Maybe<String>;
  leakage_not_starts_with?: Maybe<String>;
  leakage_ends_with?: Maybe<String>;
  leakage_not_ends_with?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  startTime_not?: Maybe<DateTimeInput>;
  startTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startTime_lt?: Maybe<DateTimeInput>;
  startTime_lte?: Maybe<DateTimeInput>;
  startTime_gt?: Maybe<DateTimeInput>;
  startTime_gte?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
  volume_not?: Maybe<Float>;
  volume_in?: Maybe<Float[] | Float>;
  volume_not_in?: Maybe<Float[] | Float>;
  volume_lt?: Maybe<Float>;
  volume_lte?: Maybe<Float>;
  volume_gt?: Maybe<Float>;
  volume_gte?: Maybe<Float>;
  AND?: Maybe<
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput
  >;
  OR?: Maybe<
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput
  >;
  NOT?: Maybe<
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput
  >;
}

export interface UserUpdateWithoutUserInterviewDataDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface UserRecordDataByTimeUpdateManyWithWhereNestedInput {
  where: UserRecordDataByTimeScalarWhereInput;
  data: UserRecordDataByTimeUpdateManyDataInput;
}

export interface UsersDataAnalysisSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UsersDataAnalysisWhereInput>;
  AND?: Maybe<
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput
  >;
}

export interface UserRecordDataByTimeUpdateManyDataInput {
  changeTime?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserRecordDataByPeriodWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  coinHistoryRow?: Maybe<UserCoinHistoryWhereInput>;
  isTakePill?: Maybe<Boolean>;
  isTakePill_not?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensFinish_not?: Maybe<DateTimeInput>;
  mensFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensFinish_lt?: Maybe<DateTimeInput>;
  mensFinish_lte?: Maybe<DateTimeInput>;
  mensFinish_gt?: Maybe<DateTimeInput>;
  mensFinish_gte?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  mensStart_not?: Maybe<DateTimeInput>;
  mensStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensStart_lt?: Maybe<DateTimeInput>;
  mensStart_lte?: Maybe<DateTimeInput>;
  mensStart_gt?: Maybe<DateTimeInput>;
  mensStart_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  userRecordDataByDay_every?: Maybe<UserRecordDataByDayWhereInput>;
  userRecordDataByDay_some?: Maybe<UserRecordDataByDayWhereInput>;
  userRecordDataByDay_none?: Maybe<UserRecordDataByDayWhereInput>;
  AND?: Maybe<
    UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput
  >;
  OR?: Maybe<
    UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput
  >;
  NOT?: Maybe<
    UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput
  >;
}

export interface UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowInput {
  where: UserRecordDataByDayWhereUniqueInput;
  update: UserRecordDataByDayUpdateWithoutRecordPeriodRowDataInput;
  create: UserRecordDataByDayCreateWithoutRecordPeriodRowInput;
}

export interface EthnicityWhereInput {
  ethnicity_id?: Maybe<Int>;
  ethnicity_id_not?: Maybe<Int>;
  ethnicity_id_in?: Maybe<Int[] | Int>;
  ethnicity_id_not_in?: Maybe<Int[] | Int>;
  ethnicity_id_lt?: Maybe<Int>;
  ethnicity_id_lte?: Maybe<Int>;
  ethnicity_id_gt?: Maybe<Int>;
  ethnicity_id_gte?: Maybe<Int>;
  ethnicity?: Maybe<String>;
  ethnicity_not?: Maybe<String>;
  ethnicity_in?: Maybe<String[] | String>;
  ethnicity_not_in?: Maybe<String[] | String>;
  ethnicity_lt?: Maybe<String>;
  ethnicity_lte?: Maybe<String>;
  ethnicity_gt?: Maybe<String>;
  ethnicity_gte?: Maybe<String>;
  ethnicity_contains?: Maybe<String>;
  ethnicity_not_contains?: Maybe<String>;
  ethnicity_starts_with?: Maybe<String>;
  ethnicity_not_starts_with?: Maybe<String>;
  ethnicity_ends_with?: Maybe<String>;
  ethnicity_not_ends_with?: Maybe<String>;
  users_every?: Maybe<UserWhereInput>;
  users_some?: Maybe<UserWhereInput>;
  users_none?: Maybe<UserWhereInput>;
  AND?: Maybe<EthnicityWhereInput[] | EthnicityWhereInput>;
  OR?: Maybe<EthnicityWhereInput[] | EthnicityWhereInput>;
  NOT?: Maybe<EthnicityWhereInput[] | EthnicityWhereInput>;
}

export interface UserRecordDataByDayScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  crampsLevel?: Maybe<Int>;
  crampsLevel_not?: Maybe<Int>;
  crampsLevel_in?: Maybe<Int[] | Int>;
  crampsLevel_not_in?: Maybe<Int[] | Int>;
  crampsLevel_lt?: Maybe<Int>;
  crampsLevel_lte?: Maybe<Int>;
  crampsLevel_gt?: Maybe<Int>;
  crampsLevel_gte?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
  recordDate_not?: Maybe<DateTimeInput>;
  recordDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  recordDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  recordDate_lt?: Maybe<DateTimeInput>;
  recordDate_lte?: Maybe<DateTimeInput>;
  recordDate_gt?: Maybe<DateTimeInput>;
  recordDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    UserRecordDataByDayScalarWhereInput[] | UserRecordDataByDayScalarWhereInput
  >;
  OR?: Maybe<
    UserRecordDataByDayScalarWhereInput[] | UserRecordDataByDayScalarWhereInput
  >;
  NOT?: Maybe<
    UserRecordDataByDayScalarWhereInput[] | UserRecordDataByDayScalarWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserRecordDataByDayUpdateManyWithWhereNestedInput {
  where: UserRecordDataByDayScalarWhereInput;
  data: UserRecordDataByDayUpdateManyDataInput;
}

export interface HardwareSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HardwareWhereInput>;
  AND?: Maybe<
    HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput
  >;
  OR?: Maybe<HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput>;
  NOT?: Maybe<
    HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput
  >;
}

export interface UserRecordDataByDayUpdateManyDataInput {
  crampsLevel?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
}

export interface CupDataColourCalibWhereInput {
  cup_data_colour_calib_id?: Maybe<Int>;
  cup_data_colour_calib_id_not?: Maybe<Int>;
  cup_data_colour_calib_id_in?: Maybe<Int[] | Int>;
  cup_data_colour_calib_id_not_in?: Maybe<Int[] | Int>;
  cup_data_colour_calib_id_lt?: Maybe<Int>;
  cup_data_colour_calib_id_lte?: Maybe<Int>;
  cup_data_colour_calib_id_gt?: Maybe<Int>;
  cup_data_colour_calib_id_gte?: Maybe<Int>;
  blue?: Maybe<Int>;
  blue_not?: Maybe<Int>;
  blue_in?: Maybe<Int[] | Int>;
  blue_not_in?: Maybe<Int[] | Int>;
  blue_lt?: Maybe<Int>;
  blue_lte?: Maybe<Int>;
  blue_gt?: Maybe<Int>;
  blue_gte?: Maybe<Int>;
  c?: Maybe<Int>;
  c_not?: Maybe<Int>;
  c_in?: Maybe<Int[] | Int>;
  c_not_in?: Maybe<Int[] | Int>;
  c_lt?: Maybe<Int>;
  c_lte?: Maybe<Int>;
  c_gt?: Maybe<Int>;
  c_gte?: Maybe<Int>;
  green?: Maybe<Int>;
  green_not?: Maybe<Int>;
  green_in?: Maybe<Int[] | Int>;
  green_not_in?: Maybe<Int[] | Int>;
  green_lt?: Maybe<Int>;
  green_lte?: Maybe<Int>;
  green_gt?: Maybe<Int>;
  green_gte?: Maybe<Int>;
  red?: Maybe<Int>;
  red_not?: Maybe<Int>;
  red_in?: Maybe<Int[] | Int>;
  red_not_in?: Maybe<Int[] | Int>;
  red_lt?: Maybe<Int>;
  red_lte?: Maybe<Int>;
  red_gt?: Maybe<Int>;
  red_gte?: Maybe<Int>;
  serialNumber?: Maybe<CupWhereInput>;
  AND?: Maybe<CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput>;
  OR?: Maybe<CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput>;
  NOT?: Maybe<CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput>;
}

export interface UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  update: UserRecordDataByPeriodUpdateWithoutUserDataInput;
  create: UserRecordDataByPeriodCreateWithoutUserInput;
}

export interface CupDataRejectionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataRejectionWhereInput>;
  AND?: Maybe<
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput
  >;
}

export interface UserRecordDataByPeriodScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  isTakePill?: Maybe<Boolean>;
  isTakePill_not?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensFinish_not?: Maybe<DateTimeInput>;
  mensFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensFinish_lt?: Maybe<DateTimeInput>;
  mensFinish_lte?: Maybe<DateTimeInput>;
  mensFinish_gt?: Maybe<DateTimeInput>;
  mensFinish_gte?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  mensStart_not?: Maybe<DateTimeInput>;
  mensStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mensStart_lt?: Maybe<DateTimeInput>;
  mensStart_lte?: Maybe<DateTimeInput>;
  mensStart_gt?: Maybe<DateTimeInput>;
  mensStart_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput
  >;
  OR?: Maybe<
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput
  >;
  NOT?: Maybe<
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput
  >;
}

export interface CupDataQuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataQuestionWhereInput>;
  AND?: Maybe<
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput
  >;
}

export interface UserRecordDataByPeriodUpdateManyWithWhereNestedInput {
  where: UserRecordDataByPeriodScalarWhereInput;
  data: UserRecordDataByPeriodUpdateManyDataInput;
}

export interface CupDataProcVolumeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataProcVolumeWhereInput>;
  AND?: Maybe<
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput
  >;
}

export interface UserRecordDataByPeriodUpdateManyDataInput {
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
}

export interface CupDataProcFlowSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataProcFlowWhereInput>;
  AND?: Maybe<
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput
  >;
}

export interface UserUpsertWithoutCupDataUserRemoveInput {
  update: UserUpdateWithoutCupDataUserRemoveDataInput;
  create: UserCreateWithoutCupDataUserRemoveInput;
}

export interface CupDataColourCalcSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataColourCalcWhereInput>;
  AND?: Maybe<
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput
  >;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutSerialNumberDataInput;
  create: CupDataUserRemoveCreateWithoutSerialNumberInput;
}

export interface CupDataUserRemoveWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  changeTime?: Maybe<DateTimeInput>;
  changeTime_not?: Maybe<DateTimeInput>;
  changeTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_lt?: Maybe<DateTimeInput>;
  changeTime_lte?: Maybe<DateTimeInput>;
  changeTime_gt?: Maybe<DateTimeInput>;
  changeTime_gte?: Maybe<DateTimeInput>;
  explain?: Maybe<CupDataUserRemoveExplainWhereInput>;
  serialNumber?: Maybe<CupWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput>;
  OR?: Maybe<CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput>;
  NOT?: Maybe<CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput>;
}

export interface CupDataUserRemoveScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  changeTime?: Maybe<DateTimeInput>;
  changeTime_not?: Maybe<DateTimeInput>;
  changeTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  changeTime_lt?: Maybe<DateTimeInput>;
  changeTime_lte?: Maybe<DateTimeInput>;
  changeTime_gt?: Maybe<DateTimeInput>;
  changeTime_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
  OR?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
}

export interface CupDataAnswerWhereInput {
  answer_id?: Maybe<Int>;
  answer_id_not?: Maybe<Int>;
  answer_id_in?: Maybe<Int[] | Int>;
  answer_id_not_in?: Maybe<Int[] | Int>;
  answer_id_lt?: Maybe<Int>;
  answer_id_lte?: Maybe<Int>;
  answer_id_gt?: Maybe<Int>;
  answer_id_gte?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerText_not?: Maybe<String>;
  answerText_in?: Maybe<String[] | String>;
  answerText_not_in?: Maybe<String[] | String>;
  answerText_lt?: Maybe<String>;
  answerText_lte?: Maybe<String>;
  answerText_gt?: Maybe<String>;
  answerText_gte?: Maybe<String>;
  answerText_contains?: Maybe<String>;
  answerText_not_contains?: Maybe<String>;
  answerText_starts_with?: Maybe<String>;
  answerText_not_starts_with?: Maybe<String>;
  answerText_ends_with?: Maybe<String>;
  answerText_not_ends_with?: Maybe<String>;
  cupDataQaResponse_every?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_some?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_none?: Maybe<CupDataQaResponseWhereInput>;
  question?: Maybe<CupDataQuestionWhereInput>;
  AND?: Maybe<CupDataAnswerWhereInput[] | CupDataAnswerWhereInput>;
  OR?: Maybe<CupDataAnswerWhereInput[] | CupDataAnswerWhereInput>;
  NOT?: Maybe<CupDataAnswerWhereInput[] | CupDataAnswerWhereInput>;
}

export interface CupDataUserRemoveUpdateManyWithWhereNestedInput {
  where: CupDataUserRemoveScalarWhereInput;
  data: CupDataUserRemoveUpdateManyDataInput;
}

export interface CupDataRejectionWhereInput {
  reject_id?: Maybe<Int>;
  reject_id_not?: Maybe<Int>;
  reject_id_in?: Maybe<Int[] | Int>;
  reject_id_not_in?: Maybe<Int[] | Int>;
  reject_id_lt?: Maybe<Int>;
  reject_id_lte?: Maybe<Int>;
  reject_id_gt?: Maybe<Int>;
  reject_id_gte?: Maybe<Int>;
  cupDataProcMdates_every?: Maybe<CupDataProcMdateWhereInput>;
  cupDataProcMdates_some?: Maybe<CupDataProcMdateWhereInput>;
  cupDataProcMdates_none?: Maybe<CupDataProcMdateWhereInput>;
  rejectionDescription?: Maybe<String>;
  rejectionDescription_not?: Maybe<String>;
  rejectionDescription_in?: Maybe<String[] | String>;
  rejectionDescription_not_in?: Maybe<String[] | String>;
  rejectionDescription_lt?: Maybe<String>;
  rejectionDescription_lte?: Maybe<String>;
  rejectionDescription_gt?: Maybe<String>;
  rejectionDescription_gte?: Maybe<String>;
  rejectionDescription_contains?: Maybe<String>;
  rejectionDescription_not_contains?: Maybe<String>;
  rejectionDescription_starts_with?: Maybe<String>;
  rejectionDescription_not_starts_with?: Maybe<String>;
  rejectionDescription_ends_with?: Maybe<String>;
  rejectionDescription_not_ends_with?: Maybe<String>;
  AND?: Maybe<CupDataRejectionWhereInput[] | CupDataRejectionWhereInput>;
  OR?: Maybe<CupDataRejectionWhereInput[] | CupDataRejectionWhereInput>;
  NOT?: Maybe<CupDataRejectionWhereInput[] | CupDataRejectionWhereInput>;
}

export interface CupDataUserRemoveUpdateManyDataInput {
  changeTime?: Maybe<DateTimeInput>;
}

export interface UsersDataAnalysisUpdateManyMutationInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface CupUpsertWithoutUserCupsInput {
  update: CupUpdateWithoutUserCupsDataInput;
  create: CupCreateWithoutUserCupsInput;
}

export interface UserRecordDataByTimeUpdateManyMutationInput {
  changeTime?: Maybe<DateTimeInput>;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserCupUpsertWithWhereUniqueWithoutUserInput {
  where: UserCupWhereUniqueInput;
  update: UserCupUpdateWithoutUserDataInput;
  create: UserCupCreateWithoutUserInput;
}

export interface CupDataManMdateWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  mdateRow?: Maybe<CupDataProcMdateWhereInput>;
  menFinish?: Maybe<DateTimeInput>;
  menFinish_not?: Maybe<DateTimeInput>;
  menFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_lt?: Maybe<DateTimeInput>;
  menFinish_lte?: Maybe<DateTimeInput>;
  menFinish_gt?: Maybe<DateTimeInput>;
  menFinish_gte?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  menStart_not?: Maybe<DateTimeInput>;
  menStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_lt?: Maybe<DateTimeInput>;
  menStart_lte?: Maybe<DateTimeInput>;
  menStart_gt?: Maybe<DateTimeInput>;
  menStart_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CupDataManMdateWhereInput[] | CupDataManMdateWhereInput>;
  OR?: Maybe<CupDataManMdateWhereInput[] | CupDataManMdateWhereInput>;
  NOT?: Maybe<CupDataManMdateWhereInput[] | CupDataManMdateWhereInput>;
}

export interface UserCupScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  AND?: Maybe<UserCupScalarWhereInput[] | UserCupScalarWhereInput>;
  OR?: Maybe<UserCupScalarWhereInput[] | UserCupScalarWhereInput>;
  NOT?: Maybe<UserCupScalarWhereInput[] | UserCupScalarWhereInput>;
}

export type CalibrationWhereUniqueInput = AtLeastOne<{
  calib_id: Maybe<Int>;
  calibVersion?: Maybe<String>;
}>;

export interface UserUpsertWithoutUserRecordDataByPeriodInput {
  update: UserUpdateWithoutUserRecordDataByPeriodDataInput;
  create: UserCreateWithoutUserRecordDataByPeriodInput;
}

export interface UserRecordDataByTimeCreateInput {
  changeTime: DateTimeInput;
  colorB?: Maybe<Int>;
  colorG?: Maybe<Int>;
  colorR?: Maybe<Int>;
  leakage?: Maybe<String>;
  recordDayRow?: Maybe<
    UserRecordDataByDayCreateOneWithoutUserRecordDataByTimeInput
  >;
  startTime?: Maybe<DateTimeInput>;
  volume?: Maybe<Float>;
}

export interface UserRecordDataByPeriodUpsertWithWhereUniqueWithoutCoinHistoryRowInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  update: UserRecordDataByPeriodUpdateWithoutCoinHistoryRowDataInput;
  create: UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput;
}

export interface UserRecordDataByPeriodUpdateInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryUpdateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneWithoutUserRecordDataByPeriodInput>;
  userRecordDataByDay?: Maybe<
    UserRecordDataByDayUpdateManyWithoutRecordPeriodRowInput
  >;
}

export interface UserCoinHistoryUpsertWithWhereUniqueWithoutUserInput {
  where: UserCoinHistoryWhereUniqueInput;
  update: UserCoinHistoryUpdateWithoutUserDataInput;
  create: UserCoinHistoryCreateWithoutUserInput;
}

export interface UserRecordDataByDayUpdateManyMutationInput {
  crampsLevel?: Maybe<Int>;
  recordDate?: Maybe<DateTimeInput>;
}

export interface UserCoinHistoryScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  category?: Maybe<String>;
  category_not?: Maybe<String>;
  category_in?: Maybe<String[] | String>;
  category_not_in?: Maybe<String[] | String>;
  category_lt?: Maybe<String>;
  category_lte?: Maybe<String>;
  category_gt?: Maybe<String>;
  category_gte?: Maybe<String>;
  category_contains?: Maybe<String>;
  category_not_contains?: Maybe<String>;
  category_starts_with?: Maybe<String>;
  category_not_starts_with?: Maybe<String>;
  category_ends_with?: Maybe<String>;
  category_not_ends_with?: Maybe<String>;
  coin?: Maybe<Int>;
  coin_not?: Maybe<Int>;
  coin_in?: Maybe<Int[] | Int>;
  coin_not_in?: Maybe<Int[] | Int>;
  coin_lt?: Maybe<Int>;
  coin_lte?: Maybe<Int>;
  coin_gt?: Maybe<Int>;
  coin_gte?: Maybe<Int>;
  contents?: Maybe<String>;
  contents_not?: Maybe<String>;
  contents_in?: Maybe<String[] | String>;
  contents_not_in?: Maybe<String[] | String>;
  contents_lt?: Maybe<String>;
  contents_lte?: Maybe<String>;
  contents_gt?: Maybe<String>;
  contents_gte?: Maybe<String>;
  contents_contains?: Maybe<String>;
  contents_not_contains?: Maybe<String>;
  contents_starts_with?: Maybe<String>;
  contents_not_starts_with?: Maybe<String>;
  contents_ends_with?: Maybe<String>;
  contents_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
  txhash_not?: Maybe<String>;
  txhash_in?: Maybe<String[] | String>;
  txhash_not_in?: Maybe<String[] | String>;
  txhash_lt?: Maybe<String>;
  txhash_lte?: Maybe<String>;
  txhash_gt?: Maybe<String>;
  txhash_gte?: Maybe<String>;
  txhash_contains?: Maybe<String>;
  txhash_not_contains?: Maybe<String>;
  txhash_starts_with?: Maybe<String>;
  txhash_not_starts_with?: Maybe<String>;
  txhash_ends_with?: Maybe<String>;
  txhash_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput
  >;
  OR?: Maybe<
    UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput
  >;
  NOT?: Maybe<
    UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput
  >;
}

export interface UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput {
  create?: Maybe<UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput>;
  update?: Maybe<
    UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput
  >;
  upsert?: Maybe<UserRecordDataByPeriodUpsertWithoutUserRecordDataByDayInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserRecordDataByPeriodWhereUniqueInput>;
}

export interface UserCoinHistoryUpdateManyWithWhereNestedInput {
  where: UserCoinHistoryScalarWhereInput;
  data: UserCoinHistoryUpdateManyDataInput;
}

export interface UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput {
  create?: Maybe<UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput>;
  connect?: Maybe<UserRecordDataByPeriodWhereUniqueInput>;
}

export interface UserCoinHistoryUpdateManyDataInput {
  category?: Maybe<String>;
  coin?: Maybe<Int>;
  contents?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
}

export interface UserInterviewQuestionUpdateInput {
  answerType?: Maybe<
    AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput
  >;
  question?: Maybe<String>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutQuestionInput>;
}

export interface UserUpsertWithoutUserCupsInput {
  update: UserUpdateWithoutUserCupsDataInput;
  create: UserCreateWithoutUserCupsInput;
}

export interface UserInterviewDatumUpdateInput {
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
  question?: Maybe<
    UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput
  >;
  user?: Maybe<UserUpdateOneRequiredWithoutUserInterviewDataInput>;
}

export interface UserCupUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: UserCupWhereUniqueInput;
  update: UserCupUpdateWithoutSerialNumberDataInput;
  create: UserCupCreateWithoutSerialNumberInput;
}

export interface UserCoinHistoryUpdateInput {
  category?: Maybe<String>;
  coin?: Maybe<Int>;
  contents?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
  user?: Maybe<UserUpdateOneWithoutUserCoinHistoryInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutCoinHistoryRowInput
  >;
}

export interface CupUpsertWithoutCupDataUserRemoveInput {
  update: CupUpdateWithoutCupDataUserRemoveDataInput;
  create: CupCreateWithoutCupDataUserRemoveInput;
}

export interface UserUpdateInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutUserInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutUserDataInput;
  create: CupDataUserRemoveCreateWithoutUserInput;
}

export interface PlatformCompUpdateInput {
  phoneId?: Maybe<Int>;
  platformId?: Maybe<Int>;
  problemHistory?: Maybe<Boolean>;
  softwareId?: Maybe<Int>;
  successHistory?: Maybe<Boolean>;
}

export interface UserUpsertWithoutCupDataProcFlowInput {
  update: UserUpdateWithoutCupDataProcFlowDataInput;
  create: UserCreateWithoutCupDataProcFlowInput;
}

export interface CupUpsertWithWhereUniqueWithoutHwInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutHwDataInput;
  create: CupCreateWithoutHwInput;
}

export interface CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowInput {
  where: CupDataProcFlowWhereUniqueInput;
  update: CupDataProcFlowUpdateWithoutMdateRowDataInput;
  create: CupDataProcFlowCreateWithoutMdateRowInput;
}

export interface CupUpdateManyWithoutHwInput {
  create?: Maybe<CupCreateWithoutHwInput[] | CupCreateWithoutHwInput>;
  delete?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  set?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  disconnect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  update?: Maybe<
    | CupUpdateWithWhereUniqueWithoutHwInput[]
    | CupUpdateWithWhereUniqueWithoutHwInput
  >;
  upsert?: Maybe<
    | CupUpsertWithWhereUniqueWithoutHwInput[]
    | CupUpsertWithWhereUniqueWithoutHwInput
  >;
  deleteMany?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  updateMany?: Maybe<
    CupUpdateManyWithWhereNestedInput[] | CupUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataProcFlowScalarWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
  hourlyFlow_not?: Maybe<Int>;
  hourlyFlow_in?: Maybe<Int[] | Int>;
  hourlyFlow_not_in?: Maybe<Int[] | Int>;
  hourlyFlow_lt?: Maybe<Int>;
  hourlyFlow_lte?: Maybe<Int>;
  hourlyFlow_gt?: Maybe<Int>;
  hourlyFlow_gte?: Maybe<Int>;
  AND?: Maybe<
    CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput
  >;
  OR?: Maybe<
    CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput
  >;
}

export interface CupCreateManyWithoutHwInput {
  create?: Maybe<CupCreateWithoutHwInput[] | CupCreateWithoutHwInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
}

export interface CupDataProcFlowUpdateManyWithWhereNestedInput {
  where: CupDataProcFlowScalarWhereInput;
  data: CupDataProcFlowUpdateManyDataInput;
}

export interface AppServerSyncWhereInput {
  app_server_sync_id?: Maybe<Int>;
  app_server_sync_id_not?: Maybe<Int>;
  app_server_sync_id_in?: Maybe<Int[] | Int>;
  app_server_sync_id_not_in?: Maybe<Int[] | Int>;
  app_server_sync_id_lt?: Maybe<Int>;
  app_server_sync_id_lte?: Maybe<Int>;
  app_server_sync_id_gt?: Maybe<Int>;
  app_server_sync_id_gte?: Maybe<Int>;
  serverSynchTime?: Maybe<DateTimeInput>;
  serverSynchTime_not?: Maybe<DateTimeInput>;
  serverSynchTime_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  serverSynchTime_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  serverSynchTime_lt?: Maybe<DateTimeInput>;
  serverSynchTime_lte?: Maybe<DateTimeInput>;
  serverSynchTime_gt?: Maybe<DateTimeInput>;
  serverSynchTime_gte?: Maybe<DateTimeInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<AppServerSyncWhereInput[] | AppServerSyncWhereInput>;
  OR?: Maybe<AppServerSyncWhereInput[] | AppServerSyncWhereInput>;
  NOT?: Maybe<AppServerSyncWhereInput[] | AppServerSyncWhereInput>;
}

export interface CupDataProcFlowUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
}

export type CupDataRawWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataProcMdateUpsertWithWhereUniqueWithoutUserInput {
  where: CupDataProcMdateWhereUniqueInput;
  update: CupDataProcMdateUpdateWithoutUserDataInput;
  create: CupDataProcMdateCreateWithoutUserInput;
}

export type CupDataRejectionWhereUniqueInput = AtLeastOne<{
  reject_id: Maybe<Int>;
  rejectionDescription?: Maybe<String>;
}>;

export interface CupDataProcMdateScalarWhereInput {
  mdate_row_id?: Maybe<Int>;
  mdate_row_id_not?: Maybe<Int>;
  mdate_row_id_in?: Maybe<Int[] | Int>;
  mdate_row_id_not_in?: Maybe<Int[] | Int>;
  mdate_row_id_lt?: Maybe<Int>;
  mdate_row_id_lte?: Maybe<Int>;
  mdate_row_id_gt?: Maybe<Int>;
  mdate_row_id_gte?: Maybe<Int>;
  dataRejected?: Maybe<Boolean>;
  dataRejected_not?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  dataVerified_not?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menFinish_not?: Maybe<DateTimeInput>;
  menFinish_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menFinish_lt?: Maybe<DateTimeInput>;
  menFinish_lte?: Maybe<DateTimeInput>;
  menFinish_gt?: Maybe<DateTimeInput>;
  menFinish_gte?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  menStart_not?: Maybe<DateTimeInput>;
  menStart_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  menStart_lt?: Maybe<DateTimeInput>;
  menStart_lte?: Maybe<DateTimeInput>;
  menStart_gt?: Maybe<DateTimeInput>;
  menStart_gte?: Maybe<DateTimeInput>;
  rewardAmount?: Maybe<Int>;
  rewardAmount_not?: Maybe<Int>;
  rewardAmount_in?: Maybe<Int[] | Int>;
  rewardAmount_not_in?: Maybe<Int[] | Int>;
  rewardAmount_lt?: Maybe<Int>;
  rewardAmount_lte?: Maybe<Int>;
  rewardAmount_gt?: Maybe<Int>;
  rewardAmount_gte?: Maybe<Int>;
  AND?: Maybe<
    CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput
  >;
  OR?: Maybe<
    CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput
  >;
}

export interface EthnicityUpdateManyMutationInput {
  ethnicity?: Maybe<String>;
}

export interface CupDataProcMdateUpdateManyWithWhereNestedInput {
  where: CupDataProcMdateScalarWhereInput;
  data: CupDataProcMdateUpdateManyDataInput;
}

export interface UserUpdateWithWhereUniqueWithoutEthnicityInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutEthnicityDataInput;
}

export interface CupDataProcMdateUpdateManyDataInput {
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  rewardAmount?: Maybe<Int>;
}

export interface UserCreateWithoutEthnicityInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface UserUpsertWithoutCupDataQaResponseInput {
  update: UserUpdateWithoutCupDataQaResponseDataInput;
  create: UserCreateWithoutCupDataQaResponseInput;
}

export interface CupDatumUpdateManyMutationInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutQuestionDataInput;
  create: CupDataQaResponseCreateWithoutQuestionInput;
}

export interface CupDataUserRemoveExplainUpdateManyMutationInput {
  explain?: Maybe<String>;
}

export interface CupDataQaResponseScalarWhereInput {
  cup_data_qa_response_id?: Maybe<Int>;
  cup_data_qa_response_id_not?: Maybe<Int>;
  cup_data_qa_response_id_in?: Maybe<Int[] | Int>;
  cup_data_qa_response_id_not_in?: Maybe<Int[] | Int>;
  cup_data_qa_response_id_lt?: Maybe<Int>;
  cup_data_qa_response_id_lte?: Maybe<Int>;
  cup_data_qa_response_id_gt?: Maybe<Int>;
  cup_data_qa_response_id_gte?: Maybe<Int>;
  qaDate?: Maybe<DateTimeInput>;
  qaDate_not?: Maybe<DateTimeInput>;
  qaDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  qaDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  qaDate_lt?: Maybe<DateTimeInput>;
  qaDate_lte?: Maybe<DateTimeInput>;
  qaDate_gt?: Maybe<DateTimeInput>;
  qaDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
  OR?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
  NOT?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
}

export interface UserInterviewDatumWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  answerRange?: Maybe<Int>;
  answerRange_not?: Maybe<Int>;
  answerRange_in?: Maybe<Int[] | Int>;
  answerRange_not_in?: Maybe<Int[] | Int>;
  answerRange_lt?: Maybe<Int>;
  answerRange_lte?: Maybe<Int>;
  answerRange_gt?: Maybe<Int>;
  answerRange_gte?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerText_not?: Maybe<String>;
  answerText_in?: Maybe<String[] | String>;
  answerText_not_in?: Maybe<String[] | String>;
  answerText_lt?: Maybe<String>;
  answerText_lte?: Maybe<String>;
  answerText_gt?: Maybe<String>;
  answerText_gte?: Maybe<String>;
  answerText_contains?: Maybe<String>;
  answerText_not_contains?: Maybe<String>;
  answerText_starts_with?: Maybe<String>;
  answerText_not_starts_with?: Maybe<String>;
  answerText_ends_with?: Maybe<String>;
  answerText_not_ends_with?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  answerYn_not?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  question?: Maybe<UserInterviewQuestionWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput>;
  OR?: Maybe<UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput>;
  NOT?: Maybe<UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput>;
}

export interface CupDataQaResponseUpdateManyWithWhereNestedInput {
  where: CupDataQaResponseScalarWhereInput;
  data: CupDataQaResponseUpdateManyDataInput;
}

export type HardwareWhereUniqueInput = AtLeastOne<{
  hw_id: Maybe<Int>;
  hwVersion?: Maybe<String>;
}>;

export interface CupDataQaResponseUpdateManyDataInput {
  qaDate?: Maybe<DateTimeInput>;
}

export interface CupDataUserRemoveExplainCreateInput {
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutExplainInput>;
  explain: String;
}

export interface CupDataQuestionUpsertWithoutCupDataAnswerInput {
  update: CupDataQuestionUpdateWithoutCupDataAnswerDataInput;
  create: CupDataQuestionCreateWithoutCupDataAnswerInput;
}

export interface UserInterviewQuestionWhereInput {
  question_id?: Maybe<Int>;
  question_id_not?: Maybe<Int>;
  question_id_in?: Maybe<Int[] | Int>;
  question_id_not_in?: Maybe<Int[] | Int>;
  question_id_lt?: Maybe<Int>;
  question_id_lte?: Maybe<Int>;
  question_id_gt?: Maybe<Int>;
  question_id_gte?: Maybe<Int>;
  answerType?: Maybe<AnswerTypeWhereInput>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  userInterviewData_every?: Maybe<UserInterviewDatumWhereInput>;
  userInterviewData_some?: Maybe<UserInterviewDatumWhereInput>;
  userInterviewData_none?: Maybe<UserInterviewDatumWhereInput>;
  AND?: Maybe<
    UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput
  >;
  OR?: Maybe<
    UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput
  >;
  NOT?: Maybe<
    UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput
  >;
}

export interface CupDataAnswerUpsertWithoutCupDataQaResponseInput {
  update: CupDataAnswerUpdateWithoutCupDataQaResponseDataInput;
  create: CupDataAnswerCreateWithoutCupDataQaResponseInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  user_id: Maybe<Int>;
  anonUserId?: Maybe<Int>;
  email?: Maybe<String>;
}>;

export interface CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: Maybe<CupDataQuestionCreateWithoutCupDataQaResponseInput>;
  update?: Maybe<CupDataQuestionUpdateWithoutCupDataQaResponseDataInput>;
  upsert?: Maybe<CupDataQuestionUpsertWithoutCupDataQaResponseInput>;
  connect?: Maybe<CupDataQuestionWhereUniqueInput>;
}

export type UserCoinHistoryWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataQuestionUpdateWithoutCupDataQaResponseDataInput {
  cupDataAnswer?: Maybe<CupDataAnswerUpdateManyWithoutQuestionInput>;
  questionText?: Maybe<String>;
}

export type UserInterviewDatumWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataAnswerUpdateManyWithoutQuestionInput {
  create?: Maybe<
    | CupDataAnswerCreateWithoutQuestionInput[]
    | CupDataAnswerCreateWithoutQuestionInput
  >;
  delete?: Maybe<
    CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput
  >;
  set?: Maybe<CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput>;
  disconnect?: Maybe<
    CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    | CupDataAnswerUpdateWithWhereUniqueWithoutQuestionInput
  >;
  upsert?: Maybe<
    | CupDataAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    | CupDataAnswerUpsertWithWhereUniqueWithoutQuestionInput
  >;
  deleteMany?: Maybe<
    CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataAnswerUpdateManyWithWhereNestedInput[]
    | CupDataAnswerUpdateManyWithWhereNestedInput
  >;
}

export type UserInterviewQuestionWhereUniqueInput = AtLeastOne<{
  question_id: Maybe<Int>;
  question?: Maybe<String>;
}>;

export interface CupDataAnswerUpdateWithWhereUniqueWithoutQuestionInput {
  where: CupDataAnswerWhereUniqueInput;
  data: CupDataAnswerUpdateWithoutQuestionDataInput;
}

export type UserRecordDataByDayWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataAnswerUpdateWithoutQuestionDataInput {
  answerText?: Maybe<String>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutAnswerInput>;
}

export type UserRecordDataByPeriodWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataQaResponseUpdateManyWithoutAnswerInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutAnswerInput[]
    | CupDataQaResponseCreateWithoutAnswerInput
  >;
  delete?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  set?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerInput
  >;
  upsert?: Maybe<
    | CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerInput
  >;
  deleteMany?: Maybe<
    CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput
  >;
}

export type UserRecordDataByTimeWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutAnswerDataInput;
}

export type UsersDataAnalysisWhereUniqueInput = AtLeastOne<{
  idx: Maybe<Int>;
}>;

export interface CupDataQaResponseUpdateWithoutAnswerDataInput {
  qaDate?: Maybe<DateTimeInput>;
  question?: Maybe<
    CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput
  >;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataQaResponseInput>;
}

export interface CupDatumUpsertWithoutCupDataProcVolumeInput {
  update: CupDatumUpdateWithoutCupDataProcVolumeDataInput;
  create: CupDatumCreateWithoutCupDataProcVolumeInput;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutAnswerDataInput;
  create: CupDataQaResponseCreateWithoutAnswerInput;
}

export interface UserInterviewDatumCreateManyWithoutQuestionInput {
  create?: Maybe<
    | UserInterviewDatumCreateWithoutQuestionInput[]
    | UserInterviewDatumCreateWithoutQuestionInput
  >;
  connect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
}

export interface CupDataAnswerUpsertWithWhereUniqueWithoutQuestionInput {
  where: CupDataAnswerWhereUniqueInput;
  update: CupDataAnswerUpdateWithoutQuestionDataInput;
  create: CupDataAnswerCreateWithoutQuestionInput;
}

export interface AppServerSyncCreateManyWithoutUserInput {
  create?: Maybe<
    AppServerSyncCreateWithoutUserInput[] | AppServerSyncCreateWithoutUserInput
  >;
  connect?: Maybe<
    AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput
  >;
}

export interface CupDataAnswerScalarWhereInput {
  answer_id?: Maybe<Int>;
  answer_id_not?: Maybe<Int>;
  answer_id_in?: Maybe<Int[] | Int>;
  answer_id_not_in?: Maybe<Int[] | Int>;
  answer_id_lt?: Maybe<Int>;
  answer_id_lte?: Maybe<Int>;
  answer_id_gt?: Maybe<Int>;
  answer_id_gte?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerText_not?: Maybe<String>;
  answerText_in?: Maybe<String[] | String>;
  answerText_not_in?: Maybe<String[] | String>;
  answerText_lt?: Maybe<String>;
  answerText_lte?: Maybe<String>;
  answerText_gt?: Maybe<String>;
  answerText_gte?: Maybe<String>;
  answerText_contains?: Maybe<String>;
  answerText_not_contains?: Maybe<String>;
  answerText_starts_with?: Maybe<String>;
  answerText_not_starts_with?: Maybe<String>;
  answerText_ends_with?: Maybe<String>;
  answerText_not_ends_with?: Maybe<String>;
  AND?: Maybe<CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput>;
  OR?: Maybe<CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput>;
  NOT?: Maybe<CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput>;
}

export interface CupDataProcFlowCreateManyWithoutUserInput {
  create?: Maybe<
    | CupDataProcFlowCreateWithoutUserInput[]
    | CupDataProcFlowCreateWithoutUserInput
  >;
  connect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
}

export interface CupDataAnswerUpdateManyWithWhereNestedInput {
  where: CupDataAnswerScalarWhereInput;
  data: CupDataAnswerUpdateManyDataInput;
}

export interface CupDataManMdateCreateManyWithoutMdateRowInput {
  create?: Maybe<
    | CupDataManMdateCreateWithoutMdateRowInput[]
    | CupDataManMdateCreateWithoutMdateRowInput
  >;
  connect?: Maybe<
    CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput
  >;
}

export interface CupDataAnswerUpdateManyDataInput {
  answerText?: Maybe<String>;
}

export interface UserCreateOneWithoutCupDataProcMdatesInput {
  create?: Maybe<UserCreateWithoutCupDataProcMdatesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataQuestionUpsertWithoutCupDataQaResponseInput {
  update: CupDataQuestionUpdateWithoutCupDataQaResponseDataInput;
  create: CupDataQuestionCreateWithoutCupDataQaResponseInput;
}

export interface CupDataAnswerCreateOneWithoutCupDataQaResponseInput {
  create?: Maybe<CupDataAnswerCreateWithoutCupDataQaResponseInput>;
  connect?: Maybe<CupDataAnswerWhereUniqueInput>;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutUserInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutUserDataInput;
  create: CupDataQaResponseCreateWithoutUserInput;
}

export interface CupDataQaResponseCreateManyWithoutQuestionInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutQuestionInput[]
    | CupDataQaResponseCreateWithoutQuestionInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
}

export interface UserUpsertWithoutCupDataProcMdatesInput {
  update: UserUpdateWithoutCupDataProcMdatesDataInput;
  create: UserCreateWithoutCupDataProcMdatesInput;
}

export interface CupDataProcMdateCreateManyWithoutUserInput {
  create?: Maybe<
    | CupDataProcMdateCreateWithoutUserInput[]
    | CupDataProcMdateCreateWithoutUserInput
  >;
  connect?: Maybe<
    CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput
  >;
}

export interface CupDataProcMdateUpsertWithoutCupDataProcFlowInput {
  update: CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput;
  create: CupDataProcMdateCreateWithoutCupDataProcFlowInput;
}

export interface UserCreateOneWithoutCupDataProcFlowInput {
  create?: Maybe<UserCreateWithoutCupDataProcFlowInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataProcFlowUpsertWithWhereUniqueWithoutUserInput {
  where: CupDataProcFlowWhereUniqueInput;
  update: CupDataProcFlowUpdateWithoutUserDataInput;
  create: CupDataProcFlowCreateWithoutUserInput;
}

export interface CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput {
  create?: Maybe<CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput>;
  connect?: Maybe<CupDataUserRemoveExplainWhereUniqueInput>;
}

export interface UserUpsertWithoutUserInterviewDataInput {
  update: UserUpdateWithoutUserInterviewDataDataInput;
  create: UserCreateWithoutUserInterviewDataInput;
}

export interface CalibrationCreateOneWithoutCupInput {
  create?: Maybe<CalibrationCreateWithoutCupInput>;
  connect?: Maybe<CalibrationWhereUniqueInput>;
}

export interface UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionInput {
  where: UserInterviewDatumWhereUniqueInput;
  update: UserInterviewDatumUpdateWithoutQuestionDataInput;
  create: UserInterviewDatumCreateWithoutQuestionInput;
}

export interface CupAppSyncCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupAppSyncCreateWithoutSerialNumberInput[]
    | CupAppSyncCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput>;
}

export interface UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeInput {
  where: UserInterviewQuestionWhereUniqueInput;
  update: UserInterviewQuestionUpdateWithoutAnswerTypeDataInput;
  create: UserInterviewQuestionCreateWithoutAnswerTypeInput;
}

export interface CupDataColourCalcCreateManyWithoutCupDataRowInput {
  create?: Maybe<
    | CupDataColourCalcCreateWithoutCupDataRowInput[]
    | CupDataColourCalcCreateWithoutCupDataRowInput
  >;
  connect?: Maybe<
    CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput
  >;
}

export interface UserInterviewQuestionScalarWhereInput {
  question_id?: Maybe<Int>;
  question_id_not?: Maybe<Int>;
  question_id_in?: Maybe<Int[] | Int>;
  question_id_not_in?: Maybe<Int[] | Int>;
  question_id_lt?: Maybe<Int>;
  question_id_lte?: Maybe<Int>;
  question_id_gt?: Maybe<Int>;
  question_id_gte?: Maybe<Int>;
  question?: Maybe<String>;
  question_not?: Maybe<String>;
  question_in?: Maybe<String[] | String>;
  question_not_in?: Maybe<String[] | String>;
  question_lt?: Maybe<String>;
  question_lte?: Maybe<String>;
  question_gt?: Maybe<String>;
  question_gte?: Maybe<String>;
  question_contains?: Maybe<String>;
  question_not_contains?: Maybe<String>;
  question_starts_with?: Maybe<String>;
  question_not_starts_with?: Maybe<String>;
  question_ends_with?: Maybe<String>;
  question_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput
  >;
  OR?: Maybe<
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput
  >;
  NOT?: Maybe<
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput
  >;
}

export interface CupDataColourCalibCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataColourCalibCreateWithoutSerialNumberInput[]
    | CupDataColourCalibCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<
    CupDataColourCalibWhereUniqueInput[] | CupDataColourCalibWhereUniqueInput
  >;
}

export interface UserInterviewQuestionUpdateManyWithWhereNestedInput {
  where: UserInterviewQuestionScalarWhereInput;
  data: UserInterviewQuestionUpdateManyDataInput;
}

export interface FirmwareCreateOneWithoutCupInput {
  create?: Maybe<FirmwareCreateWithoutCupInput>;
  connect?: Maybe<FirmwareWhereUniqueInput>;
}

export interface UserInterviewQuestionUpdateManyDataInput {
  question?: Maybe<String>;
}

export interface UserCupCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | UserCupCreateWithoutSerialNumberInput[]
    | UserCupCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
}

export interface AnswerTypeUpdateManyMutationInput {
  answerType?: Maybe<String>;
}

export interface EthnicityCreateOneWithoutUsersInput {
  create?: Maybe<EthnicityCreateWithoutUsersInput>;
  connect?: Maybe<EthnicityWhereUniqueInput>;
}

export interface CupDatumCreateOneWithoutCupDataProcVolumeInput {
  create?: Maybe<CupDatumCreateWithoutCupDataProcVolumeInput>;
  connect?: Maybe<CupDatumWhereUniqueInput>;
}

export interface UserRecordDataByPeriodCreateManyWithoutCoinHistoryRowInput {
  create?: Maybe<
    | UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput[]
    | UserRecordDataByPeriodCreateWithoutCoinHistoryRowInput
  >;
  connect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
}

export interface CupDataProcVolumeCreateInput {
  row_id?: Maybe<Int>;
  confidenceL?: Maybe<Int>;
  confidenceR?: Maybe<Int>;
  cupDataRow: CupDatumCreateOneWithoutCupDataProcVolumeInput;
  inVitro?: Maybe<Boolean>;
  volume?: Maybe<Int>;
  volumeAdj?: Maybe<Int>;
  volumeL?: Maybe<Int>;
  volumeR?: Maybe<Int>;
}

export interface UserCupCreateManyWithoutUserInput {
  create?: Maybe<
    UserCupCreateWithoutUserInput[] | UserCupCreateWithoutUserInput
  >;
  connect?: Maybe<UserCupWhereUniqueInput[] | UserCupWhereUniqueInput>;
}

export interface AppServerSyncCreateInput {
  serverSynchTime: DateTimeInput;
  user: UserCreateOneWithoutAppServerSyncInput;
}

export interface CupDataUserRemoveCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutSerialNumberInput[]
    | CupDataUserRemoveCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
}

export interface UserCreateOneWithoutAppServerSyncInput {
  create?: Maybe<UserCreateWithoutAppServerSyncInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserInterviewDatumCreateManyWithoutUserInput {
  create?: Maybe<
    | UserInterviewDatumCreateWithoutUserInput[]
    | UserInterviewDatumCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserInterviewDatumWhereUniqueInput[] | UserInterviewDatumWhereUniqueInput
  >;
}

export interface UserCreateWithoutAppServerSyncInput {
  anonUserId?: Maybe<Int>;
  country?: Maybe<CountryCreateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface AnswerTypeCreateOneWithoutUserInterviewQuestionsInput {
  create?: Maybe<AnswerTypeCreateWithoutUserInterviewQuestionsInput>;
  connect?: Maybe<AnswerTypeWhereUniqueInput>;
}

export interface AppServerSyncUpdateInput {
  serverSynchTime?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutAppServerSyncInput>;
}

export interface UserCoinHistoryCreateOneWithoutUserRecordDataByPeriodInput {
  create?: Maybe<UserCoinHistoryCreateWithoutUserRecordDataByPeriodInput>;
  connect?: Maybe<UserCoinHistoryWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutAppServerSyncInput {
  create?: Maybe<UserCreateWithoutAppServerSyncInput>;
  update?: Maybe<UserUpdateWithoutAppServerSyncDataInput>;
  upsert?: Maybe<UserUpsertWithoutAppServerSyncInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserRecordDataByDayCreateManyWithoutRecordPeriodRowInput {
  create?: Maybe<
    | UserRecordDataByDayCreateWithoutRecordPeriodRowInput[]
    | UserRecordDataByDayCreateWithoutRecordPeriodRowInput
  >;
  connect?: Maybe<
    UserRecordDataByDayWhereUniqueInput[] | UserRecordDataByDayWhereUniqueInput
  >;
}

export interface UserUpdateWithoutAppServerSyncDataInput {
  anonUserId?: Maybe<Int>;
  country?: Maybe<CountryUpdateOneWithoutUsersInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export type UserCupWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface UserUpsertWithoutAppServerSyncInput {
  update: UserUpdateWithoutAppServerSyncDataInput;
  create: UserCreateWithoutAppServerSyncInput;
}

export interface CupDataAnswerCreateWithoutQuestionInput {
  answerText: String;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutAnswerInput>;
}

export interface AppServerSyncUpdateManyMutationInput {
  serverSynchTime?: Maybe<DateTimeInput>;
}

export interface UserInterviewQuestionUpdateManyWithoutAnswerTypeInput {
  create?: Maybe<
    | UserInterviewQuestionCreateWithoutAnswerTypeInput[]
    | UserInterviewQuestionCreateWithoutAnswerTypeInput
  >;
  delete?: Maybe<
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput
  >;
  connect?: Maybe<
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput
  >;
  set?: Maybe<
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput
  >;
  disconnect?: Maybe<
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput
  >;
  update?: Maybe<
    | UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeInput[]
    | UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeInput
  >;
  upsert?: Maybe<
    | UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeInput[]
    | UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeInput
  >;
  deleteMany?: Maybe<
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput
  >;
  updateMany?: Maybe<
    | UserInterviewQuestionUpdateManyWithWhereNestedInput[]
    | UserInterviewQuestionUpdateManyWithWhereNestedInput
  >;
}

export interface AuthTokenCreateInput {
  user_id?: Maybe<Int>;
}

export interface UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionInput {
  where: UserInterviewDatumWhereUniqueInput;
  data: UserInterviewDatumUpdateWithoutQuestionDataInput;
}

export interface CalibrationCreateInput {
  calibVersion: String;
  cup?: Maybe<CupCreateManyWithoutCalibInput>;
}

export interface AppServerSyncUpdateManyWithoutUserInput {
  create?: Maybe<
    AppServerSyncCreateWithoutUserInput[] | AppServerSyncCreateWithoutUserInput
  >;
  delete?: Maybe<
    AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput
  >;
  connect?: Maybe<
    AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput
  >;
  set?: Maybe<AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput>;
  disconnect?: Maybe<
    AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput
  >;
  update?: Maybe<
    | AppServerSyncUpdateWithWhereUniqueWithoutUserInput[]
    | AppServerSyncUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | AppServerSyncUpsertWithWhereUniqueWithoutUserInput[]
    | AppServerSyncUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput
  >;
  updateMany?: Maybe<
    | AppServerSyncUpdateManyWithWhereNestedInput[]
    | AppServerSyncUpdateManyWithWhereNestedInput
  >;
}

export interface CupCreateManyWithoutCalibInput {
  create?: Maybe<CupCreateWithoutCalibInput[] | CupCreateWithoutCalibInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
}

export interface UserInterviewQuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserInterviewQuestionWhereInput>;
  AND?: Maybe<
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput
  >;
}

export interface CupCreateWithoutCalibInput {
  anonSerialNumber: Int;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface HardwareWhereInput {
  hw_id?: Maybe<Int>;
  hw_id_not?: Maybe<Int>;
  hw_id_in?: Maybe<Int[] | Int>;
  hw_id_not_in?: Maybe<Int[] | Int>;
  hw_id_lt?: Maybe<Int>;
  hw_id_lte?: Maybe<Int>;
  hw_id_gt?: Maybe<Int>;
  hw_id_gte?: Maybe<Int>;
  cup_every?: Maybe<CupWhereInput>;
  cup_some?: Maybe<CupWhereInput>;
  cup_none?: Maybe<CupWhereInput>;
  hwVersion?: Maybe<String>;
  hwVersion_not?: Maybe<String>;
  hwVersion_in?: Maybe<String[] | String>;
  hwVersion_not_in?: Maybe<String[] | String>;
  hwVersion_lt?: Maybe<String>;
  hwVersion_lte?: Maybe<String>;
  hwVersion_gt?: Maybe<String>;
  hwVersion_gte?: Maybe<String>;
  hwVersion_contains?: Maybe<String>;
  hwVersion_not_contains?: Maybe<String>;
  hwVersion_starts_with?: Maybe<String>;
  hwVersion_not_starts_with?: Maybe<String>;
  hwVersion_ends_with?: Maybe<String>;
  hwVersion_not_ends_with?: Maybe<String>;
  AND?: Maybe<HardwareWhereInput[] | HardwareWhereInput>;
  OR?: Maybe<HardwareWhereInput[] | HardwareWhereInput>;
  NOT?: Maybe<HardwareWhereInput[] | HardwareWhereInput>;
}

export interface CalibrationUpdateInput {
  calibVersion?: Maybe<String>;
  cup?: Maybe<CupUpdateManyWithoutCalibInput>;
}

export interface CupDataUserRemoveExplainSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataUserRemoveExplainWhereInput>;
  AND?: Maybe<
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput
  >;
}

export interface CupUpdateManyWithoutCalibInput {
  create?: Maybe<CupCreateWithoutCalibInput[] | CupCreateWithoutCalibInput>;
  delete?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  set?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  disconnect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  update?: Maybe<
    | CupUpdateWithWhereUniqueWithoutCalibInput[]
    | CupUpdateWithWhereUniqueWithoutCalibInput
  >;
  upsert?: Maybe<
    | CupUpsertWithWhereUniqueWithoutCalibInput[]
    | CupUpsertWithWhereUniqueWithoutCalibInput
  >;
  deleteMany?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  updateMany?: Maybe<
    CupUpdateManyWithWhereNestedInput[] | CupUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataQaResponseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataQaResponseWhereInput>;
  AND?: Maybe<
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput
  >;
}

export interface CupUpdateWithWhereUniqueWithoutCalibInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutCalibDataInput;
}

export interface CupDataManMdateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataManMdateWhereInput>;
  AND?: Maybe<
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput
  >;
}

export interface CupUpdateWithoutCalibDataInput {
  anonSerialNumber?: Maybe<Int>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface CupDataQuestionWhereInput {
  question_id?: Maybe<Int>;
  question_id_not?: Maybe<Int>;
  question_id_in?: Maybe<Int[] | Int>;
  question_id_not_in?: Maybe<Int[] | Int>;
  question_id_lt?: Maybe<Int>;
  question_id_lte?: Maybe<Int>;
  question_id_gt?: Maybe<Int>;
  question_id_gte?: Maybe<Int>;
  cupDataAnswer_every?: Maybe<CupDataAnswerWhereInput>;
  cupDataAnswer_some?: Maybe<CupDataAnswerWhereInput>;
  cupDataAnswer_none?: Maybe<CupDataAnswerWhereInput>;
  cupDataQaResponse_every?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_some?: Maybe<CupDataQaResponseWhereInput>;
  cupDataQaResponse_none?: Maybe<CupDataQaResponseWhereInput>;
  questionText?: Maybe<String>;
  questionText_not?: Maybe<String>;
  questionText_in?: Maybe<String[] | String>;
  questionText_not_in?: Maybe<String[] | String>;
  questionText_lt?: Maybe<String>;
  questionText_lte?: Maybe<String>;
  questionText_gt?: Maybe<String>;
  questionText_gte?: Maybe<String>;
  questionText_contains?: Maybe<String>;
  questionText_not_contains?: Maybe<String>;
  questionText_starts_with?: Maybe<String>;
  questionText_not_starts_with?: Maybe<String>;
  questionText_ends_with?: Maybe<String>;
  questionText_not_ends_with?: Maybe<String>;
  AND?: Maybe<CupDataQuestionWhereInput[] | CupDataQuestionWhereInput>;
  OR?: Maybe<CupDataQuestionWhereInput[] | CupDataQuestionWhereInput>;
  NOT?: Maybe<CupDataQuestionWhereInput[] | CupDataQuestionWhereInput>;
}

export interface CupUpsertWithWhereUniqueWithoutCalibInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutCalibDataInput;
  create: CupCreateWithoutCalibInput;
}

export interface AppServerSyncSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppServerSyncWhereInput>;
  AND?: Maybe<
    AppServerSyncSubscriptionWhereInput[] | AppServerSyncSubscriptionWhereInput
  >;
  OR?: Maybe<
    AppServerSyncSubscriptionWhereInput[] | AppServerSyncSubscriptionWhereInput
  >;
  NOT?: Maybe<
    AppServerSyncSubscriptionWhereInput[] | AppServerSyncSubscriptionWhereInput
  >;
}

export interface CupScalarWhereInput {
  serial_number?: Maybe<Int>;
  serial_number_not?: Maybe<Int>;
  serial_number_in?: Maybe<Int[] | Int>;
  serial_number_not_in?: Maybe<Int[] | Int>;
  serial_number_lt?: Maybe<Int>;
  serial_number_lte?: Maybe<Int>;
  serial_number_gt?: Maybe<Int>;
  serial_number_gte?: Maybe<Int>;
  anonSerialNumber?: Maybe<Int>;
  anonSerialNumber_not?: Maybe<Int>;
  anonSerialNumber_in?: Maybe<Int[] | Int>;
  anonSerialNumber_not_in?: Maybe<Int[] | Int>;
  anonSerialNumber_lt?: Maybe<Int>;
  anonSerialNumber_lte?: Maybe<Int>;
  anonSerialNumber_gt?: Maybe<Int>;
  anonSerialNumber_gte?: Maybe<Int>;
  encryptionKey?: Maybe<Int>;
  encryptionKey_not?: Maybe<Int>;
  encryptionKey_in?: Maybe<Int[] | Int>;
  encryptionKey_not_in?: Maybe<Int[] | Int>;
  encryptionKey_lt?: Maybe<Int>;
  encryptionKey_lte?: Maybe<Int>;
  encryptionKey_gt?: Maybe<Int>;
  encryptionKey_gte?: Maybe<Int>;
  AND?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  OR?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  NOT?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
}

export interface UserRecordDataByDayUpsertWithoutUserRecordDataByTimeInput {
  update: UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput;
  create: UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput;
}

export interface CupUpdateManyWithWhereNestedInput {
  where: CupScalarWhereInput;
  data: CupUpdateManyDataInput;
}

export interface UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput {
  crampsLevel?: Maybe<Int>;
  recordDate: DateTimeInput;
  recordPeriodRow?: Maybe<
    UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput
  >;
}

export interface CupUpdateManyDataInput {
  anonSerialNumber?: Maybe<Int>;
  encryptionKey?: Maybe<Int>;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  country_id: Maybe<Int>;
  countryName?: Maybe<String>;
}>;

export interface CalibrationUpdateManyMutationInput {
  calibVersion?: Maybe<String>;
}

export interface UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryCreateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish: DateTimeInput;
  mensStart: DateTimeInput;
  user?: Maybe<UserCreateOneWithoutUserRecordDataByPeriodInput>;
}

export interface CompanyCreateInput {
  companyName: String;
  cup?: Maybe<CupCreateManyWithoutCompanyInput>;
}

export interface UserInterviewDatumUpdateManyMutationInput {
  answerRange?: Maybe<Int>;
  answerText?: Maybe<String>;
  answerYn?: Maybe<Boolean>;
  date?: Maybe<DateTimeInput>;
}

export interface CupCreateManyWithoutCompanyInput {
  create?: Maybe<CupCreateWithoutCompanyInput[] | CupCreateWithoutCompanyInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
}

export interface UserUpdateManyMutationInput {
  anonUserId?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
}

export interface CupCreateWithoutCompanyInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface HardwareUpdateManyMutationInput {
  hwVersion?: Maybe<String>;
}

export interface CompanyUpdateInput {
  companyName?: Maybe<String>;
  cup?: Maybe<CupUpdateManyWithoutCompanyInput>;
}

export interface CupCreateWithoutHwInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupUpdateManyWithoutCompanyInput {
  create?: Maybe<CupCreateWithoutCompanyInput[] | CupCreateWithoutCompanyInput>;
  delete?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  set?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  disconnect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
  update?: Maybe<
    | CupUpdateWithWhereUniqueWithoutCompanyInput[]
    | CupUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | CupUpsertWithWhereUniqueWithoutCompanyInput[]
    | CupUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<CupScalarWhereInput[] | CupScalarWhereInput>;
  updateMany?: Maybe<
    CupUpdateManyWithWhereNestedInput[] | CupUpdateManyWithWhereNestedInput
  >;
}

export interface CupUpdateWithoutFwDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface CupUpdateWithWhereUniqueWithoutCompanyInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutCompanyDataInput;
}

export interface CupCreateManyWithoutFwInput {
  create?: Maybe<CupCreateWithoutFwInput[] | CupCreateWithoutFwInput>;
  connect?: Maybe<CupWhereUniqueInput[] | CupWhereUniqueInput>;
}

export interface CupUpdateWithoutCompanyDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface UserUpdateManyWithoutEthnicityInput {
  create?: Maybe<
    UserCreateWithoutEthnicityInput[] | UserCreateWithoutEthnicityInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutEthnicityInput[]
    | UserUpdateWithWhereUniqueWithoutEthnicityInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutEthnicityInput[]
    | UserUpsertWithWhereUniqueWithoutEthnicityInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface CupUpsertWithWhereUniqueWithoutCompanyInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutCompanyDataInput;
  create: CupCreateWithoutCompanyInput;
}

export type EthnicityWhereUniqueInput = AtLeastOne<{
  ethnicity_id: Maybe<Int>;
  ethnicity?: Maybe<String>;
}>;

export interface CompanyUpdateManyMutationInput {
  companyName?: Maybe<String>;
}

export interface CupDataUserRemoveUpdateManyWithoutExplainInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutExplainInput[]
    | CupDataUserRemoveCreateWithoutExplainInput
  >;
  delete?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  set?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  disconnect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
  update?: Maybe<
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainInput
  >;
  upsert?: Maybe<
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainInput
  >;
  deleteMany?: Maybe<
    CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput
  >;
  updateMany?: Maybe<
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput
  >;
}

export interface CountryCreateInput {
  countryName: String;
  users?: Maybe<UserCreateManyWithoutCountryInput>;
}

export interface CupDataUserRemoveUpdateManyMutationInput {
  changeTime?: Maybe<DateTimeInput>;
}

export interface UserCreateManyWithoutCountryInput {
  create?: Maybe<
    UserCreateWithoutCountryInput[] | UserCreateWithoutCountryInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface CupDataProcMdateUpdateWithoutRejectDataInput {
  cupDataManMdates?: Maybe<CupDataManMdateUpdateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  rewardAmount?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcMdatesInput>;
}

export interface UserCreateWithoutCountryInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncCreateManyWithoutUserInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveCreateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: Maybe<String>;
  ethnicity: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: Maybe<UserCoinHistoryCreateManyWithoutUserInput>;
  userCups?: Maybe<UserCupCreateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumCreateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodCreateManyWithoutUserInput
  >;
}

export interface CupDataRejectionCreateInput {
  cupDataProcMdates?: Maybe<CupDataProcMdateCreateManyWithoutRejectInput>;
  rejectionDescription: String;
}

export interface CountryUpdateInput {
  countryName?: Maybe<String>;
  users?: Maybe<UserUpdateManyWithoutCountryInput>;
}

export interface CupCreateWithoutCupDataRawInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface UserUpdateManyWithoutCountryInput {
  create?: Maybe<
    UserCreateWithoutCountryInput[] | UserCreateWithoutCountryInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCountryInput[]
    | UserUpdateWithWhereUniqueWithoutCountryInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCountryInput[]
    | UserUpsertWithWhereUniqueWithoutCountryInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface CupDataQaResponseUpdateManyMutationInput {
  qaDate?: Maybe<DateTimeInput>;
}

export interface UserUpdateWithWhereUniqueWithoutCountryInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCountryDataInput;
}

export interface CupDatumUpdateOneRequiredWithoutCupDataProcVolumeInput {
  create?: Maybe<CupDatumCreateWithoutCupDataProcVolumeInput>;
  update?: Maybe<CupDatumUpdateWithoutCupDataProcVolumeDataInput>;
  upsert?: Maybe<CupDatumUpsertWithoutCupDataProcVolumeInput>;
  connect?: Maybe<CupDatumWhereUniqueInput>;
}

export interface UserUpdateWithoutCountryDataInput {
  anonUserId?: Maybe<Int>;
  appServerSync?: Maybe<AppServerSyncUpdateManyWithoutUserInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutUserInput>;
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutUserInput>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutUserInput>;
  cupDataUserRemove?: Maybe<CupDataUserRemoveUpdateManyWithoutUserInput>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  ethnicity?: Maybe<EthnicityUpdateOneRequiredWithoutUsersInput>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userCoinHistory?: Maybe<UserCoinHistoryUpdateManyWithoutUserInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutUserInput>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutUserInput>;
  userRecordDataByPeriod?: Maybe<
    UserRecordDataByPeriodUpdateManyWithoutUserInput
  >;
}

export interface UserCreateOneWithoutUserInterviewDataInput {
  create?: Maybe<UserCreateWithoutUserInterviewDataInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutCountryInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCountryDataInput;
  create: UserCreateWithoutCountryInput;
}

export interface CupDataProcMdateCreateOneWithoutCupDataProcFlowInput {
  create?: Maybe<CupDataProcMdateCreateWithoutCupDataProcFlowInput>;
  connect?: Maybe<CupDataProcMdateWhereUniqueInput>;
}

export interface UserScalarWhereInput {
  user_id?: Maybe<Int>;
  user_id_not?: Maybe<Int>;
  user_id_in?: Maybe<Int[] | Int>;
  user_id_not_in?: Maybe<Int[] | Int>;
  user_id_lt?: Maybe<Int>;
  user_id_lte?: Maybe<Int>;
  user_id_gt?: Maybe<Int>;
  user_id_gte?: Maybe<Int>;
  anonUserId?: Maybe<Int>;
  anonUserId_not?: Maybe<Int>;
  anonUserId_in?: Maybe<Int[] | Int>;
  anonUserId_not_in?: Maybe<Int[] | Int>;
  anonUserId_lt?: Maybe<Int>;
  anonUserId_lte?: Maybe<Int>;
  anonUserId_gt?: Maybe<Int>;
  anonUserId_gte?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  dob_not?: Maybe<DateTimeInput>;
  dob_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  dob_lt?: Maybe<DateTimeInput>;
  dob_lte?: Maybe<DateTimeInput>;
  dob_gt?: Maybe<DateTimeInput>;
  dob_gte?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  encryptSaltString_not?: Maybe<String>;
  encryptSaltString_in?: Maybe<String[] | String>;
  encryptSaltString_not_in?: Maybe<String[] | String>;
  encryptSaltString_lt?: Maybe<String>;
  encryptSaltString_lte?: Maybe<String>;
  encryptSaltString_gt?: Maybe<String>;
  encryptSaltString_gte?: Maybe<String>;
  encryptSaltString_contains?: Maybe<String>;
  encryptSaltString_not_contains?: Maybe<String>;
  encryptSaltString_starts_with?: Maybe<String>;
  encryptSaltString_not_starts_with?: Maybe<String>;
  encryptSaltString_ends_with?: Maybe<String>;
  encryptSaltString_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  givenBirth_not?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface CupDataQaResponseCreateManyWithoutUserInput {
  create?: Maybe<
    | CupDataQaResponseCreateWithoutUserInput[]
    | CupDataQaResponseCreateWithoutUserInput
  >;
  connect?: Maybe<
    CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput
  >;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserCreateOneWithoutCupDataQaResponseInput {
  create?: Maybe<UserCreateWithoutCupDataQaResponseInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateManyDataInput {
  anonUserId?: Maybe<Int>;
  deleted?: Maybe<Boolean>;
  dob?: Maybe<DateTimeInput>;
  email?: Maybe<String>;
  encryptSaltString?: Maybe<String>;
  firstName?: Maybe<String>;
  givenBirth?: Maybe<Boolean>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
}

export interface CupDataUserRemoveCreateManyWithoutUserInput {
  create?: Maybe<
    | CupDataUserRemoveCreateWithoutUserInput[]
    | CupDataUserRemoveCreateWithoutUserInput
  >;
  connect?: Maybe<
    CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput
  >;
}

export interface CountryUpdateManyMutationInput {
  countryName?: Maybe<String>;
}

export interface CompanyCreateOneWithoutCupInput {
  create?: Maybe<CompanyCreateWithoutCupInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CupCreateInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupDataProcVolumeCreateManyWithoutCupDataRowInput {
  create?: Maybe<
    | CupDataProcVolumeCreateWithoutCupDataRowInput[]
    | CupDataProcVolumeCreateWithoutCupDataRowInput
  >;
  connect?: Maybe<
    CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput
  >;
}

export interface CupUpdateInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface HardwareCreateOneWithoutCupInput {
  create?: Maybe<HardwareCreateWithoutCupInput>;
  connect?: Maybe<HardwareWhereUniqueInput>;
}

export interface CupUpdateManyMutationInput {
  anonSerialNumber?: Maybe<Int>;
  encryptionKey?: Maybe<Int>;
}

export interface UserCoinHistoryCreateManyWithoutUserInput {
  create?: Maybe<
    | UserCoinHistoryCreateWithoutUserInput[]
    | UserCoinHistoryCreateWithoutUserInput
  >;
  connect?: Maybe<
    UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput
  >;
}

export interface CupAppSyncCreateInput {
  appSynchTime: DateTimeInput;
  serialNumber: CupCreateOneWithoutCupAppSyncInput;
}

export interface CupCreateOneWithoutUserCupsInput {
  create?: Maybe<CupCreateWithoutUserCupsInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupCreateOneWithoutCupAppSyncInput {
  create?: Maybe<CupCreateWithoutCupAppSyncInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface UserInterviewQuestionCreateOneWithoutUserInterviewDataInput {
  create?: Maybe<UserInterviewQuestionCreateWithoutUserInterviewDataInput>;
  connect?: Maybe<UserInterviewQuestionWhereUniqueInput>;
}

export interface CupCreateWithoutCupAppSyncInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface UserCreateOneWithoutUserCoinHistoryInput {
  create?: Maybe<UserCreateWithoutUserCoinHistoryInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupAppSyncUpdateInput {
  appSynchTime?: Maybe<DateTimeInput>;
  serialNumber?: Maybe<CupUpdateOneRequiredWithoutCupAppSyncInput>;
}

export interface CupDataQuestionCreateWithoutCupDataQaResponseInput {
  cupDataAnswer?: Maybe<CupDataAnswerCreateManyWithoutQuestionInput>;
  questionText: String;
}

export interface CupUpdateOneRequiredWithoutCupAppSyncInput {
  create?: Maybe<CupCreateWithoutCupAppSyncInput>;
  update?: Maybe<CupUpdateWithoutCupAppSyncDataInput>;
  upsert?: Maybe<CupUpsertWithoutCupAppSyncInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface UserInterviewQuestionUpdateWithoutAnswerTypeDataInput {
  question?: Maybe<String>;
  userInterviewData?: Maybe<UserInterviewDatumUpdateManyWithoutQuestionInput>;
}

export interface CupUpdateWithoutCupAppSyncDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface UserRecordDataByTimeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserRecordDataByTimeWhereInput>;
  AND?: Maybe<
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput
  >;
}

export interface CupUpsertWithoutCupAppSyncInput {
  update: CupUpdateWithoutCupAppSyncDataInput;
  create: CupCreateWithoutCupAppSyncInput;
}

export interface EthnicitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EthnicityWhereInput>;
  AND?: Maybe<
    EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput
  >;
  OR?: Maybe<
    EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput
  >;
  NOT?: Maybe<
    EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput
  >;
}

export interface CupAppSyncUpdateManyMutationInput {
  appSynchTime?: Maybe<DateTimeInput>;
}

export interface CupDataProcMdateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataProcMdateWhereInput>;
  AND?: Maybe<
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput
  >;
}

export interface CupDataAnswerCreateInput {
  answerText: String;
  cupDataQaResponse?: Maybe<CupDataQaResponseCreateManyWithoutAnswerInput>;
  question: CupDataQuestionCreateOneWithoutCupDataAnswerInput;
}

export interface CupDataQaResponseWhereInput {
  cup_data_qa_response_id?: Maybe<Int>;
  cup_data_qa_response_id_not?: Maybe<Int>;
  cup_data_qa_response_id_in?: Maybe<Int[] | Int>;
  cup_data_qa_response_id_not_in?: Maybe<Int[] | Int>;
  cup_data_qa_response_id_lt?: Maybe<Int>;
  cup_data_qa_response_id_lte?: Maybe<Int>;
  cup_data_qa_response_id_gt?: Maybe<Int>;
  cup_data_qa_response_id_gte?: Maybe<Int>;
  answer?: Maybe<CupDataAnswerWhereInput>;
  qaDate?: Maybe<DateTimeInput>;
  qaDate_not?: Maybe<DateTimeInput>;
  qaDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  qaDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  qaDate_lt?: Maybe<DateTimeInput>;
  qaDate_lte?: Maybe<DateTimeInput>;
  qaDate_gt?: Maybe<DateTimeInput>;
  qaDate_gte?: Maybe<DateTimeInput>;
  question?: Maybe<CupDataQuestionWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput>;
  OR?: Maybe<CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput>;
  NOT?: Maybe<CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput>;
}

export interface CupDataAnswerUpdateInput {
  answerText?: Maybe<String>;
  cupDataQaResponse?: Maybe<CupDataQaResponseUpdateManyWithoutAnswerInput>;
  question?: Maybe<CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput>;
}

export interface UserRecordDataByDayUpdateOneWithoutUserRecordDataByTimeInput {
  create?: Maybe<UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput>;
  update?: Maybe<UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput>;
  upsert?: Maybe<UserRecordDataByDayUpsertWithoutUserRecordDataByTimeInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserRecordDataByDayWhereUniqueInput>;
}

export interface CupDataAnswerUpdateManyMutationInput {
  answerText?: Maybe<String>;
}

export interface UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput {
  coinHistoryRow?: Maybe<
    UserCoinHistoryUpdateOneWithoutUserRecordDataByPeriodInput
  >;
  isTakePill?: Maybe<Boolean>;
  mensFinish?: Maybe<DateTimeInput>;
  mensStart?: Maybe<DateTimeInput>;
  user?: Maybe<UserUpdateOneWithoutUserRecordDataByPeriodInput>;
}

export interface CupDataColourCalcCreateInput {
  blue: Int;
  cupDataRow: CupDatumCreateOneWithoutCupDataColourCalcInput;
  green: Int;
  red: Int;
}

export interface UserCoinHistoryUpdateManyMutationInput {
  category?: Maybe<String>;
  coin?: Maybe<Int>;
  contents?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  txhash?: Maybe<String>;
}

export interface CupDatumCreateOneWithoutCupDataColourCalcInput {
  create?: Maybe<CupDatumCreateWithoutCupDataColourCalcInput>;
  connect?: Maybe<CupDatumWhereUniqueInput>;
}

export interface CupUpdateWithWhereUniqueWithoutHwInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutHwDataInput;
}

export interface CupDatumCreateWithoutCupDataColourCalcInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataProcVolume?: Maybe<CupDataProcVolumeCreateManyWithoutCupDataRowInput>;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupCreateOneWithoutCupDataInput>;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface FirmwareUpdateInput {
  cup?: Maybe<CupUpdateManyWithoutFwInput>;
  fwVersion?: Maybe<String>;
}

export interface CupCreateOneWithoutCupDataInput {
  create?: Maybe<CupCreateWithoutCupDataInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export type CupDatumWhereUniqueInput = AtLeastOne<{
  row_id: Maybe<Int>;
}>;

export interface CupCreateWithoutCupDataInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibCreateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupDataUserRemoveCreateWithoutExplainInput {
  changeTime: DateTimeInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
  user: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface CupDataColourCalcUpdateInput {
  blue?: Maybe<Int>;
  cupDataRow?: Maybe<CupDatumUpdateOneRequiredWithoutCupDataColourCalcInput>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface CupDataRejectionUpdateInput {
  cupDataProcMdates?: Maybe<CupDataProcMdateUpdateManyWithoutRejectInput>;
  rejectionDescription?: Maybe<String>;
}

export interface CupDatumUpdateOneRequiredWithoutCupDataColourCalcInput {
  create?: Maybe<CupDatumCreateWithoutCupDataColourCalcInput>;
  update?: Maybe<CupDatumUpdateWithoutCupDataColourCalcDataInput>;
  upsert?: Maybe<CupDatumUpsertWithoutCupDataColourCalcInput>;
  connect?: Maybe<CupDatumWhereUniqueInput>;
}

export interface CupDataQuestionUpdateManyMutationInput {
  questionText?: Maybe<String>;
}

export interface CupDatumUpdateWithoutCupDataColourCalcDataInput {
  battery?: Maybe<Int>;
  calibFlag?: Maybe<Boolean>;
  ch1?: Maybe<Int>;
  ch10?: Maybe<Int>;
  ch11?: Maybe<Int>;
  ch12?: Maybe<Int>;
  ch13?: Maybe<Int>;
  ch14?: Maybe<Int>;
  ch2?: Maybe<Int>;
  ch3?: Maybe<Int>;
  ch4?: Maybe<Int>;
  ch5?: Maybe<Int>;
  ch6?: Maybe<Int>;
  ch7?: Maybe<Int>;
  ch8?: Maybe<Int>;
  ch9?: Maybe<Int>;
  colourB?: Maybe<Int>;
  colourC?: Maybe<Int>;
  colourG?: Maybe<Int>;
  colourR?: Maybe<Int>;
  cupDataProcVolume?: Maybe<CupDataProcVolumeUpdateManyWithoutCupDataRowInput>;
  date?: Maybe<DateTimeInput>;
  day?: Maybe<Int>;
  hour?: Maybe<Int>;
  line?: Maybe<Int>;
  minute?: Maybe<Int>;
  month?: Maybe<Int>;
  page?: Maybe<Int>;
  rawTotalVolume?: Maybe<Int>;
  rawVolumeL?: Maybe<Int>;
  rawVolumeR?: Maybe<Int>;
  serialNumber?: Maybe<CupUpdateOneWithoutCupDataInput>;
  temperature?: Maybe<Int>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  year?: Maybe<Int>;
  z?: Maybe<Int>;
}

export interface UserInterviewQuestionCreateManyWithoutAnswerTypeInput {
  create?: Maybe<
    | UserInterviewQuestionCreateWithoutAnswerTypeInput[]
    | UserInterviewQuestionCreateWithoutAnswerTypeInput
  >;
  connect?: Maybe<
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput
  >;
}

export interface CupUpdateOneWithoutCupDataInput {
  create?: Maybe<CupCreateWithoutCupDataInput>;
  update?: Maybe<CupUpdateWithoutCupDataDataInput>;
  upsert?: Maybe<CupUpsertWithoutCupDataInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupDataRejectionCreateOneWithoutCupDataProcMdatesInput {
  create?: Maybe<CupDataRejectionCreateWithoutCupDataProcMdatesInput>;
  connect?: Maybe<CupDataRejectionWhereUniqueInput>;
}

export interface CupUpdateWithoutCupDataDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface CupDataProcFlowCreateManyWithoutMdateRowInput {
  create?: Maybe<
    | CupDataProcFlowCreateWithoutMdateRowInput[]
    | CupDataProcFlowCreateWithoutMdateRowInput
  >;
  connect?: Maybe<
    CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput
  >;
}

export interface CupUpsertWithoutCupDataInput {
  update: CupUpdateWithoutCupDataDataInput;
  create: CupCreateWithoutCupDataInput;
}

export interface CupDatumCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDatumCreateWithoutSerialNumberInput[]
    | CupDatumCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput>;
}

export interface CupDatumUpsertWithoutCupDataColourCalcInput {
  update: CupDatumUpdateWithoutCupDataColourCalcDataInput;
  create: CupDatumCreateWithoutCupDataColourCalcInput;
}

export interface UserCreateOneWithoutUserCupsInput {
  create?: Maybe<UserCreateWithoutUserCupsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataColourCalcUpdateManyMutationInput {
  blue?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface UserCreateOneWithoutCupDataUserRemoveInput {
  create?: Maybe<UserCreateWithoutCupDataUserRemoveInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataColourCalibCreateInput {
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
  serialNumber: CupCreateOneWithoutCupDataColourCalibInput;
}

export interface UserRecordDataByTimeCreateManyWithoutRecordDayRowInput {
  create?: Maybe<
    | UserRecordDataByTimeCreateWithoutRecordDayRowInput[]
    | UserRecordDataByTimeCreateWithoutRecordDayRowInput
  >;
  connect?: Maybe<
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput
  >;
}

export interface CupCreateOneWithoutCupDataColourCalibInput {
  create?: Maybe<CupCreateWithoutCupDataColourCalibInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutUserInterviewDataInput {
  create?: Maybe<UserCreateWithoutUserInterviewDataInput>;
  update?: Maybe<UserUpdateWithoutUserInterviewDataDataInput>;
  upsert?: Maybe<UserUpsertWithoutUserInterviewDataInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupCreateWithoutCupDataColourCalibInput {
  anonSerialNumber: Int;
  calib?: Maybe<CalibrationCreateOneWithoutCupInput>;
  company?: Maybe<CompanyCreateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncCreateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumCreateManyWithoutSerialNumberInput>;
  cupDataRaw?: Maybe<CupDataRawCreateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveCreateManyWithoutSerialNumberInput
  >;
  encryptionKey: Int;
  fw?: Maybe<FirmwareCreateOneWithoutCupInput>;
  hw?: Maybe<HardwareCreateOneWithoutCupInput>;
  userCups?: Maybe<UserCupCreateManyWithoutSerialNumberInput>;
}

export interface CupDataRawSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataRawWhereInput>;
  AND?: Maybe<
    CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput
  >;
  OR?: Maybe<
    CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput
  >;
}

export interface CupDataColourCalibUpdateInput {
  blue?: Maybe<Int>;
  c?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
  serialNumber?: Maybe<CupUpdateOneRequiredWithoutCupDataColourCalibInput>;
}

export interface UsersDataAnalysisUpdateInput {
  email?: Maybe<String>;
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  password?: Maybe<String>;
  userId?: Maybe<String>;
}

export interface CupUpdateOneRequiredWithoutCupDataColourCalibInput {
  create?: Maybe<CupCreateWithoutCupDataColourCalibInput>;
  update?: Maybe<CupUpdateWithoutCupDataColourCalibDataInput>;
  upsert?: Maybe<CupUpsertWithoutCupDataColourCalibInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface UserInterviewQuestionUpdateManyMutationInput {
  question?: Maybe<String>;
}

export interface CupUpdateWithoutCupDataColourCalibDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataRaw?: Maybe<CupDataRawUpdateManyWithoutSerialNumberInput>;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface FirmwareUpdateManyMutationInput {
  fwVersion?: Maybe<String>;
}

export interface CupUpsertWithoutCupDataColourCalibInput {
  update: CupUpdateWithoutCupDataColourCalibDataInput;
  create: CupCreateWithoutCupDataColourCalibInput;
}

export interface CupDataUserRemoveUpdateWithoutExplainDataInput {
  changeTime?: Maybe<DateTimeInput>;
  serialNumber?: Maybe<CupUpdateOneRequiredWithoutCupDataUserRemoveInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataUserRemoveInput>;
}

export interface CupDataColourCalibUpdateManyMutationInput {
  blue?: Maybe<Int>;
  c?: Maybe<Int>;
  green?: Maybe<Int>;
  red?: Maybe<Int>;
}

export interface CupUpdateWithoutCupDataRawDataInput {
  anonSerialNumber?: Maybe<Int>;
  calib?: Maybe<CalibrationUpdateOneWithoutCupInput>;
  company?: Maybe<CompanyUpdateOneWithoutCupInput>;
  cupAppSync?: Maybe<CupAppSyncUpdateManyWithoutSerialNumberInput>;
  cupData?: Maybe<CupDatumUpdateManyWithoutSerialNumberInput>;
  cupDataColourCalib?: Maybe<
    CupDataColourCalibUpdateManyWithoutSerialNumberInput
  >;
  cupDataUserRemove?: Maybe<
    CupDataUserRemoveUpdateManyWithoutSerialNumberInput
  >;
  encryptionKey?: Maybe<Int>;
  fw?: Maybe<FirmwareUpdateOneWithoutCupInput>;
  hw?: Maybe<HardwareUpdateOneWithoutCupInput>;
  userCups?: Maybe<UserCupUpdateManyWithoutSerialNumberInput>;
}

export interface CupDataManMdateCreateInput {
  mdateRow: CupDataProcMdateCreateOneWithoutCupDataManMdatesInput;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface CountryCreateOneWithoutUsersInput {
  create?: Maybe<CountryCreateWithoutUsersInput>;
  connect?: Maybe<CountryWhereUniqueInput>;
}

export interface CupDataProcMdateCreateOneWithoutCupDataManMdatesInput {
  create?: Maybe<CupDataProcMdateCreateWithoutCupDataManMdatesInput>;
  connect?: Maybe<CupDataProcMdateWhereUniqueInput>;
}

export interface CupCreateOneWithoutCupDataUserRemoveInput {
  create?: Maybe<CupCreateWithoutCupDataUserRemoveInput>;
  connect?: Maybe<CupWhereUniqueInput>;
}

export interface CupDataProcMdateCreateWithoutCupDataManMdatesInput {
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  reject?: Maybe<CupDataRejectionCreateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface UserCreateOneWithoutUserRecordDataByPeriodInput {
  create?: Maybe<UserCreateWithoutUserRecordDataByPeriodInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CupDataManMdateUpdateInput {
  mdateRow?: Maybe<
    CupDataProcMdateUpdateOneRequiredWithoutCupDataManMdatesInput
  >;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface CupDataQaResponseCreateWithoutAnswerInput {
  qaDate: DateTimeInput;
  question: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
  user: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface CupDataProcMdateUpdateOneRequiredWithoutCupDataManMdatesInput {
  create?: Maybe<CupDataProcMdateCreateWithoutCupDataManMdatesInput>;
  update?: Maybe<CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput>;
  upsert?: Maybe<CupDataProcMdateUpsertWithoutCupDataManMdatesInput>;
  connect?: Maybe<CupDataProcMdateWhereUniqueInput>;
}

export interface CupDataAnswerSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CupDataAnswerWhereInput>;
  AND?: Maybe<
    CupDataAnswerSubscriptionWhereInput[] | CupDataAnswerSubscriptionWhereInput
  >;
  OR?: Maybe<
    CupDataAnswerSubscriptionWhereInput[] | CupDataAnswerSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CupDataAnswerSubscriptionWhereInput[] | CupDataAnswerSubscriptionWhereInput
  >;
}

export interface CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput {
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  reject?: Maybe<CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcMdatesInput>;
}

export interface PlatformCompUpdateManyMutationInput {
  phoneId?: Maybe<Int>;
  platformId?: Maybe<Int>;
  problemHistory?: Maybe<Boolean>;
  softwareId?: Maybe<Int>;
  successHistory?: Maybe<Boolean>;
}

export interface CupDataProcMdateUpsertWithoutCupDataManMdatesInput {
  update: CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput;
  create: CupDataProcMdateCreateWithoutCupDataManMdatesInput;
}

export interface CupDataUserRemoveCreateInput {
  changeTime: DateTimeInput;
  explain: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
  user: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface CupDataManMdateUpdateManyMutationInput {
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
}

export interface CupDataQuestionCreateOneWithoutCupDataAnswerInput {
  create?: Maybe<CupDataQuestionCreateWithoutCupDataAnswerInput>;
  connect?: Maybe<CupDataQuestionWhereUniqueInput>;
}

export interface CupDataProcFlowCreateInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  mdateRow: CupDataProcMdateCreateOneWithoutCupDataProcFlowInput;
  user: UserCreateOneWithoutCupDataProcFlowInput;
}

export interface UserRecordDataByPeriodCreateManyWithoutUserInput {
  create?: Maybe<
    | UserRecordDataByPeriodCreateWithoutUserInput[]
    | UserRecordDataByPeriodCreateWithoutUserInput
  >;
  connect?: Maybe<
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput
  >;
}

export interface CupDataProcMdateUpdateInput {
  cupDataManMdates?: Maybe<CupDataManMdateUpdateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowUpdateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified?: Maybe<Boolean>;
  menFinish?: Maybe<DateTimeInput>;
  menStart?: Maybe<DateTimeInput>;
  reject?: Maybe<CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcMdatesInput>;
}

export interface CupDataProcMdateCreateInput {
  cupDataManMdates?: Maybe<CupDataManMdateCreateManyWithoutMdateRowInput>;
  cupDataProcFlow?: Maybe<CupDataProcFlowCreateManyWithoutMdateRowInput>;
  dataRejected?: Maybe<Boolean>;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  reject?: Maybe<CupDataRejectionCreateOneWithoutCupDataProcMdatesInput>;
  rewardAmount?: Maybe<Int>;
  user: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface CupDataProcFlowUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
}

export interface CupDataProcFlowUpdateInput {
  date?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
  mdateRow?: Maybe<
    CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput
  >;
  user?: Maybe<UserUpdateOneRequiredWithoutCupDataProcFlowInput>;
}

export interface UserCoinHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserCoinHistoryWhereInput>;
  AND?: Maybe<
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput
  >;
}

export interface CupDataRawCreateManyWithoutSerialNumberInput {
  create?: Maybe<
    | CupDataRawCreateWithoutSerialNumberInput[]
    | CupDataRawCreateWithoutSerialNumberInput
  >;
  connect?: Maybe<CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput>;
}

export interface UsersDataAnalysisWhereInput {
  idx?: Maybe<Int>;
  idx_not?: Maybe<Int>;
  idx_in?: Maybe<Int[] | Int>;
  idx_not_in?: Maybe<Int[] | Int>;
  idx_lt?: Maybe<Int>;
  idx_lte?: Maybe<Int>;
  idx_gt?: Maybe<Int>;
  idx_gte?: Maybe<Int>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  userId?: Maybe<String>;
  userId_not?: Maybe<String>;
  userId_in?: Maybe<String[] | String>;
  userId_not_in?: Maybe<String[] | String>;
  userId_lt?: Maybe<String>;
  userId_lte?: Maybe<String>;
  userId_gt?: Maybe<String>;
  userId_gte?: Maybe<String>;
  userId_contains?: Maybe<String>;
  userId_not_contains?: Maybe<String>;
  userId_starts_with?: Maybe<String>;
  userId_not_starts_with?: Maybe<String>;
  userId_ends_with?: Maybe<String>;
  userId_not_ends_with?: Maybe<String>;
  AND?: Maybe<UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput>;
  OR?: Maybe<UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput>;
  NOT?: Maybe<UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput>;
}

export interface UserUpsertWithWhereUniqueWithoutEthnicityInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutEthnicityDataInput;
  create: UserCreateWithoutEthnicityInput;
}

export interface CupDataProcFlowWhereInput {
  row_id?: Maybe<Int>;
  row_id_not?: Maybe<Int>;
  row_id_in?: Maybe<Int[] | Int>;
  row_id_not_in?: Maybe<Int[] | Int>;
  row_id_lt?: Maybe<Int>;
  row_id_lte?: Maybe<Int>;
  row_id_gt?: Maybe<Int>;
  row_id_gte?: Maybe<Int>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  hourlyFlow?: Maybe<Int>;
  hourlyFlow_not?: Maybe<Int>;
  hourlyFlow_in?: Maybe<Int[] | Int>;
  hourlyFlow_not_in?: Maybe<Int[] | Int>;
  hourlyFlow_lt?: Maybe<Int>;
  hourlyFlow_lte?: Maybe<Int>;
  hourlyFlow_gt?: Maybe<Int>;
  hourlyFlow_gte?: Maybe<Int>;
  mdateRow?: Maybe<CupDataProcMdateWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput>;
  OR?: Maybe<CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput>;
  NOT?: Maybe<CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UsersDataAnalysisPreviousValues {
  idx: Int;
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface UsersDataAnalysisPreviousValuesPromise
  extends Promise<UsersDataAnalysisPreviousValues>,
    Fragmentable {
  idx: () => Promise<Int>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface UsersDataAnalysisPreviousValuesSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisPreviousValues>>,
    Fragmentable {
  idx: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AuthTokenConnection {
  pageInfo: PageInfo;
  edges: AuthTokenEdge[];
}

export interface AuthTokenConnectionPromise
  extends Promise<AuthTokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthTokenEdge>>() => T;
  aggregate: <T = AggregateAuthTokenPromise>() => T;
}

export interface AuthTokenConnectionSubscription
  extends Promise<AsyncIterator<AuthTokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthTokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthTokenSubscription>() => T;
}

export interface UserRecordDataByPeriodPreviousValues {
  row_id: Int;
  isTakePill?: Boolean;
  mensFinish: DateTimeOutput;
  mensStart: DateTimeOutput;
}

export interface UserRecordDataByPeriodPreviousValuesPromise
  extends Promise<UserRecordDataByPeriodPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  isTakePill: () => Promise<Boolean>;
  mensFinish: () => Promise<DateTimeOutput>;
  mensStart: () => Promise<DateTimeOutput>;
}

export interface UserRecordDataByPeriodPreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  isTakePill: () => Promise<AsyncIterator<Boolean>>;
  mensFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  mensStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthToken {
  user_id: Int;
}

export interface AuthTokenPromise extends Promise<AuthToken>, Fragmentable {
  user_id: () => Promise<Int>;
}

export interface AuthTokenSubscription
  extends Promise<AsyncIterator<AuthToken>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
}

export interface AuthTokenNullablePromise
  extends Promise<AuthToken | null>,
    Fragmentable {
  user_id: () => Promise<Int>;
}

export interface AggregateAppServerSync {
  count: Int;
}

export interface AggregateAppServerSyncPromise
  extends Promise<AggregateAppServerSync>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppServerSyncSubscription
  extends Promise<AsyncIterator<AggregateAppServerSync>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserInterviewQuestion {
  question_id: Int;
  question: String;
}

export interface UserInterviewQuestionPromise
  extends Promise<UserInterviewQuestion>,
    Fragmentable {
  question_id: () => Promise<Int>;
  answerType: <T = AnswerTypePromise>() => T;
  question: () => Promise<String>;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserInterviewQuestionSubscription
  extends Promise<AsyncIterator<UserInterviewQuestion>>,
    Fragmentable {
  question_id: () => Promise<AsyncIterator<Int>>;
  answerType: <T = AnswerTypeSubscription>() => T;
  question: () => Promise<AsyncIterator<String>>;
  userInterviewData: <
    T = Promise<AsyncIterator<UserInterviewDatumSubscription>>
  >(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserInterviewQuestionNullablePromise
  extends Promise<UserInterviewQuestion | null>,
    Fragmentable {
  question_id: () => Promise<Int>;
  answerType: <T = AnswerTypePromise>() => T;
  question: () => Promise<String>;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AppServerSyncEdge {
  node: AppServerSync;
  cursor: String;
}

export interface AppServerSyncEdgePromise
  extends Promise<AppServerSyncEdge>,
    Fragmentable {
  node: <T = AppServerSyncPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppServerSyncEdgeSubscription
  extends Promise<AsyncIterator<AppServerSyncEdge>>,
    Fragmentable {
  node: <T = AppServerSyncSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UsersDataAnalysisEdge {
  node: UsersDataAnalysis;
  cursor: String;
}

export interface UsersDataAnalysisEdgePromise
  extends Promise<UsersDataAnalysisEdge>,
    Fragmentable {
  node: <T = UsersDataAnalysisPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UsersDataAnalysisEdgeSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisEdge>>,
    Fragmentable {
  node: <T = UsersDataAnalysisSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppServerSyncConnection {
  pageInfo: PageInfo;
  edges: AppServerSyncEdge[];
}

export interface AppServerSyncConnectionPromise
  extends Promise<AppServerSyncConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppServerSyncEdge>>() => T;
  aggregate: <T = AggregateAppServerSyncPromise>() => T;
}

export interface AppServerSyncConnectionSubscription
  extends Promise<AsyncIterator<AppServerSyncConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppServerSyncEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppServerSyncSubscription>() => T;
}

export interface AnswerType {
  answer_type_id: Int;
  answerType: String;
}

export interface AnswerTypePromise extends Promise<AnswerType>, Fragmentable {
  answer_type_id: () => Promise<Int>;
  answerType: () => Promise<String>;
  userInterviewQuestions: <
    T = FragmentableArray<UserInterviewQuestion>
  >(args?: {
    where?: UserInterviewQuestionWhereInput;
    orderBy?: UserInterviewQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnswerTypeSubscription
  extends Promise<AsyncIterator<AnswerType>>,
    Fragmentable {
  answer_type_id: () => Promise<AsyncIterator<Int>>;
  answerType: () => Promise<AsyncIterator<String>>;
  userInterviewQuestions: <
    T = Promise<AsyncIterator<UserInterviewQuestionSubscription>>
  >(args?: {
    where?: UserInterviewQuestionWhereInput;
    orderBy?: UserInterviewQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AnswerTypeNullablePromise
  extends Promise<AnswerType | null>,
    Fragmentable {
  answer_type_id: () => Promise<Int>;
  answerType: () => Promise<String>;
  userInterviewQuestions: <
    T = FragmentableArray<UserInterviewQuestion>
  >(args?: {
    where?: UserInterviewQuestionWhereInput;
    orderBy?: UserInterviewQuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateAnswerType {
  count: Int;
}

export interface AggregateAnswerTypePromise
  extends Promise<AggregateAnswerType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnswerTypeSubscription
  extends Promise<AsyncIterator<AggregateAnswerType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUserRecordDataByTime {
  count: Int;
}

export interface AggregateUserRecordDataByTimePromise
  extends Promise<AggregateUserRecordDataByTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByTimeSubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AnswerTypeEdge {
  node: AnswerType;
  cursor: String;
}

export interface AnswerTypeEdgePromise
  extends Promise<AnswerTypeEdge>,
    Fragmentable {
  node: <T = AnswerTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnswerTypeEdgeSubscription
  extends Promise<AsyncIterator<AnswerTypeEdge>>,
    Fragmentable {
  node: <T = AnswerTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByTimeConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByTimeEdge[];
}

export interface UserRecordDataByTimeConnectionPromise
  extends Promise<UserRecordDataByTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByTimeEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByTimePromise>() => T;
}

export interface UserRecordDataByTimeConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByTimeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByTimeSubscription>() => T;
}

export interface UserInterviewDatum {
  row_id: Int;
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeOutput;
}

export interface UserInterviewDatumPromise
  extends Promise<UserInterviewDatum>,
    Fragmentable {
  row_id: () => Promise<Int>;
  answerRange: () => Promise<Int>;
  answerText: () => Promise<String>;
  answerYn: () => Promise<Boolean>;
  date: () => Promise<DateTimeOutput>;
  question: <T = UserInterviewQuestionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserInterviewDatumSubscription
  extends Promise<AsyncIterator<UserInterviewDatum>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  answerRange: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  answerYn: () => Promise<AsyncIterator<Boolean>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  question: <T = UserInterviewQuestionSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface UserInterviewDatumNullablePromise
  extends Promise<UserInterviewDatum | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  answerRange: () => Promise<Int>;
  answerText: () => Promise<String>;
  answerYn: () => Promise<Boolean>;
  date: () => Promise<DateTimeOutput>;
  question: <T = UserInterviewQuestionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserRecordDataByPeriodEdge {
  node: UserRecordDataByPeriod;
  cursor: String;
}

export interface UserRecordDataByPeriodEdgePromise
  extends Promise<UserRecordDataByPeriodEdge>,
    Fragmentable {
  node: <T = UserRecordDataByPeriodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByPeriodEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByPeriodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AnswerTypeSubscriptionPayload {
  mutation: MutationType;
  node: AnswerType;
  updatedFields: String[];
  previousValues: AnswerTypePreviousValues;
}

export interface AnswerTypeSubscriptionPayloadPromise
  extends Promise<AnswerTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnswerTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnswerTypePreviousValuesPromise>() => T;
}

export interface AnswerTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnswerTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnswerTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnswerTypePreviousValuesSubscription>() => T;
}

export interface AggregateUserRecordDataByDay {
  count: Int;
}

export interface AggregateUserRecordDataByDayPromise
  extends Promise<AggregateUserRecordDataByDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByDaySubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AnswerTypePreviousValues {
  answer_type_id: Int;
  answerType: String;
}

export interface AnswerTypePreviousValuesPromise
  extends Promise<AnswerTypePreviousValues>,
    Fragmentable {
  answer_type_id: () => Promise<Int>;
  answerType: () => Promise<String>;
}

export interface AnswerTypePreviousValuesSubscription
  extends Promise<AsyncIterator<AnswerTypePreviousValues>>,
    Fragmentable {
  answer_type_id: () => Promise<AsyncIterator<Int>>;
  answerType: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByDayConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByDayEdge[];
}

export interface UserRecordDataByDayConnectionPromise
  extends Promise<UserRecordDataByDayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByDayEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByDayPromise>() => T;
}

export interface UserRecordDataByDayConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByDayEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByDaySubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserInterviewQuestionEdge {
  node: UserInterviewQuestion;
  cursor: String;
}

export interface UserInterviewQuestionEdgePromise
  extends Promise<UserInterviewQuestionEdge>,
    Fragmentable {
  node: <T = UserInterviewQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserInterviewQuestionEdgeSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionEdge>>,
    Fragmentable {
  node: <T = UserInterviewQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppServerSyncSubscriptionPayload {
  mutation: MutationType;
  node: AppServerSync;
  updatedFields: String[];
  previousValues: AppServerSyncPreviousValues;
}

export interface AppServerSyncSubscriptionPayloadPromise
  extends Promise<AppServerSyncSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppServerSyncPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppServerSyncPreviousValuesPromise>() => T;
}

export interface AppServerSyncSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppServerSyncSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppServerSyncSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppServerSyncPreviousValuesSubscription>() => T;
}

export interface AggregateUserInterviewDatum {
  count: Int;
}

export interface AggregateUserInterviewDatumPromise
  extends Promise<AggregateUserInterviewDatum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserInterviewDatumSubscription
  extends Promise<AsyncIterator<AggregateUserInterviewDatum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppServerSyncPreviousValues {
  app_server_sync_id: Int;
  serverSynchTime: DateTimeOutput;
}

export interface AppServerSyncPreviousValuesPromise
  extends Promise<AppServerSyncPreviousValues>,
    Fragmentable {
  app_server_sync_id: () => Promise<Int>;
  serverSynchTime: () => Promise<DateTimeOutput>;
}

export interface AppServerSyncPreviousValuesSubscription
  extends Promise<AsyncIterator<AppServerSyncPreviousValues>>,
    Fragmentable {
  app_server_sync_id: () => Promise<AsyncIterator<Int>>;
  serverSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserInterviewDatumConnection {
  pageInfo: PageInfo;
  edges: UserInterviewDatumEdge[];
}

export interface UserInterviewDatumConnectionPromise
  extends Promise<UserInterviewDatumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserInterviewDatumEdge>>() => T;
  aggregate: <T = AggregateUserInterviewDatumPromise>() => T;
}

export interface UserInterviewDatumConnectionSubscription
  extends Promise<AsyncIterator<UserInterviewDatumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserInterviewDatumEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserInterviewDatumSubscription>() => T;
}

export interface AnswerTypeConnection {
  pageInfo: PageInfo;
  edges: AnswerTypeEdge[];
}

export interface AnswerTypeConnectionPromise
  extends Promise<AnswerTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnswerTypeEdge>>() => T;
  aggregate: <T = AggregateAnswerTypePromise>() => T;
}

export interface AnswerTypeConnectionSubscription
  extends Promise<AsyncIterator<AnswerTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnswerTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnswerTypeSubscription>() => T;
}

export interface UserCoinHistoryEdge {
  node: UserCoinHistory;
  cursor: String;
}

export interface UserCoinHistoryEdgePromise
  extends Promise<UserCoinHistoryEdge>,
    Fragmentable {
  node: <T = UserCoinHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCoinHistoryEdgeSubscription
  extends Promise<AsyncIterator<UserCoinHistoryEdge>>,
    Fragmentable {
  node: <T = UserCoinHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthTokenSubscriptionPayload {
  mutation: MutationType;
  node: AuthToken;
  updatedFields: String[];
  previousValues: AuthTokenPreviousValues;
}

export interface AuthTokenSubscriptionPayloadPromise
  extends Promise<AuthTokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthTokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthTokenPreviousValuesPromise>() => T;
}

export interface AuthTokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthTokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthTokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthTokenPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthTokenPreviousValues {
  user_id: Int;
}

export interface AuthTokenPreviousValuesPromise
  extends Promise<AuthTokenPreviousValues>,
    Fragmentable {
  user_id: () => Promise<Int>;
}

export interface AuthTokenPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthTokenPreviousValues>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserRecordDataByTime {
  row_id: Int;
  changeTime: DateTimeOutput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeOutput;
  volume?: Float;
}

export interface UserRecordDataByTimePromise
  extends Promise<UserRecordDataByTime>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  colorB: () => Promise<Int>;
  colorG: () => Promise<Int>;
  colorR: () => Promise<Int>;
  leakage: () => Promise<String>;
  recordDayRow: <T = UserRecordDataByDayPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  volume: () => Promise<Float>;
}

export interface UserRecordDataByTimeSubscription
  extends Promise<AsyncIterator<UserRecordDataByTime>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  colorB: () => Promise<AsyncIterator<Int>>;
  colorG: () => Promise<AsyncIterator<Int>>;
  colorR: () => Promise<AsyncIterator<Int>>;
  leakage: () => Promise<AsyncIterator<String>>;
  recordDayRow: <T = UserRecordDataByDaySubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface UserRecordDataByTimeNullablePromise
  extends Promise<UserRecordDataByTime | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  colorB: () => Promise<Int>;
  colorG: () => Promise<Int>;
  colorR: () => Promise<Int>;
  leakage: () => Promise<String>;
  recordDayRow: <T = UserRecordDataByDayPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  volume: () => Promise<Float>;
}

export interface PlatformCompEdge {
  node: PlatformComp;
  cursor: String;
}

export interface PlatformCompEdgePromise
  extends Promise<PlatformCompEdge>,
    Fragmentable {
  node: <T = PlatformCompPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlatformCompEdgeSubscription
  extends Promise<AsyncIterator<PlatformCompEdge>>,
    Fragmentable {
  node: <T = PlatformCompSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CalibrationSubscriptionPayload {
  mutation: MutationType;
  node: Calibration;
  updatedFields: String[];
  previousValues: CalibrationPreviousValues;
}

export interface CalibrationSubscriptionPayloadPromise
  extends Promise<CalibrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalibrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalibrationPreviousValuesPromise>() => T;
}

export interface CalibrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalibrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalibrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalibrationPreviousValuesSubscription>() => T;
}

export interface PlatformComp {
  row_id: Int;
  phoneId: Int;
  platformId: Int;
  problemHistory?: Boolean;
  softwareId: Int;
  successHistory?: Boolean;
}

export interface PlatformCompPromise
  extends Promise<PlatformComp>,
    Fragmentable {
  row_id: () => Promise<Int>;
  phoneId: () => Promise<Int>;
  platformId: () => Promise<Int>;
  problemHistory: () => Promise<Boolean>;
  softwareId: () => Promise<Int>;
  successHistory: () => Promise<Boolean>;
}

export interface PlatformCompSubscription
  extends Promise<AsyncIterator<PlatformComp>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  phoneId: () => Promise<AsyncIterator<Int>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  problemHistory: () => Promise<AsyncIterator<Boolean>>;
  softwareId: () => Promise<AsyncIterator<Int>>;
  successHistory: () => Promise<AsyncIterator<Boolean>>;
}

export interface PlatformCompNullablePromise
  extends Promise<PlatformComp | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  phoneId: () => Promise<Int>;
  platformId: () => Promise<Int>;
  problemHistory: () => Promise<Boolean>;
  softwareId: () => Promise<Int>;
  successHistory: () => Promise<Boolean>;
}

export interface CalibrationPreviousValues {
  calib_id: Int;
  calibVersion: String;
}

export interface CalibrationPreviousValuesPromise
  extends Promise<CalibrationPreviousValues>,
    Fragmentable {
  calib_id: () => Promise<Int>;
  calibVersion: () => Promise<String>;
}

export interface CalibrationPreviousValuesSubscription
  extends Promise<AsyncIterator<CalibrationPreviousValues>>,
    Fragmentable {
  calib_id: () => Promise<AsyncIterator<Int>>;
  calibVersion: () => Promise<AsyncIterator<String>>;
}

export interface HardwareEdge {
  node: Hardware;
  cursor: String;
}

export interface HardwareEdgePromise
  extends Promise<HardwareEdge>,
    Fragmentable {
  node: <T = HardwarePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HardwareEdgeSubscription
  extends Promise<AsyncIterator<HardwareEdge>>,
    Fragmentable {
  node: <T = HardwareSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByDay {
  row_id: Int;
  crampsLevel?: Int;
  recordDate: DateTimeOutput;
}

export interface UserRecordDataByDayPromise
  extends Promise<UserRecordDataByDay>,
    Fragmentable {
  row_id: () => Promise<Int>;
  crampsLevel: () => Promise<Int>;
  recordDate: () => Promise<DateTimeOutput>;
  recordPeriodRow: <T = UserRecordDataByPeriodPromise>() => T;
  userRecordDataByTime: <T = FragmentableArray<UserRecordDataByTime>>(args?: {
    where?: UserRecordDataByTimeWhereInput;
    orderBy?: UserRecordDataByTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByDaySubscription
  extends Promise<AsyncIterator<UserRecordDataByDay>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  crampsLevel: () => Promise<AsyncIterator<Int>>;
  recordDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  recordPeriodRow: <T = UserRecordDataByPeriodSubscription>() => T;
  userRecordDataByTime: <
    T = Promise<AsyncIterator<UserRecordDataByTimeSubscription>>
  >(args?: {
    where?: UserRecordDataByTimeWhereInput;
    orderBy?: UserRecordDataByTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByDayNullablePromise
  extends Promise<UserRecordDataByDay | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  crampsLevel: () => Promise<Int>;
  recordDate: () => Promise<DateTimeOutput>;
  recordPeriodRow: <T = UserRecordDataByPeriodPromise>() => T;
  userRecordDataByTime: <T = FragmentableArray<UserRecordDataByTime>>(args?: {
    where?: UserRecordDataByTimeWhereInput;
    orderBy?: UserRecordDataByTimeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateFirmware {
  count: Int;
}

export interface AggregateFirmwarePromise
  extends Promise<AggregateFirmware>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFirmwareSubscription
  extends Promise<AsyncIterator<AggregateFirmware>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface FirmwareConnection {
  pageInfo: PageInfo;
  edges: FirmwareEdge[];
}

export interface FirmwareConnectionPromise
  extends Promise<FirmwareConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FirmwareEdge>>() => T;
  aggregate: <T = AggregateFirmwarePromise>() => T;
}

export interface FirmwareConnectionSubscription
  extends Promise<AsyncIterator<FirmwareConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FirmwareEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFirmwareSubscription>() => T;
}

export interface CompanyPreviousValues {
  company_id: Int;
  companyName: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  company_id: () => Promise<Int>;
  companyName: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  company_id: () => Promise<AsyncIterator<Int>>;
  companyName: () => Promise<AsyncIterator<String>>;
}

export interface EthnicityEdge {
  node: Ethnicity;
  cursor: String;
}

export interface EthnicityEdgePromise
  extends Promise<EthnicityEdge>,
    Fragmentable {
  node: <T = EthnicityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EthnicityEdgeSubscription
  extends Promise<AsyncIterator<EthnicityEdge>>,
    Fragmentable {
  node: <T = EthnicitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByPeriod {
  row_id: Int;
  isTakePill?: Boolean;
  mensFinish: DateTimeOutput;
  mensStart: DateTimeOutput;
}

export interface UserRecordDataByPeriodPromise
  extends Promise<UserRecordDataByPeriod>,
    Fragmentable {
  row_id: () => Promise<Int>;
  coinHistoryRow: <T = UserCoinHistoryPromise>() => T;
  isTakePill: () => Promise<Boolean>;
  mensFinish: () => Promise<DateTimeOutput>;
  mensStart: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  userRecordDataByDay: <T = FragmentableArray<UserRecordDataByDay>>(args?: {
    where?: UserRecordDataByDayWhereInput;
    orderBy?: UserRecordDataByDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByPeriodSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriod>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  coinHistoryRow: <T = UserCoinHistorySubscription>() => T;
  isTakePill: () => Promise<AsyncIterator<Boolean>>;
  mensFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  mensStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
  userRecordDataByDay: <
    T = Promise<AsyncIterator<UserRecordDataByDaySubscription>>
  >(args?: {
    where?: UserRecordDataByDayWhereInput;
    orderBy?: UserRecordDataByDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByPeriodNullablePromise
  extends Promise<UserRecordDataByPeriod | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  coinHistoryRow: <T = UserCoinHistoryPromise>() => T;
  isTakePill: () => Promise<Boolean>;
  mensFinish: () => Promise<DateTimeOutput>;
  mensStart: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
  userRecordDataByDay: <T = FragmentableArray<UserRecordDataByDay>>(args?: {
    where?: UserRecordDataByDayWhereInput;
    orderBy?: UserRecordDataByDayOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByTimePreviousValues {
  row_id: Int;
  changeTime: DateTimeOutput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeOutput;
  volume?: Float;
}

export interface UserRecordDataByTimePreviousValuesPromise
  extends Promise<UserRecordDataByTimePreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  colorB: () => Promise<Int>;
  colorG: () => Promise<Int>;
  colorR: () => Promise<Int>;
  leakage: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  volume: () => Promise<Float>;
}

export interface UserRecordDataByTimePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimePreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  colorB: () => Promise<AsyncIterator<Int>>;
  colorG: () => Promise<AsyncIterator<Int>>;
  colorR: () => Promise<AsyncIterator<Int>>;
  leakage: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface CupDatumEdge {
  node: CupDatum;
  cursor: String;
}

export interface CupDatumEdgePromise
  extends Promise<CupDatumEdge>,
    Fragmentable {
  node: <T = CupDatumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDatumEdgeSubscription
  extends Promise<AsyncIterator<CupDatumEdge>>,
    Fragmentable {
  node: <T = CupDatumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CountryPreviousValues {
  country_id: Int;
  countryName: String;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  country_id: () => Promise<Int>;
  countryName: () => Promise<String>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  country_id: () => Promise<AsyncIterator<Int>>;
  countryName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDataUserRemoveExplain {
  count: Int;
}

export interface AggregateCupDataUserRemoveExplainPromise
  extends Promise<AggregateCupDataUserRemoveExplain>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataUserRemoveExplainSubscription
  extends Promise<AsyncIterator<AggregateCupDataUserRemoveExplain>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCoinHistory {
  row_id: Int;
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeOutput;
  txhash: String;
}

export interface UserCoinHistoryPromise
  extends Promise<UserCoinHistory>,
    Fragmentable {
  row_id: () => Promise<Int>;
  category: () => Promise<String>;
  coin: () => Promise<Int>;
  contents: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  txhash: () => Promise<String>;
  user: <T = UserPromise>() => T;
  userRecordDataByPeriod: <
    T = FragmentableArray<UserRecordDataByPeriod>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserCoinHistorySubscription
  extends Promise<AsyncIterator<UserCoinHistory>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  coin: () => Promise<AsyncIterator<Int>>;
  contents: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  txhash: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
  userRecordDataByPeriod: <
    T = Promise<AsyncIterator<UserRecordDataByPeriodSubscription>>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserCoinHistoryNullablePromise
  extends Promise<UserCoinHistory | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  category: () => Promise<String>;
  coin: () => Promise<Int>;
  contents: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  txhash: () => Promise<String>;
  user: <T = UserPromise>() => T;
  userRecordDataByPeriod: <
    T = FragmentableArray<UserRecordDataByPeriod>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CupDataUserRemoveExplainConnection {
  pageInfo: PageInfo;
  edges: CupDataUserRemoveExplainEdge[];
}

export interface CupDataUserRemoveExplainConnectionPromise
  extends Promise<CupDataUserRemoveExplainConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataUserRemoveExplainEdge>>() => T;
  aggregate: <T = AggregateCupDataUserRemoveExplainPromise>() => T;
}

export interface CupDataUserRemoveExplainConnectionSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CupDataUserRemoveExplainEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCupDataUserRemoveExplainSubscription>() => T;
}

export interface CupSubscriptionPayload {
  mutation: MutationType;
  node: Cup;
  updatedFields: String[];
  previousValues: CupPreviousValues;
}

export interface CupSubscriptionPayloadPromise
  extends Promise<CupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupPreviousValuesPromise>() => T;
}

export interface CupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataUserRemove {
  count: Int;
}

export interface AggregateCupDataUserRemovePromise
  extends Promise<AggregateCupDataUserRemove>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataUserRemoveSubscription
  extends Promise<AsyncIterator<AggregateCupDataUserRemove>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupPreviousValues {
  serial_number: Int;
  anonSerialNumber: Int;
  encryptionKey: Int;
}

export interface CupPreviousValuesPromise
  extends Promise<CupPreviousValues>,
    Fragmentable {
  serial_number: () => Promise<Int>;
  anonSerialNumber: () => Promise<Int>;
  encryptionKey: () => Promise<Int>;
}

export interface CupPreviousValuesSubscription
  extends Promise<AsyncIterator<CupPreviousValues>>,
    Fragmentable {
  serial_number: () => Promise<AsyncIterator<Int>>;
  anonSerialNumber: () => Promise<AsyncIterator<Int>>;
  encryptionKey: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataUserRemoveConnection {
  pageInfo: PageInfo;
  edges: CupDataUserRemoveEdge[];
}

export interface CupDataUserRemoveConnectionPromise
  extends Promise<CupDataUserRemoveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataUserRemoveEdge>>() => T;
  aggregate: <T = AggregateCupDataUserRemovePromise>() => T;
}

export interface CupDataUserRemoveConnectionSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataUserRemoveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataUserRemoveSubscription>() => T;
}

export interface Ethnicity {
  ethnicity_id: Int;
  ethnicity: String;
}

export interface EthnicityPromise extends Promise<Ethnicity>, Fragmentable {
  ethnicity_id: () => Promise<Int>;
  ethnicity: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EthnicitySubscription
  extends Promise<AsyncIterator<Ethnicity>>,
    Fragmentable {
  ethnicity_id: () => Promise<AsyncIterator<Int>>;
  ethnicity: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EthnicityNullablePromise
  extends Promise<Ethnicity | null>,
    Fragmentable {
  ethnicity_id: () => Promise<Int>;
  ethnicity: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CupDataRejectionEdge {
  node: CupDataRejection;
  cursor: String;
}

export interface CupDataRejectionEdgePromise
  extends Promise<CupDataRejectionEdge>,
    Fragmentable {
  node: <T = CupDataRejectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataRejectionEdgeSubscription
  extends Promise<AsyncIterator<CupDataRejectionEdge>>,
    Fragmentable {
  node: <T = CupDataRejectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupAppSyncSubscriptionPayload {
  mutation: MutationType;
  node: CupAppSync;
  updatedFields: String[];
  previousValues: CupAppSyncPreviousValues;
}

export interface CupAppSyncSubscriptionPayloadPromise
  extends Promise<CupAppSyncSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupAppSyncPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupAppSyncPreviousValuesPromise>() => T;
}

export interface CupAppSyncSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupAppSyncSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupAppSyncSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupAppSyncPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataRaw {
  count: Int;
}

export interface AggregateCupDataRawPromise
  extends Promise<AggregateCupDataRaw>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataRawSubscription
  extends Promise<AsyncIterator<AggregateCupDataRaw>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupAppSyncPreviousValues {
  cup_app_sync_id: Int;
  appSynchTime: DateTimeOutput;
}

export interface CupAppSyncPreviousValuesPromise
  extends Promise<CupAppSyncPreviousValues>,
    Fragmentable {
  cup_app_sync_id: () => Promise<Int>;
  appSynchTime: () => Promise<DateTimeOutput>;
}

export interface CupAppSyncPreviousValuesSubscription
  extends Promise<AsyncIterator<CupAppSyncPreviousValues>>,
    Fragmentable {
  cup_app_sync_id: () => Promise<AsyncIterator<Int>>;
  appSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataRawConnection {
  pageInfo: PageInfo;
  edges: CupDataRawEdge[];
}

export interface CupDataRawConnectionPromise
  extends Promise<CupDataRawConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataRawEdge>>() => T;
  aggregate: <T = AggregateCupDataRawPromise>() => T;
}

export interface CupDataRawConnectionSubscription
  extends Promise<AsyncIterator<CupDataRawConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataRawEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataRawSubscription>() => T;
}

export interface UserCup {
  row_id: Int;
}

export interface UserCupPromise extends Promise<UserCup>, Fragmentable {
  row_id: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserCupSubscription
  extends Promise<AsyncIterator<UserCup>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface UserCupNullablePromise
  extends Promise<UserCup | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CupDataQuestionEdge {
  node: CupDataQuestion;
  cursor: String;
}

export interface CupDataQuestionEdgePromise
  extends Promise<CupDataQuestionEdge>,
    Fragmentable {
  node: <T = CupDataQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataQuestionEdgeSubscription
  extends Promise<AsyncIterator<CupDataQuestionEdge>>,
    Fragmentable {
  node: <T = CupDataQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataAnswerSubscriptionPayload {
  mutation: MutationType;
  node: CupDataAnswer;
  updatedFields: String[];
  previousValues: CupDataAnswerPreviousValues;
}

export interface CupDataAnswerSubscriptionPayloadPromise
  extends Promise<CupDataAnswerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataAnswerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataAnswerPreviousValuesPromise>() => T;
}

export interface CupDataAnswerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataAnswerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataAnswerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataAnswerPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataQaResponse {
  count: Int;
}

export interface AggregateCupDataQaResponsePromise
  extends Promise<AggregateCupDataQaResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataQaResponseSubscription
  extends Promise<AsyncIterator<AggregateCupDataQaResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataAnswerPreviousValues {
  answer_id: Int;
  answerText: String;
}

export interface CupDataAnswerPreviousValuesPromise
  extends Promise<CupDataAnswerPreviousValues>,
    Fragmentable {
  answer_id: () => Promise<Int>;
  answerText: () => Promise<String>;
}

export interface CupDataAnswerPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataAnswerPreviousValues>>,
    Fragmentable {
  answer_id: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQaResponseConnection {
  pageInfo: PageInfo;
  edges: CupDataQaResponseEdge[];
}

export interface CupDataQaResponseConnectionPromise
  extends Promise<CupDataQaResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataQaResponseEdge>>() => T;
  aggregate: <T = AggregateCupDataQaResponsePromise>() => T;
}

export interface CupDataQaResponseConnectionSubscription
  extends Promise<AsyncIterator<CupDataQaResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataQaResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataQaResponseSubscription>() => T;
}

export interface Hardware {
  hw_id: Int;
  hwVersion: String;
}

export interface HardwarePromise extends Promise<Hardware>, Fragmentable {
  hw_id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hwVersion: () => Promise<String>;
}

export interface HardwareSubscription
  extends Promise<AsyncIterator<Hardware>>,
    Fragmentable {
  hw_id: () => Promise<AsyncIterator<Int>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hwVersion: () => Promise<AsyncIterator<String>>;
}

export interface HardwareNullablePromise
  extends Promise<Hardware | null>,
    Fragmentable {
  hw_id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hwVersion: () => Promise<String>;
}

export interface CupDataProcVolumeEdge {
  node: CupDataProcVolume;
  cursor: String;
}

export interface CupDataProcVolumeEdgePromise
  extends Promise<CupDataProcVolumeEdge>,
    Fragmentable {
  node: <T = CupDataProcVolumePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcVolumeEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeEdge>>,
    Fragmentable {
  node: <T = CupDataProcVolumeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataColourCalcSubscriptionPayload {
  mutation: MutationType;
  node: CupDataColourCalc;
  updatedFields: String[];
  previousValues: CupDataColourCalcPreviousValues;
}

export interface CupDataColourCalcSubscriptionPayloadPromise
  extends Promise<CupDataColourCalcSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataColourCalcPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataColourCalcPreviousValuesPromise>() => T;
}

export interface CupDataColourCalcSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataColourCalcSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataColourCalcSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataColourCalcPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataProcMdate {
  count: Int;
}

export interface AggregateCupDataProcMdatePromise
  extends Promise<AggregateCupDataProcMdate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcMdateSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcMdate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalcPreviousValues {
  row_id: Int;
  blue: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalcPreviousValuesPromise
  extends Promise<CupDataColourCalcPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalcPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataColourCalcPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcMdateConnection {
  pageInfo: PageInfo;
  edges: CupDataProcMdateEdge[];
}

export interface CupDataProcMdateConnectionPromise
  extends Promise<CupDataProcMdateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcMdateEdge>>() => T;
  aggregate: <T = AggregateCupDataProcMdatePromise>() => T;
}

export interface CupDataProcMdateConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcMdateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcMdateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcMdateSubscription>() => T;
}

export interface Firmware {
  fw_id: Int;
  fwVersion: String;
}

export interface FirmwarePromise extends Promise<Firmware>, Fragmentable {
  fw_id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fwVersion: () => Promise<String>;
}

export interface FirmwareSubscription
  extends Promise<AsyncIterator<Firmware>>,
    Fragmentable {
  fw_id: () => Promise<AsyncIterator<Int>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fwVersion: () => Promise<AsyncIterator<String>>;
}

export interface FirmwareNullablePromise
  extends Promise<Firmware | null>,
    Fragmentable {
  fw_id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  fwVersion: () => Promise<String>;
}

export interface CupDataProcFlowEdge {
  node: CupDataProcFlow;
  cursor: String;
}

export interface CupDataProcFlowEdgePromise
  extends Promise<CupDataProcFlowEdge>,
    Fragmentable {
  node: <T = CupDataProcFlowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcFlowEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcFlowEdge>>,
    Fragmentable {
  node: <T = CupDataProcFlowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataColourCalibSubscriptionPayload {
  mutation: MutationType;
  node: CupDataColourCalib;
  updatedFields: String[];
  previousValues: CupDataColourCalibPreviousValues;
}

export interface CupDataColourCalibSubscriptionPayloadPromise
  extends Promise<CupDataColourCalibSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataColourCalibPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataColourCalibPreviousValuesPromise>() => T;
}

export interface CupDataColourCalibSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataColourCalibSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataColourCalibSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataColourCalibPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataManMdate {
  count: Int;
}

export interface AggregateCupDataManMdatePromise
  extends Promise<AggregateCupDataManMdate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataManMdateSubscription
  extends Promise<AsyncIterator<AggregateCupDataManMdate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalibPreviousValues {
  cup_data_colour_calib_id: Int;
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalibPreviousValuesPromise
  extends Promise<CupDataColourCalibPreviousValues>,
    Fragmentable {
  cup_data_colour_calib_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  c: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalibPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataColourCalibPreviousValues>>,
    Fragmentable {
  cup_data_colour_calib_id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  c: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataManMdateConnection {
  pageInfo: PageInfo;
  edges: CupDataManMdateEdge[];
}

export interface CupDataManMdateConnectionPromise
  extends Promise<CupDataManMdateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataManMdateEdge>>() => T;
  aggregate: <T = AggregateCupDataManMdatePromise>() => T;
}

export interface CupDataManMdateConnectionSubscription
  extends Promise<AsyncIterator<CupDataManMdateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataManMdateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataManMdateSubscription>() => T;
}

export interface CupDataRaw {
  row_id: Int;
  pageData: String;
}

export interface CupDataRawPromise extends Promise<CupDataRaw>, Fragmentable {
  row_id: () => Promise<Int>;
  pageData: () => Promise<String>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataRawSubscription
  extends Promise<AsyncIterator<CupDataRaw>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  pageData: () => Promise<AsyncIterator<String>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface CupDataRawNullablePromise
  extends Promise<CupDataRaw | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  pageData: () => Promise<String>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataColourCalibEdge {
  node: CupDataColourCalib;
  cursor: String;
}

export interface CupDataColourCalibEdgePromise
  extends Promise<CupDataColourCalibEdge>,
    Fragmentable {
  node: <T = CupDataColourCalibPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataColourCalibEdgeSubscription
  extends Promise<AsyncIterator<CupDataColourCalibEdge>>,
    Fragmentable {
  node: <T = CupDataColourCalibSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataManMdateSubscriptionPayload {
  mutation: MutationType;
  node: CupDataManMdate;
  updatedFields: String[];
  previousValues: CupDataManMdatePreviousValues;
}

export interface CupDataManMdateSubscriptionPayloadPromise
  extends Promise<CupDataManMdateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataManMdatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataManMdatePreviousValuesPromise>() => T;
}

export interface CupDataManMdateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataManMdateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataManMdateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataManMdatePreviousValuesSubscription>() => T;
}

export interface AggregateCupDataColourCalc {
  count: Int;
}

export interface AggregateCupDataColourCalcPromise
  extends Promise<AggregateCupDataColourCalc>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataColourCalcSubscription
  extends Promise<AsyncIterator<AggregateCupDataColourCalc>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataManMdatePreviousValues {
  row_id: Int;
  menFinish?: DateTimeOutput;
  menStart?: DateTimeOutput;
}

export interface CupDataManMdatePreviousValuesPromise
  extends Promise<CupDataManMdatePreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
}

export interface CupDataManMdatePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataManMdatePreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataColourCalcConnection {
  pageInfo: PageInfo;
  edges: CupDataColourCalcEdge[];
}

export interface CupDataColourCalcConnectionPromise
  extends Promise<CupDataColourCalcConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataColourCalcEdge>>() => T;
  aggregate: <T = AggregateCupDataColourCalcPromise>() => T;
}

export interface CupDataColourCalcConnectionSubscription
  extends Promise<AsyncIterator<CupDataColourCalcConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataColourCalcEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataColourCalcSubscription>() => T;
}

export interface CupDataColourCalib {
  cup_data_colour_calib_id: Int;
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalibPromise
  extends Promise<CupDataColourCalib>,
    Fragmentable {
  cup_data_colour_calib_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  c: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataColourCalibSubscription
  extends Promise<AsyncIterator<CupDataColourCalib>>,
    Fragmentable {
  cup_data_colour_calib_id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  c: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface CupDataColourCalibNullablePromise
  extends Promise<CupDataColourCalib | null>,
    Fragmentable {
  cup_data_colour_calib_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  c: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataAnswerEdge {
  node: CupDataAnswer;
  cursor: String;
}

export interface CupDataAnswerEdgePromise
  extends Promise<CupDataAnswerEdge>,
    Fragmentable {
  node: <T = CupDataAnswerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataAnswerEdgeSubscription
  extends Promise<AsyncIterator<CupDataAnswerEdge>>,
    Fragmentable {
  node: <T = CupDataAnswerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcFlowSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcFlow;
  updatedFields: String[];
  previousValues: CupDataProcFlowPreviousValues;
}

export interface CupDataProcFlowSubscriptionPayloadPromise
  extends Promise<CupDataProcFlowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcFlowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcFlowPreviousValuesPromise>() => T;
}

export interface CupDataProcFlowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcFlowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcFlowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcFlowPreviousValuesSubscription>() => T;
}

export interface AggregateCupAppSync {
  count: Int;
}

export interface AggregateCupAppSyncPromise
  extends Promise<AggregateCupAppSync>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupAppSyncSubscription
  extends Promise<AsyncIterator<AggregateCupAppSync>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcFlowPreviousValues {
  row_id: Int;
  date: DateTimeOutput;
  hourlyFlow: Int;
}

export interface CupDataProcFlowPreviousValuesPromise
  extends Promise<CupDataProcFlowPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  hourlyFlow: () => Promise<Int>;
}

export interface CupDataProcFlowPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcFlowPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  hourlyFlow: () => Promise<AsyncIterator<Int>>;
}

export interface CupAppSyncConnection {
  pageInfo: PageInfo;
  edges: CupAppSyncEdge[];
}

export interface CupAppSyncConnectionPromise
  extends Promise<CupAppSyncConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupAppSyncEdge>>() => T;
  aggregate: <T = AggregateCupAppSyncPromise>() => T;
}

export interface CupAppSyncConnectionSubscription
  extends Promise<AsyncIterator<CupAppSyncConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupAppSyncEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupAppSyncSubscription>() => T;
}

export interface CupDataProcVolume {
  row_id: Int;
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface CupDataProcVolumePromise
  extends Promise<CupDataProcVolume>,
    Fragmentable {
  row_id: () => Promise<Int>;
  confidenceL: () => Promise<Int>;
  confidenceR: () => Promise<Int>;
  cupDataRow: <T = CupDatumPromise>() => T;
  inVitro: () => Promise<Boolean>;
  volume: () => Promise<Int>;
  volumeAdj: () => Promise<Int>;
  volumeL: () => Promise<Int>;
  volumeR: () => Promise<Int>;
}

export interface CupDataProcVolumeSubscription
  extends Promise<AsyncIterator<CupDataProcVolume>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  confidenceL: () => Promise<AsyncIterator<Int>>;
  confidenceR: () => Promise<AsyncIterator<Int>>;
  cupDataRow: <T = CupDatumSubscription>() => T;
  inVitro: () => Promise<AsyncIterator<Boolean>>;
  volume: () => Promise<AsyncIterator<Int>>;
  volumeAdj: () => Promise<AsyncIterator<Int>>;
  volumeL: () => Promise<AsyncIterator<Int>>;
  volumeR: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcVolumeNullablePromise
  extends Promise<CupDataProcVolume | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  confidenceL: () => Promise<Int>;
  confidenceR: () => Promise<Int>;
  cupDataRow: <T = CupDatumPromise>() => T;
  inVitro: () => Promise<Boolean>;
  volume: () => Promise<Int>;
  volumeAdj: () => Promise<Int>;
  volumeL: () => Promise<Int>;
  volumeR: () => Promise<Int>;
}

export interface CupEdge {
  node: Cup;
  cursor: String;
}

export interface CupEdgePromise extends Promise<CupEdge>, Fragmentable {
  node: <T = CupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupEdgeSubscription
  extends Promise<AsyncIterator<CupEdge>>,
    Fragmentable {
  node: <T = CupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcMdateSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcMdate;
  updatedFields: String[];
  previousValues: CupDataProcMdatePreviousValues;
}

export interface CupDataProcMdateSubscriptionPayloadPromise
  extends Promise<CupDataProcMdateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcMdatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcMdatePreviousValuesPromise>() => T;
}

export interface CupDataProcMdateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcMdateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcMdateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcMdatePreviousValuesSubscription>() => T;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcMdatePreviousValues {
  mdate_row_id: Int;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeOutput;
  menStart: DateTimeOutput;
  rewardAmount?: Int;
}

export interface CupDataProcMdatePreviousValuesPromise
  extends Promise<CupDataProcMdatePreviousValues>,
    Fragmentable {
  mdate_row_id: () => Promise<Int>;
  dataRejected: () => Promise<Boolean>;
  dataVerified: () => Promise<Boolean>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
  rewardAmount: () => Promise<Int>;
}

export interface CupDataProcMdatePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcMdatePreviousValues>>,
    Fragmentable {
  mdate_row_id: () => Promise<AsyncIterator<Int>>;
  dataRejected: () => Promise<AsyncIterator<Boolean>>;
  dataVerified: () => Promise<AsyncIterator<Boolean>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  rewardAmount: () => Promise<AsyncIterator<Int>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

export interface CupDataColourCalc {
  row_id: Int;
  blue: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalcPromise
  extends Promise<CupDataColourCalc>,
    Fragmentable {
  row_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  cupDataRow: <T = CupDatumPromise>() => T;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalcSubscription
  extends Promise<AsyncIterator<CupDataColourCalc>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  cupDataRow: <T = CupDatumSubscription>() => T;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalcNullablePromise
  extends Promise<CupDataColourCalc | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  blue: () => Promise<Int>;
  cupDataRow: <T = CupDatumPromise>() => T;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcVolumeSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcVolume;
  updatedFields: String[];
  previousValues: CupDataProcVolumePreviousValues;
}

export interface CupDataProcVolumeSubscriptionPayloadPromise
  extends Promise<CupDataProcVolumeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcVolumePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcVolumePreviousValuesPromise>() => T;
}

export interface CupDataProcVolumeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcVolumeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcVolumePreviousValuesSubscription>() => T;
}

export interface AggregateCalibration {
  count: Int;
}

export interface AggregateCalibrationPromise
  extends Promise<AggregateCalibration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalibrationSubscription
  extends Promise<AsyncIterator<AggregateCalibration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcVolumePreviousValues {
  row_id: Int;
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface CupDataProcVolumePreviousValuesPromise
  extends Promise<CupDataProcVolumePreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  confidenceL: () => Promise<Int>;
  confidenceR: () => Promise<Int>;
  inVitro: () => Promise<Boolean>;
  volume: () => Promise<Int>;
  volumeAdj: () => Promise<Int>;
  volumeL: () => Promise<Int>;
  volumeR: () => Promise<Int>;
}

export interface CupDataProcVolumePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcVolumePreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  confidenceL: () => Promise<AsyncIterator<Int>>;
  confidenceR: () => Promise<AsyncIterator<Int>>;
  inVitro: () => Promise<AsyncIterator<Boolean>>;
  volume: () => Promise<AsyncIterator<Int>>;
  volumeAdj: () => Promise<AsyncIterator<Int>>;
  volumeL: () => Promise<AsyncIterator<Int>>;
  volumeR: () => Promise<AsyncIterator<Int>>;
}

export interface CalibrationConnection {
  pageInfo: PageInfo;
  edges: CalibrationEdge[];
}

export interface CalibrationConnectionPromise
  extends Promise<CalibrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CalibrationEdge>>() => T;
  aggregate: <T = AggregateCalibrationPromise>() => T;
}

export interface CalibrationConnectionSubscription
  extends Promise<AsyncIterator<CalibrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalibrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalibrationSubscription>() => T;
}

export interface CupDatum {
  row_id: Int;
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  date: DateTimeOutput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDatumPromise extends Promise<CupDatum>, Fragmentable {
  row_id: () => Promise<Int>;
  battery: () => Promise<Int>;
  calibFlag: () => Promise<Boolean>;
  ch1: () => Promise<Int>;
  ch10: () => Promise<Int>;
  ch11: () => Promise<Int>;
  ch12: () => Promise<Int>;
  ch13: () => Promise<Int>;
  ch14: () => Promise<Int>;
  ch2: () => Promise<Int>;
  ch3: () => Promise<Int>;
  ch4: () => Promise<Int>;
  ch5: () => Promise<Int>;
  ch6: () => Promise<Int>;
  ch7: () => Promise<Int>;
  ch8: () => Promise<Int>;
  ch9: () => Promise<Int>;
  colourB: () => Promise<Int>;
  colourC: () => Promise<Int>;
  colourG: () => Promise<Int>;
  colourR: () => Promise<Int>;
  cupDataColourCalc: <T = FragmentableArray<CupDataColourCalc>>(args?: {
    where?: CupDataColourCalcWhereInput;
    orderBy?: CupDataColourCalcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcVolume: <T = FragmentableArray<CupDataProcVolume>>(args?: {
    where?: CupDataProcVolumeWhereInput;
    orderBy?: CupDataProcVolumeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
  day: () => Promise<Int>;
  hour: () => Promise<Int>;
  line: () => Promise<Int>;
  minute: () => Promise<Int>;
  month: () => Promise<Int>;
  page: () => Promise<Int>;
  rawTotalVolume: () => Promise<Int>;
  rawVolumeL: () => Promise<Int>;
  rawVolumeR: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  temperature: () => Promise<Int>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  year: () => Promise<Int>;
  z: () => Promise<Int>;
}

export interface CupDatumSubscription
  extends Promise<AsyncIterator<CupDatum>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  battery: () => Promise<AsyncIterator<Int>>;
  calibFlag: () => Promise<AsyncIterator<Boolean>>;
  ch1: () => Promise<AsyncIterator<Int>>;
  ch10: () => Promise<AsyncIterator<Int>>;
  ch11: () => Promise<AsyncIterator<Int>>;
  ch12: () => Promise<AsyncIterator<Int>>;
  ch13: () => Promise<AsyncIterator<Int>>;
  ch14: () => Promise<AsyncIterator<Int>>;
  ch2: () => Promise<AsyncIterator<Int>>;
  ch3: () => Promise<AsyncIterator<Int>>;
  ch4: () => Promise<AsyncIterator<Int>>;
  ch5: () => Promise<AsyncIterator<Int>>;
  ch6: () => Promise<AsyncIterator<Int>>;
  ch7: () => Promise<AsyncIterator<Int>>;
  ch8: () => Promise<AsyncIterator<Int>>;
  ch9: () => Promise<AsyncIterator<Int>>;
  colourB: () => Promise<AsyncIterator<Int>>;
  colourC: () => Promise<AsyncIterator<Int>>;
  colourG: () => Promise<AsyncIterator<Int>>;
  colourR: () => Promise<AsyncIterator<Int>>;
  cupDataColourCalc: <
    T = Promise<AsyncIterator<CupDataColourCalcSubscription>>
  >(args?: {
    where?: CupDataColourCalcWhereInput;
    orderBy?: CupDataColourCalcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcVolume: <
    T = Promise<AsyncIterator<CupDataProcVolumeSubscription>>
  >(args?: {
    where?: CupDataProcVolumeWhereInput;
    orderBy?: CupDataProcVolumeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  day: () => Promise<AsyncIterator<Int>>;
  hour: () => Promise<AsyncIterator<Int>>;
  line: () => Promise<AsyncIterator<Int>>;
  minute: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  page: () => Promise<AsyncIterator<Int>>;
  rawTotalVolume: () => Promise<AsyncIterator<Int>>;
  rawVolumeL: () => Promise<AsyncIterator<Int>>;
  rawVolumeR: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
  temperature: () => Promise<AsyncIterator<Int>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
}

export interface CupDatumNullablePromise
  extends Promise<CupDatum | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  battery: () => Promise<Int>;
  calibFlag: () => Promise<Boolean>;
  ch1: () => Promise<Int>;
  ch10: () => Promise<Int>;
  ch11: () => Promise<Int>;
  ch12: () => Promise<Int>;
  ch13: () => Promise<Int>;
  ch14: () => Promise<Int>;
  ch2: () => Promise<Int>;
  ch3: () => Promise<Int>;
  ch4: () => Promise<Int>;
  ch5: () => Promise<Int>;
  ch6: () => Promise<Int>;
  ch7: () => Promise<Int>;
  ch8: () => Promise<Int>;
  ch9: () => Promise<Int>;
  colourB: () => Promise<Int>;
  colourC: () => Promise<Int>;
  colourG: () => Promise<Int>;
  colourR: () => Promise<Int>;
  cupDataColourCalc: <T = FragmentableArray<CupDataColourCalc>>(args?: {
    where?: CupDataColourCalcWhereInput;
    orderBy?: CupDataColourCalcOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcVolume: <T = FragmentableArray<CupDataProcVolume>>(args?: {
    where?: CupDataProcVolumeWhereInput;
    orderBy?: CupDataProcVolumeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
  day: () => Promise<Int>;
  hour: () => Promise<Int>;
  line: () => Promise<Int>;
  minute: () => Promise<Int>;
  month: () => Promise<Int>;
  page: () => Promise<Int>;
  rawTotalVolume: () => Promise<Int>;
  rawVolumeL: () => Promise<Int>;
  rawVolumeR: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  temperature: () => Promise<Int>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  year: () => Promise<Int>;
  z: () => Promise<Int>;
}

export interface AuthTokenEdge {
  node: AuthToken;
  cursor: String;
}

export interface AuthTokenEdgePromise
  extends Promise<AuthTokenEdge>,
    Fragmentable {
  node: <T = AuthTokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthTokenEdgeSubscription
  extends Promise<AsyncIterator<AuthTokenEdge>>,
    Fragmentable {
  node: <T = AuthTokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQaResponseSubscriptionPayload {
  mutation: MutationType;
  node: CupDataQaResponse;
  updatedFields: String[];
  previousValues: CupDataQaResponsePreviousValues;
}

export interface CupDataQaResponseSubscriptionPayloadPromise
  extends Promise<CupDataQaResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataQaResponsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataQaResponsePreviousValuesPromise>() => T;
}

export interface CupDataQaResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataQaResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataQaResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataQaResponsePreviousValuesSubscription>() => T;
}

export interface AggregateUsersDataAnalysis {
  count: Int;
}

export interface AggregateUsersDataAnalysisPromise
  extends Promise<AggregateUsersDataAnalysis>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUsersDataAnalysisSubscription
  extends Promise<AsyncIterator<AggregateUsersDataAnalysis>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataQaResponsePreviousValues {
  cup_data_qa_response_id: Int;
  qaDate: DateTimeOutput;
}

export interface CupDataQaResponsePreviousValuesPromise
  extends Promise<CupDataQaResponsePreviousValues>,
    Fragmentable {
  cup_data_qa_response_id: () => Promise<Int>;
  qaDate: () => Promise<DateTimeOutput>;
}

export interface CupDataQaResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataQaResponsePreviousValues>>,
    Fragmentable {
  cup_data_qa_response_id: () => Promise<AsyncIterator<Int>>;
  qaDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UsersDataAnalysis {
  idx: Int;
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface UsersDataAnalysisPromise
  extends Promise<UsersDataAnalysis>,
    Fragmentable {
  idx: () => Promise<Int>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface UsersDataAnalysisSubscription
  extends Promise<AsyncIterator<UsersDataAnalysis>>,
    Fragmentable {
  idx: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface UsersDataAnalysisNullablePromise
  extends Promise<UsersDataAnalysis | null>,
    Fragmentable {
  idx: () => Promise<Int>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface CupAppSync {
  cup_app_sync_id: Int;
  appSynchTime: DateTimeOutput;
}

export interface CupAppSyncPromise extends Promise<CupAppSync>, Fragmentable {
  cup_app_sync_id: () => Promise<Int>;
  appSynchTime: () => Promise<DateTimeOutput>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupAppSyncSubscription
  extends Promise<AsyncIterator<CupAppSync>>,
    Fragmentable {
  cup_app_sync_id: () => Promise<AsyncIterator<Int>>;
  appSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface CupAppSyncNullablePromise
  extends Promise<CupAppSync | null>,
    Fragmentable {
  cup_app_sync_id: () => Promise<Int>;
  appSynchTime: () => Promise<DateTimeOutput>;
  serialNumber: <T = CupPromise>() => T;
}

export interface AggregateUserRecordDataByPeriod {
  count: Int;
}

export interface AggregateUserRecordDataByPeriodPromise
  extends Promise<AggregateUserRecordDataByPeriod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByPeriodSubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByPeriod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataQuestionSubscriptionPayload {
  mutation: MutationType;
  node: CupDataQuestion;
  updatedFields: String[];
  previousValues: CupDataQuestionPreviousValues;
}

export interface CupDataQuestionSubscriptionPayloadPromise
  extends Promise<CupDataQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataQuestionPreviousValuesPromise>() => T;
}

export interface CupDataQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataQuestionPreviousValuesSubscription>() => T;
}

export interface UserRecordDataByDayEdge {
  node: UserRecordDataByDay;
  cursor: String;
}

export interface UserRecordDataByDayEdgePromise
  extends Promise<UserRecordDataByDayEdge>,
    Fragmentable {
  node: <T = UserRecordDataByDayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByDayEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByDaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestionPreviousValues {
  question_id: Int;
  questionText: String;
}

export interface CupDataQuestionPreviousValuesPromise
  extends Promise<CupDataQuestionPreviousValues>,
    Fragmentable {
  question_id: () => Promise<Int>;
  questionText: () => Promise<String>;
}

export interface CupDataQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataQuestionPreviousValues>>,
    Fragmentable {
  question_id: () => Promise<AsyncIterator<Int>>;
  questionText: () => Promise<AsyncIterator<String>>;
}

export interface UserInterviewQuestionConnection {
  pageInfo: PageInfo;
  edges: UserInterviewQuestionEdge[];
}

export interface UserInterviewQuestionConnectionPromise
  extends Promise<UserInterviewQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserInterviewQuestionEdge>>() => T;
  aggregate: <T = AggregateUserInterviewQuestionPromise>() => T;
}

export interface UserInterviewQuestionConnectionSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserInterviewQuestionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserInterviewQuestionSubscription>() => T;
}

export interface Company {
  company_id: Int;
  companyName: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  company_id: () => Promise<Int>;
  companyName: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  company_id: () => Promise<AsyncIterator<Int>>;
  companyName: () => Promise<AsyncIterator<String>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  company_id: () => Promise<Int>;
  companyName: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateUserCoinHistory {
  count: Int;
}

export interface AggregateUserCoinHistoryPromise
  extends Promise<AggregateUserCoinHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCoinHistorySubscription
  extends Promise<AsyncIterator<AggregateUserCoinHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataRawSubscriptionPayload {
  mutation: MutationType;
  node: CupDataRaw;
  updatedFields: String[];
  previousValues: CupDataRawPreviousValues;
}

export interface CupDataRawSubscriptionPayloadPromise
  extends Promise<CupDataRawSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataRawPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataRawPreviousValuesPromise>() => T;
}

export interface CupDataRawSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataRawSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataRawSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataRawPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataRawPreviousValues {
  row_id: Int;
  pageData: String;
}

export interface CupDataRawPreviousValuesPromise
  extends Promise<CupDataRawPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  pageData: () => Promise<String>;
}

export interface CupDataRawPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataRawPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  pageData: () => Promise<AsyncIterator<String>>;
}

export interface PlatformCompConnection {
  pageInfo: PageInfo;
  edges: PlatformCompEdge[];
}

export interface PlatformCompConnectionPromise
  extends Promise<PlatformCompConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlatformCompEdge>>() => T;
  aggregate: <T = AggregatePlatformCompPromise>() => T;
}

export interface PlatformCompConnectionSubscription
  extends Promise<AsyncIterator<PlatformCompConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlatformCompEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlatformCompSubscription>() => T;
}

export interface Calibration {
  calib_id: Int;
  calibVersion: String;
}

export interface CalibrationPromise extends Promise<Calibration>, Fragmentable {
  calib_id: () => Promise<Int>;
  calibVersion: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CalibrationSubscription
  extends Promise<AsyncIterator<Calibration>>,
    Fragmentable {
  calib_id: () => Promise<AsyncIterator<Int>>;
  calibVersion: () => Promise<AsyncIterator<String>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CalibrationNullablePromise
  extends Promise<Calibration | null>,
    Fragmentable {
  calib_id: () => Promise<Int>;
  calibVersion: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(args?: {
    where?: CupWhereInput;
    orderBy?: CupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface HardwareConnection {
  pageInfo: PageInfo;
  edges: HardwareEdge[];
}

export interface HardwareConnectionPromise
  extends Promise<HardwareConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HardwareEdge>>() => T;
  aggregate: <T = AggregateHardwarePromise>() => T;
}

export interface HardwareConnectionSubscription
  extends Promise<AsyncIterator<HardwareConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HardwareEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHardwareSubscription>() => T;
}

export interface CupDataRejectionSubscriptionPayload {
  mutation: MutationType;
  node: CupDataRejection;
  updatedFields: String[];
  previousValues: CupDataRejectionPreviousValues;
}

export interface CupDataRejectionSubscriptionPayloadPromise
  extends Promise<CupDataRejectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataRejectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataRejectionPreviousValuesPromise>() => T;
}

export interface CupDataRejectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataRejectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataRejectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataRejectionPreviousValuesSubscription>() => T;
}

export interface AggregateEthnicity {
  count: Int;
}

export interface AggregateEthnicityPromise
  extends Promise<AggregateEthnicity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEthnicitySubscription
  extends Promise<AsyncIterator<AggregateEthnicity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataRejectionPreviousValues {
  reject_id: Int;
  rejectionDescription: String;
}

export interface CupDataRejectionPreviousValuesPromise
  extends Promise<CupDataRejectionPreviousValues>,
    Fragmentable {
  reject_id: () => Promise<Int>;
  rejectionDescription: () => Promise<String>;
}

export interface CupDataRejectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataRejectionPreviousValues>>,
    Fragmentable {
  reject_id: () => Promise<AsyncIterator<Int>>;
  rejectionDescription: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDatum {
  count: Int;
}

export interface AggregateCupDatumPromise
  extends Promise<AggregateCupDatum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDatumSubscription
  extends Promise<AsyncIterator<AggregateCupDatum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Cup {
  serial_number: Int;
  anonSerialNumber: Int;
  encryptionKey: Int;
}

export interface CupPromise extends Promise<Cup>, Fragmentable {
  serial_number: () => Promise<Int>;
  anonSerialNumber: () => Promise<Int>;
  calib: <T = CalibrationPromise>() => T;
  company: <T = CompanyPromise>() => T;
  cupAppSync: <T = FragmentableArray<CupAppSync>>(args?: {
    where?: CupAppSyncWhereInput;
    orderBy?: CupAppSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupData: <T = FragmentableArray<CupDatum>>(args?: {
    where?: CupDatumWhereInput;
    orderBy?: CupDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataColourCalib: <T = FragmentableArray<CupDataColourCalib>>(args?: {
    where?: CupDataColourCalibWhereInput;
    orderBy?: CupDataColourCalibOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataRaw: <T = FragmentableArray<CupDataRaw>>(args?: {
    where?: CupDataRawWhereInput;
    orderBy?: CupDataRawOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  encryptionKey: () => Promise<Int>;
  fw: <T = FirmwarePromise>() => T;
  hw: <T = HardwarePromise>() => T;
  userCups: <T = FragmentableArray<UserCup>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CupSubscription
  extends Promise<AsyncIterator<Cup>>,
    Fragmentable {
  serial_number: () => Promise<AsyncIterator<Int>>;
  anonSerialNumber: () => Promise<AsyncIterator<Int>>;
  calib: <T = CalibrationSubscription>() => T;
  company: <T = CompanySubscription>() => T;
  cupAppSync: <T = Promise<AsyncIterator<CupAppSyncSubscription>>>(args?: {
    where?: CupAppSyncWhereInput;
    orderBy?: CupAppSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupData: <T = Promise<AsyncIterator<CupDatumSubscription>>>(args?: {
    where?: CupDatumWhereInput;
    orderBy?: CupDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataColourCalib: <
    T = Promise<AsyncIterator<CupDataColourCalibSubscription>>
  >(args?: {
    where?: CupDataColourCalibWhereInput;
    orderBy?: CupDataColourCalibOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataRaw: <T = Promise<AsyncIterator<CupDataRawSubscription>>>(args?: {
    where?: CupDataRawWhereInput;
    orderBy?: CupDataRawOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  encryptionKey: () => Promise<AsyncIterator<Int>>;
  fw: <T = FirmwareSubscription>() => T;
  hw: <T = HardwareSubscription>() => T;
  userCups: <T = Promise<AsyncIterator<UserCupSubscription>>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CupNullablePromise extends Promise<Cup | null>, Fragmentable {
  serial_number: () => Promise<Int>;
  anonSerialNumber: () => Promise<Int>;
  calib: <T = CalibrationPromise>() => T;
  company: <T = CompanyPromise>() => T;
  cupAppSync: <T = FragmentableArray<CupAppSync>>(args?: {
    where?: CupAppSyncWhereInput;
    orderBy?: CupAppSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupData: <T = FragmentableArray<CupDatum>>(args?: {
    where?: CupDatumWhereInput;
    orderBy?: CupDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataColourCalib: <T = FragmentableArray<CupDataColourCalib>>(args?: {
    where?: CupDataColourCalibWhereInput;
    orderBy?: CupDataColourCalibOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataRaw: <T = FragmentableArray<CupDataRaw>>(args?: {
    where?: CupDataRawWhereInput;
    orderBy?: CupDataRawOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  encryptionKey: () => Promise<Int>;
  fw: <T = FirmwarePromise>() => T;
  hw: <T = HardwarePromise>() => T;
  userCups: <T = FragmentableArray<UserCup>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CupDataUserRemoveExplainEdge {
  node: CupDataUserRemoveExplain;
  cursor: String;
}

export interface CupDataUserRemoveExplainEdgePromise
  extends Promise<CupDataUserRemoveExplainEdge>,
    Fragmentable {
  node: <T = CupDataUserRemoveExplainPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataUserRemoveExplainEdgeSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainEdge>>,
    Fragmentable {
  node: <T = CupDataUserRemoveExplainSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemoveSubscriptionPayload {
  mutation: MutationType;
  node: CupDataUserRemove;
  updatedFields: String[];
  previousValues: CupDataUserRemovePreviousValues;
}

export interface CupDataUserRemoveSubscriptionPayloadPromise
  extends Promise<CupDataUserRemoveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataUserRemovePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataUserRemovePreviousValuesPromise>() => T;
}

export interface CupDataUserRemoveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataUserRemoveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataUserRemovePreviousValuesSubscription>() => T;
}

export interface CupDataUserRemoveEdge {
  node: CupDataUserRemove;
  cursor: String;
}

export interface CupDataUserRemoveEdgePromise
  extends Promise<CupDataUserRemoveEdge>,
    Fragmentable {
  node: <T = CupDataUserRemovePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataUserRemoveEdgeSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveEdge>>,
    Fragmentable {
  node: <T = CupDataUserRemoveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemovePreviousValues {
  row_id: Int;
  changeTime: DateTimeOutput;
}

export interface CupDataUserRemovePreviousValuesPromise
  extends Promise<CupDataUserRemovePreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
}

export interface CupDataUserRemovePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataUserRemovePreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataRejectionConnection {
  pageInfo: PageInfo;
  edges: CupDataRejectionEdge[];
}

export interface CupDataRejectionConnectionPromise
  extends Promise<CupDataRejectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataRejectionEdge>>() => T;
  aggregate: <T = AggregateCupDataRejectionPromise>() => T;
}

export interface CupDataRejectionConnectionSubscription
  extends Promise<AsyncIterator<CupDataRejectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataRejectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataRejectionSubscription>() => T;
}

export interface CupDataUserRemoveExplain {
  explain_id: Int;
  explain: String;
}

export interface CupDataUserRemoveExplainPromise
  extends Promise<CupDataUserRemoveExplain>,
    Fragmentable {
  explain_id: () => Promise<Int>;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  explain: () => Promise<String>;
}

export interface CupDataUserRemoveExplainSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplain>>,
    Fragmentable {
  explain_id: () => Promise<AsyncIterator<Int>>;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  explain: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemoveExplainNullablePromise
  extends Promise<CupDataUserRemoveExplain | null>,
    Fragmentable {
  explain_id: () => Promise<Int>;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  explain: () => Promise<String>;
}

export interface AggregateCupDataQuestion {
  count: Int;
}

export interface AggregateCupDataQuestionPromise
  extends Promise<AggregateCupDataQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataQuestionSubscription
  extends Promise<AsyncIterator<AggregateCupDataQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataUserRemoveExplainSubscriptionPayload {
  mutation: MutationType;
  node: CupDataUserRemoveExplain;
  updatedFields: String[];
  previousValues: CupDataUserRemoveExplainPreviousValues;
}

export interface CupDataUserRemoveExplainSubscriptionPayloadPromise
  extends Promise<CupDataUserRemoveExplainSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataUserRemoveExplainPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataUserRemoveExplainPreviousValuesPromise>() => T;
}

export interface CupDataUserRemoveExplainSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataUserRemoveExplainSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = CupDataUserRemoveExplainPreviousValuesSubscription
  >() => T;
}

export interface CupDataQaResponseEdge {
  node: CupDataQaResponse;
  cursor: String;
}

export interface CupDataQaResponseEdgePromise
  extends Promise<CupDataQaResponseEdge>,
    Fragmentable {
  node: <T = CupDataQaResponsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataQaResponseEdgeSubscription
  extends Promise<AsyncIterator<CupDataQaResponseEdge>>,
    Fragmentable {
  node: <T = CupDataQaResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemoveExplainPreviousValues {
  explain_id: Int;
  explain: String;
}

export interface CupDataUserRemoveExplainPreviousValuesPromise
  extends Promise<CupDataUserRemoveExplainPreviousValues>,
    Fragmentable {
  explain_id: () => Promise<Int>;
  explain: () => Promise<String>;
}

export interface CupDataUserRemoveExplainPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainPreviousValues>>,
    Fragmentable {
  explain_id: () => Promise<AsyncIterator<Int>>;
  explain: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcVolumeConnection {
  pageInfo: PageInfo;
  edges: CupDataProcVolumeEdge[];
}

export interface CupDataProcVolumeConnectionPromise
  extends Promise<CupDataProcVolumeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcVolumeEdge>>() => T;
  aggregate: <T = AggregateCupDataProcVolumePromise>() => T;
}

export interface CupDataProcVolumeConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcVolumeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcVolumeSubscription>() => T;
}

export interface CupDataUserRemove {
  row_id: Int;
  changeTime: DateTimeOutput;
}

export interface CupDataUserRemovePromise
  extends Promise<CupDataUserRemove>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  explain: <T = CupDataUserRemoveExplainPromise>() => T;
  serialNumber: <T = CupPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CupDataUserRemoveSubscription
  extends Promise<AsyncIterator<CupDataUserRemove>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  explain: <T = CupDataUserRemoveExplainSubscription>() => T;
  serialNumber: <T = CupSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CupDataUserRemoveNullablePromise
  extends Promise<CupDataUserRemove | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  explain: <T = CupDataUserRemoveExplainPromise>() => T;
  serialNumber: <T = CupPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface AggregateCupDataProcFlow {
  count: Int;
}

export interface AggregateCupDataProcFlowPromise
  extends Promise<AggregateCupDataProcFlow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcFlowSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcFlow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDatumSubscriptionPayload {
  mutation: MutationType;
  node: CupDatum;
  updatedFields: String[];
  previousValues: CupDatumPreviousValues;
}

export interface CupDatumSubscriptionPayloadPromise
  extends Promise<CupDatumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDatumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDatumPreviousValuesPromise>() => T;
}

export interface CupDatumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDatumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDatumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDatumPreviousValuesSubscription>() => T;
}

export interface CupDataManMdateEdge {
  node: CupDataManMdate;
  cursor: String;
}

export interface CupDataManMdateEdgePromise
  extends Promise<CupDataManMdateEdge>,
    Fragmentable {
  node: <T = CupDataManMdatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataManMdateEdgeSubscription
  extends Promise<AsyncIterator<CupDataManMdateEdge>>,
    Fragmentable {
  node: <T = CupDataManMdateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDatumPreviousValues {
  row_id: Int;
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  date: DateTimeOutput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDatumPreviousValuesPromise
  extends Promise<CupDatumPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  battery: () => Promise<Int>;
  calibFlag: () => Promise<Boolean>;
  ch1: () => Promise<Int>;
  ch10: () => Promise<Int>;
  ch11: () => Promise<Int>;
  ch12: () => Promise<Int>;
  ch13: () => Promise<Int>;
  ch14: () => Promise<Int>;
  ch2: () => Promise<Int>;
  ch3: () => Promise<Int>;
  ch4: () => Promise<Int>;
  ch5: () => Promise<Int>;
  ch6: () => Promise<Int>;
  ch7: () => Promise<Int>;
  ch8: () => Promise<Int>;
  ch9: () => Promise<Int>;
  colourB: () => Promise<Int>;
  colourC: () => Promise<Int>;
  colourG: () => Promise<Int>;
  colourR: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  day: () => Promise<Int>;
  hour: () => Promise<Int>;
  line: () => Promise<Int>;
  minute: () => Promise<Int>;
  month: () => Promise<Int>;
  page: () => Promise<Int>;
  rawTotalVolume: () => Promise<Int>;
  rawVolumeL: () => Promise<Int>;
  rawVolumeR: () => Promise<Int>;
  temperature: () => Promise<Int>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  year: () => Promise<Int>;
  z: () => Promise<Int>;
}

export interface CupDatumPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDatumPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  battery: () => Promise<AsyncIterator<Int>>;
  calibFlag: () => Promise<AsyncIterator<Boolean>>;
  ch1: () => Promise<AsyncIterator<Int>>;
  ch10: () => Promise<AsyncIterator<Int>>;
  ch11: () => Promise<AsyncIterator<Int>>;
  ch12: () => Promise<AsyncIterator<Int>>;
  ch13: () => Promise<AsyncIterator<Int>>;
  ch14: () => Promise<AsyncIterator<Int>>;
  ch2: () => Promise<AsyncIterator<Int>>;
  ch3: () => Promise<AsyncIterator<Int>>;
  ch4: () => Promise<AsyncIterator<Int>>;
  ch5: () => Promise<AsyncIterator<Int>>;
  ch6: () => Promise<AsyncIterator<Int>>;
  ch7: () => Promise<AsyncIterator<Int>>;
  ch8: () => Promise<AsyncIterator<Int>>;
  ch9: () => Promise<AsyncIterator<Int>>;
  colourB: () => Promise<AsyncIterator<Int>>;
  colourC: () => Promise<AsyncIterator<Int>>;
  colourG: () => Promise<AsyncIterator<Int>>;
  colourR: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  day: () => Promise<AsyncIterator<Int>>;
  hour: () => Promise<AsyncIterator<Int>>;
  line: () => Promise<AsyncIterator<Int>>;
  minute: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  page: () => Promise<AsyncIterator<Int>>;
  rawTotalVolume: () => Promise<AsyncIterator<Int>>;
  rawVolumeL: () => Promise<AsyncIterator<Int>>;
  rawVolumeR: () => Promise<AsyncIterator<Int>>;
  temperature: () => Promise<AsyncIterator<Int>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalibConnection {
  pageInfo: PageInfo;
  edges: CupDataColourCalibEdge[];
}

export interface CupDataColourCalibConnectionPromise
  extends Promise<CupDataColourCalibConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataColourCalibEdge>>() => T;
  aggregate: <T = AggregateCupDataColourCalibPromise>() => T;
}

export interface CupDataColourCalibConnectionSubscription
  extends Promise<AsyncIterator<CupDataColourCalibConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CupDataColourCalibEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCupDataColourCalibSubscription>() => T;
}

export interface CupDataQuestion {
  question_id: Int;
  questionText: String;
}

export interface CupDataQuestionPromise
  extends Promise<CupDataQuestion>,
    Fragmentable {
  question_id: () => Promise<Int>;
  cupDataAnswer: <T = FragmentableArray<CupDataAnswer>>(args?: {
    where?: CupDataAnswerWhereInput;
    orderBy?: CupDataAnswerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  questionText: () => Promise<String>;
}

export interface CupDataQuestionSubscription
  extends Promise<AsyncIterator<CupDataQuestion>>,
    Fragmentable {
  question_id: () => Promise<AsyncIterator<Int>>;
  cupDataAnswer: <
    T = Promise<AsyncIterator<CupDataAnswerSubscription>>
  >(args?: {
    where?: CupDataAnswerWhereInput;
    orderBy?: CupDataAnswerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  questionText: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestionNullablePromise
  extends Promise<CupDataQuestion | null>,
    Fragmentable {
  question_id: () => Promise<Int>;
  cupDataAnswer: <T = FragmentableArray<CupDataAnswer>>(args?: {
    where?: CupDataAnswerWhereInput;
    orderBy?: CupDataAnswerOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  questionText: () => Promise<String>;
}

export interface AggregateCupDataAnswer {
  count: Int;
}

export interface AggregateCupDataAnswerPromise
  extends Promise<AggregateCupDataAnswer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataAnswerSubscription
  extends Promise<AsyncIterator<AggregateCupDataAnswer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EthnicitySubscriptionPayload {
  mutation: MutationType;
  node: Ethnicity;
  updatedFields: String[];
  previousValues: EthnicityPreviousValues;
}

export interface EthnicitySubscriptionPayloadPromise
  extends Promise<EthnicitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EthnicityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EthnicityPreviousValuesPromise>() => T;
}

export interface EthnicitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EthnicitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EthnicitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EthnicityPreviousValuesSubscription>() => T;
}

export interface CupAppSyncEdge {
  node: CupAppSync;
  cursor: String;
}

export interface CupAppSyncEdgePromise
  extends Promise<CupAppSyncEdge>,
    Fragmentable {
  node: <T = CupAppSyncPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupAppSyncEdgeSubscription
  extends Promise<AsyncIterator<CupAppSyncEdge>>,
    Fragmentable {
  node: <T = CupAppSyncSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EthnicityPreviousValues {
  ethnicity_id: Int;
  ethnicity: String;
}

export interface EthnicityPreviousValuesPromise
  extends Promise<EthnicityPreviousValues>,
    Fragmentable {
  ethnicity_id: () => Promise<Int>;
  ethnicity: () => Promise<String>;
}

export interface EthnicityPreviousValuesSubscription
  extends Promise<AsyncIterator<EthnicityPreviousValues>>,
    Fragmentable {
  ethnicity_id: () => Promise<AsyncIterator<Int>>;
  ethnicity: () => Promise<AsyncIterator<String>>;
}

export interface CupConnection {
  pageInfo: PageInfo;
  edges: CupEdge[];
}

export interface CupConnectionPromise
  extends Promise<CupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupEdge>>() => T;
  aggregate: <T = AggregateCupPromise>() => T;
}

export interface CupConnectionSubscription
  extends Promise<AsyncIterator<CupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupSubscription>() => T;
}

export interface CupDataAnswer {
  answer_id: Int;
  answerText: String;
}

export interface CupDataAnswerPromise
  extends Promise<CupDataAnswer>,
    Fragmentable {
  answer_id: () => Promise<Int>;
  answerText: () => Promise<String>;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  question: <T = CupDataQuestionPromise>() => T;
}

export interface CupDataAnswerSubscription
  extends Promise<AsyncIterator<CupDataAnswer>>,
    Fragmentable {
  answer_id: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  question: <T = CupDataQuestionSubscription>() => T;
}

export interface CupDataAnswerNullablePromise
  extends Promise<CupDataAnswer | null>,
    Fragmentable {
  answer_id: () => Promise<Int>;
  answerText: () => Promise<String>;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  question: <T = CupDataQuestionPromise>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FirmwareSubscriptionPayload {
  mutation: MutationType;
  node: Firmware;
  updatedFields: String[];
  previousValues: FirmwarePreviousValues;
}

export interface FirmwareSubscriptionPayloadPromise
  extends Promise<FirmwareSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FirmwarePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FirmwarePreviousValuesPromise>() => T;
}

export interface FirmwareSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FirmwareSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FirmwareSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FirmwarePreviousValuesSubscription>() => T;
}

export interface CalibrationEdge {
  node: Calibration;
  cursor: String;
}

export interface CalibrationEdgePromise
  extends Promise<CalibrationEdge>,
    Fragmentable {
  node: <T = CalibrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CalibrationEdgeSubscription
  extends Promise<AsyncIterator<CalibrationEdge>>,
    Fragmentable {
  node: <T = CalibrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FirmwarePreviousValues {
  fw_id: Int;
  fwVersion: String;
}

export interface FirmwarePreviousValuesPromise
  extends Promise<FirmwarePreviousValues>,
    Fragmentable {
  fw_id: () => Promise<Int>;
  fwVersion: () => Promise<String>;
}

export interface FirmwarePreviousValuesSubscription
  extends Promise<AsyncIterator<FirmwarePreviousValues>>,
    Fragmentable {
  fw_id: () => Promise<AsyncIterator<Int>>;
  fwVersion: () => Promise<AsyncIterator<String>>;
}

export interface UsersDataAnalysisSubscriptionPayload {
  mutation: MutationType;
  node: UsersDataAnalysis;
  updatedFields: String[];
  previousValues: UsersDataAnalysisPreviousValues;
}

export interface UsersDataAnalysisSubscriptionPayloadPromise
  extends Promise<UsersDataAnalysisSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UsersDataAnalysisPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UsersDataAnalysisPreviousValuesPromise>() => T;
}

export interface UsersDataAnalysisSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UsersDataAnalysisSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UsersDataAnalysisPreviousValuesSubscription>() => T;
}

export interface CupDataQaResponse {
  cup_data_qa_response_id: Int;
  qaDate: DateTimeOutput;
}

export interface CupDataQaResponsePromise
  extends Promise<CupDataQaResponse>,
    Fragmentable {
  cup_data_qa_response_id: () => Promise<Int>;
  answer: <T = CupDataAnswerPromise>() => T;
  qaDate: () => Promise<DateTimeOutput>;
  question: <T = CupDataQuestionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CupDataQaResponseSubscription
  extends Promise<AsyncIterator<CupDataQaResponse>>,
    Fragmentable {
  cup_data_qa_response_id: () => Promise<AsyncIterator<Int>>;
  answer: <T = CupDataAnswerSubscription>() => T;
  qaDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  question: <T = CupDataQuestionSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CupDataQaResponseNullablePromise
  extends Promise<CupDataQaResponse | null>,
    Fragmentable {
  cup_data_qa_response_id: () => Promise<Int>;
  answer: <T = CupDataAnswerPromise>() => T;
  qaDate: () => Promise<DateTimeOutput>;
  question: <T = CupDataQuestionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserRecordDataByTimeEdge {
  node: UserRecordDataByTime;
  cursor: String;
}

export interface UserRecordDataByTimeEdgePromise
  extends Promise<UserRecordDataByTimeEdge>,
    Fragmentable {
  node: <T = UserRecordDataByTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByTimeEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HardwareSubscriptionPayload {
  mutation: MutationType;
  node: Hardware;
  updatedFields: String[];
  previousValues: HardwarePreviousValues;
}

export interface HardwareSubscriptionPayloadPromise
  extends Promise<HardwareSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HardwarePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HardwarePreviousValuesPromise>() => T;
}

export interface HardwareSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HardwareSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HardwareSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HardwarePreviousValuesSubscription>() => T;
}

export interface AggregateUserInterviewQuestion {
  count: Int;
}

export interface AggregateUserInterviewQuestionPromise
  extends Promise<AggregateUserInterviewQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserInterviewQuestionSubscription
  extends Promise<AsyncIterator<AggregateUserInterviewQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HardwarePreviousValues {
  hw_id: Int;
  hwVersion: String;
}

export interface HardwarePreviousValuesPromise
  extends Promise<HardwarePreviousValues>,
    Fragmentable {
  hw_id: () => Promise<Int>;
  hwVersion: () => Promise<String>;
}

export interface HardwarePreviousValuesSubscription
  extends Promise<AsyncIterator<HardwarePreviousValues>>,
    Fragmentable {
  hw_id: () => Promise<AsyncIterator<Int>>;
  hwVersion: () => Promise<AsyncIterator<String>>;
}

export interface UserCoinHistoryConnection {
  pageInfo: PageInfo;
  edges: UserCoinHistoryEdge[];
}

export interface UserCoinHistoryConnectionPromise
  extends Promise<UserCoinHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCoinHistoryEdge>>() => T;
  aggregate: <T = AggregateUserCoinHistoryPromise>() => T;
}

export interface UserCoinHistoryConnectionSubscription
  extends Promise<AsyncIterator<UserCoinHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserCoinHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserCoinHistorySubscription>() => T;
}

export interface CupDataRejection {
  reject_id: Int;
  rejectionDescription: String;
}

export interface CupDataRejectionPromise
  extends Promise<CupDataRejection>,
    Fragmentable {
  reject_id: () => Promise<Int>;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rejectionDescription: () => Promise<String>;
}

export interface CupDataRejectionSubscription
  extends Promise<AsyncIterator<CupDataRejection>>,
    Fragmentable {
  reject_id: () => Promise<AsyncIterator<Int>>;
  cupDataProcMdates: <
    T = Promise<AsyncIterator<CupDataProcMdateSubscription>>
  >(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rejectionDescription: () => Promise<AsyncIterator<String>>;
}

export interface CupDataRejectionNullablePromise
  extends Promise<CupDataRejection | null>,
    Fragmentable {
  reject_id: () => Promise<Int>;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  rejectionDescription: () => Promise<String>;
}

export interface AggregateHardware {
  count: Int;
}

export interface AggregateHardwarePromise
  extends Promise<AggregateHardware>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHardwareSubscription
  extends Promise<AsyncIterator<AggregateHardware>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformCompSubscriptionPayload {
  mutation: MutationType;
  node: PlatformComp;
  updatedFields: String[];
  previousValues: PlatformCompPreviousValues;
}

export interface PlatformCompSubscriptionPayloadPromise
  extends Promise<PlatformCompSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlatformCompPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlatformCompPreviousValuesPromise>() => T;
}

export interface PlatformCompSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlatformCompSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlatformCompSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlatformCompPreviousValuesSubscription>() => T;
}

export interface EthnicityConnection {
  pageInfo: PageInfo;
  edges: EthnicityEdge[];
}

export interface EthnicityConnectionPromise
  extends Promise<EthnicityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EthnicityEdge>>() => T;
  aggregate: <T = AggregateEthnicityPromise>() => T;
}

export interface EthnicityConnectionSubscription
  extends Promise<AsyncIterator<EthnicityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EthnicityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEthnicitySubscription>() => T;
}

export interface PlatformCompPreviousValues {
  row_id: Int;
  phoneId: Int;
  platformId: Int;
  problemHistory?: Boolean;
  softwareId: Int;
  successHistory?: Boolean;
}

export interface PlatformCompPreviousValuesPromise
  extends Promise<PlatformCompPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  phoneId: () => Promise<Int>;
  platformId: () => Promise<Int>;
  problemHistory: () => Promise<Boolean>;
  softwareId: () => Promise<Int>;
  successHistory: () => Promise<Boolean>;
}

export interface PlatformCompPreviousValuesSubscription
  extends Promise<AsyncIterator<PlatformCompPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  phoneId: () => Promise<AsyncIterator<Int>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  problemHistory: () => Promise<AsyncIterator<Boolean>>;
  softwareId: () => Promise<AsyncIterator<Int>>;
  successHistory: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserRecordDataByTimeSubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByTime;
  updatedFields: String[];
  previousValues: UserRecordDataByTimePreviousValues;
}

export interface UserRecordDataByTimeSubscriptionPayloadPromise
  extends Promise<UserRecordDataByTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByTimePreviousValuesPromise>() => T;
}

export interface UserRecordDataByTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByTimePreviousValuesSubscription>() => T;
}

export interface CupDataManMdate {
  row_id: Int;
  menFinish?: DateTimeOutput;
  menStart?: DateTimeOutput;
}

export interface CupDataManMdatePromise
  extends Promise<CupDataManMdate>,
    Fragmentable {
  row_id: () => Promise<Int>;
  mdateRow: <T = CupDataProcMdatePromise>() => T;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
}

export interface CupDataManMdateSubscription
  extends Promise<AsyncIterator<CupDataManMdate>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  mdateRow: <T = CupDataProcMdateSubscription>() => T;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataManMdateNullablePromise
  extends Promise<CupDataManMdate | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  mdateRow: <T = CupDataProcMdatePromise>() => T;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
}

export interface CupDataRawEdge {
  node: CupDataRaw;
  cursor: String;
}

export interface CupDataRawEdgePromise
  extends Promise<CupDataRawEdge>,
    Fragmentable {
  node: <T = CupDataRawPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataRawEdgeSubscription
  extends Promise<AsyncIterator<CupDataRawEdge>>,
    Fragmentable {
  node: <T = CupDataRawSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataProcVolume {
  count: Int;
}

export interface AggregateCupDataProcVolumePromise
  extends Promise<AggregateCupDataProcVolume>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcVolumeSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcVolume>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  user_id: Int;
  anonUserId?: Int;
  deleted: Boolean;
  dob: DateTimeOutput;
  email: String;
  encryptSaltString?: String;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  user_id: () => Promise<Int>;
  anonUserId: () => Promise<Int>;
  deleted: () => Promise<Boolean>;
  dob: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  encryptSaltString: () => Promise<String>;
  firstName: () => Promise<String>;
  givenBirth: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
  anonUserId: () => Promise<AsyncIterator<Int>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptSaltString: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  givenBirth: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcFlowConnection {
  pageInfo: PageInfo;
  edges: CupDataProcFlowEdge[];
}

export interface CupDataProcFlowConnectionPromise
  extends Promise<CupDataProcFlowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcFlowEdge>>() => T;
  aggregate: <T = AggregateCupDataProcFlowPromise>() => T;
}

export interface CupDataProcFlowConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcFlowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcFlowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcFlowSubscription>() => T;
}

export interface CupDataProcMdate {
  mdate_row_id: Int;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeOutput;
  menStart: DateTimeOutput;
  rewardAmount?: Int;
}

export interface CupDataProcMdatePromise
  extends Promise<CupDataProcMdate>,
    Fragmentable {
  mdate_row_id: () => Promise<Int>;
  cupDataManMdates: <T = FragmentableArray<CupDataManMdate>>(args?: {
    where?: CupDataManMdateWhereInput;
    orderBy?: CupDataManMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRejected: () => Promise<Boolean>;
  dataVerified: () => Promise<Boolean>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
  reject: <T = CupDataRejectionPromise>() => T;
  rewardAmount: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface CupDataProcMdateSubscription
  extends Promise<AsyncIterator<CupDataProcMdate>>,
    Fragmentable {
  mdate_row_id: () => Promise<AsyncIterator<Int>>;
  cupDataManMdates: <
    T = Promise<AsyncIterator<CupDataManMdateSubscription>>
  >(args?: {
    where?: CupDataManMdateWhereInput;
    orderBy?: CupDataManMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcFlow: <
    T = Promise<AsyncIterator<CupDataProcFlowSubscription>>
  >(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRejected: () => Promise<AsyncIterator<Boolean>>;
  dataVerified: () => Promise<AsyncIterator<Boolean>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  reject: <T = CupDataRejectionSubscription>() => T;
  rewardAmount: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface CupDataProcMdateNullablePromise
  extends Promise<CupDataProcMdate | null>,
    Fragmentable {
  mdate_row_id: () => Promise<Int>;
  cupDataManMdates: <T = FragmentableArray<CupDataManMdate>>(args?: {
    where?: CupDataManMdateWhereInput;
    orderBy?: CupDataManMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dataRejected: () => Promise<Boolean>;
  dataVerified: () => Promise<Boolean>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
  reject: <T = CupDataRejectionPromise>() => T;
  rewardAmount: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface CupDataColourCalcEdge {
  node: CupDataColourCalc;
  cursor: String;
}

export interface CupDataColourCalcEdgePromise
  extends Promise<CupDataColourCalcEdge>,
    Fragmentable {
  node: <T = CupDataColourCalcPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataColourCalcEdgeSubscription
  extends Promise<AsyncIterator<CupDataColourCalcEdge>>,
    Fragmentable {
  node: <T = CupDataColourCalcSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserCoinHistorySubscriptionPayload {
  mutation: MutationType;
  node: UserCoinHistory;
  updatedFields: String[];
  previousValues: UserCoinHistoryPreviousValues;
}

export interface UserCoinHistorySubscriptionPayloadPromise
  extends Promise<UserCoinHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCoinHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCoinHistoryPreviousValuesPromise>() => T;
}

export interface UserCoinHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCoinHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCoinHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserCoinHistoryPreviousValuesSubscription>() => T;
}

export interface AggregateCup {
  count: Int;
}

export interface AggregateCupPromise
  extends Promise<AggregateCup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupSubscription
  extends Promise<AsyncIterator<AggregateCup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCoinHistoryPreviousValues {
  row_id: Int;
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeOutput;
  txhash: String;
}

export interface UserCoinHistoryPreviousValuesPromise
  extends Promise<UserCoinHistoryPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  category: () => Promise<String>;
  coin: () => Promise<Int>;
  contents: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  txhash: () => Promise<String>;
}

export interface UserCoinHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCoinHistoryPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  coin: () => Promise<AsyncIterator<Int>>;
  contents: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  txhash: () => Promise<AsyncIterator<String>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CupDataProcFlow {
  row_id: Int;
  date: DateTimeOutput;
  hourlyFlow: Int;
}

export interface CupDataProcFlowPromise
  extends Promise<CupDataProcFlow>,
    Fragmentable {
  row_id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  hourlyFlow: () => Promise<Int>;
  mdateRow: <T = CupDataProcMdatePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CupDataProcFlowSubscription
  extends Promise<AsyncIterator<CupDataProcFlow>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  hourlyFlow: () => Promise<AsyncIterator<Int>>;
  mdateRow: <T = CupDataProcMdateSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CupDataProcFlowNullablePromise
  extends Promise<CupDataProcFlow | null>,
    Fragmentable {
  row_id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  hourlyFlow: () => Promise<Int>;
  mdateRow: <T = CupDataProcMdatePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UsersDataAnalysisConnection {
  pageInfo: PageInfo;
  edges: UsersDataAnalysisEdge[];
}

export interface UsersDataAnalysisConnectionPromise
  extends Promise<UsersDataAnalysisConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UsersDataAnalysisEdge>>() => T;
  aggregate: <T = AggregateUsersDataAnalysisPromise>() => T;
}

export interface UsersDataAnalysisConnectionSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UsersDataAnalysisEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUsersDataAnalysisSubscription>() => T;
}

export interface UserInterviewDatumSubscriptionPayload {
  mutation: MutationType;
  node: UserInterviewDatum;
  updatedFields: String[];
  previousValues: UserInterviewDatumPreviousValues;
}

export interface UserInterviewDatumSubscriptionPayloadPromise
  extends Promise<UserInterviewDatumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserInterviewDatumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserInterviewDatumPreviousValuesPromise>() => T;
}

export interface UserInterviewDatumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserInterviewDatumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserInterviewDatumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserInterviewDatumPreviousValuesSubscription>() => T;
}

export interface UserInterviewDatumEdge {
  node: UserInterviewDatum;
  cursor: String;
}

export interface UserInterviewDatumEdgePromise
  extends Promise<UserInterviewDatumEdge>,
    Fragmentable {
  node: <T = UserInterviewDatumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserInterviewDatumEdgeSubscription
  extends Promise<AsyncIterator<UserInterviewDatumEdge>>,
    Fragmentable {
  node: <T = UserInterviewDatumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserInterviewDatumPreviousValues {
  row_id: Int;
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeOutput;
}

export interface UserInterviewDatumPreviousValuesPromise
  extends Promise<UserInterviewDatumPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  answerRange: () => Promise<Int>;
  answerText: () => Promise<String>;
  answerYn: () => Promise<Boolean>;
  date: () => Promise<DateTimeOutput>;
}

export interface UserInterviewDatumPreviousValuesSubscription
  extends Promise<AsyncIterator<UserInterviewDatumPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  answerRange: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  answerYn: () => Promise<AsyncIterator<Boolean>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FirmwareEdge {
  node: Firmware;
  cursor: String;
}

export interface FirmwareEdgePromise
  extends Promise<FirmwareEdge>,
    Fragmentable {
  node: <T = FirmwarePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FirmwareEdgeSubscription
  extends Promise<AsyncIterator<FirmwareEdge>>,
    Fragmentable {
  node: <T = FirmwareSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Country {
  country_id: Int;
  countryName: String;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  country_id: () => Promise<Int>;
  countryName: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  country_id: () => Promise<AsyncIterator<Int>>;
  countryName: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CountryNullablePromise
  extends Promise<Country | null>,
    Fragmentable {
  country_id: () => Promise<Int>;
  countryName: () => Promise<String>;
  users: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateCupDataRejection {
  count: Int;
}

export interface AggregateCupDataRejectionPromise
  extends Promise<AggregateCupDataRejection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataRejectionSubscription
  extends Promise<AsyncIterator<AggregateCupDataRejection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserInterviewQuestionSubscriptionPayload {
  mutation: MutationType;
  node: UserInterviewQuestion;
  updatedFields: String[];
  previousValues: UserInterviewQuestionPreviousValues;
}

export interface UserInterviewQuestionSubscriptionPayloadPromise
  extends Promise<UserInterviewQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserInterviewQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserInterviewQuestionPreviousValuesPromise>() => T;
}

export interface UserInterviewQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserInterviewQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserInterviewQuestionPreviousValuesSubscription>() => T;
}

export interface CupDataProcMdateEdge {
  node: CupDataProcMdate;
  cursor: String;
}

export interface CupDataProcMdateEdgePromise
  extends Promise<CupDataProcMdateEdge>,
    Fragmentable {
  node: <T = CupDataProcMdatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcMdateEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcMdateEdge>>,
    Fragmentable {
  node: <T = CupDataProcMdateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserInterviewQuestionPreviousValues {
  question_id: Int;
  question: String;
}

export interface UserInterviewQuestionPreviousValuesPromise
  extends Promise<UserInterviewQuestionPreviousValues>,
    Fragmentable {
  question_id: () => Promise<Int>;
  question: () => Promise<String>;
}

export interface UserInterviewQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionPreviousValues>>,
    Fragmentable {
  question_id: () => Promise<AsyncIterator<Int>>;
  question: () => Promise<AsyncIterator<String>>;
}

export interface CupDataAnswerConnection {
  pageInfo: PageInfo;
  edges: CupDataAnswerEdge[];
}

export interface CupDataAnswerConnectionPromise
  extends Promise<CupDataAnswerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataAnswerEdge>>() => T;
  aggregate: <T = AggregateCupDataAnswerPromise>() => T;
}

export interface CupDataAnswerConnectionSubscription
  extends Promise<AsyncIterator<CupDataAnswerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataAnswerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataAnswerSubscription>() => T;
}

export interface AppServerSync {
  app_server_sync_id: Int;
  serverSynchTime: DateTimeOutput;
}

export interface AppServerSyncPromise
  extends Promise<AppServerSync>,
    Fragmentable {
  app_server_sync_id: () => Promise<Int>;
  serverSynchTime: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface AppServerSyncSubscription
  extends Promise<AsyncIterator<AppServerSync>>,
    Fragmentable {
  app_server_sync_id: () => Promise<AsyncIterator<Int>>;
  serverSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  user: <T = UserSubscription>() => T;
}

export interface AppServerSyncNullablePromise
  extends Promise<AppServerSync | null>,
    Fragmentable {
  app_server_sync_id: () => Promise<Int>;
  serverSynchTime: () => Promise<DateTimeOutput>;
  user: <T = UserPromise>() => T;
}

export interface AggregateAuthToken {
  count: Int;
}

export interface AggregateAuthTokenPromise
  extends Promise<AggregateAuthToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthTokenSubscription
  extends Promise<AsyncIterator<AggregateAuthToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePlatformComp {
  count: Int;
}

export interface AggregatePlatformCompPromise
  extends Promise<AggregatePlatformComp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlatformCompSubscription
  extends Promise<AsyncIterator<AggregatePlatformComp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByPeriodSubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByPeriod;
  updatedFields: String[];
  previousValues: UserRecordDataByPeriodPreviousValues;
}

export interface UserRecordDataByPeriodSubscriptionPayloadPromise
  extends Promise<UserRecordDataByPeriodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByPeriodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByPeriodPreviousValuesPromise>() => T;
}

export interface UserRecordDataByPeriodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByPeriodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByPeriodPreviousValuesSubscription>() => T;
}

export interface User {
  user_id: Int;
  anonUserId?: Int;
  deleted: Boolean;
  dob: DateTimeOutput;
  email: String;
  encryptSaltString?: String;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  user_id: () => Promise<Int>;
  anonUserId: () => Promise<Int>;
  appServerSync: <T = FragmentableArray<AppServerSync>>(args?: {
    where?: AppServerSyncWhereInput;
    orderBy?: AppServerSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  country: <T = CountryPromise>() => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deleted: () => Promise<Boolean>;
  dob: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  encryptSaltString: () => Promise<String>;
  ethnicity: <T = EthnicityPromise>() => T;
  firstName: () => Promise<String>;
  givenBirth: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userCoinHistory: <T = FragmentableArray<UserCoinHistory>>(args?: {
    where?: UserCoinHistoryWhereInput;
    orderBy?: UserCoinHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCups: <T = FragmentableArray<UserCup>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRecordDataByPeriod: <
    T = FragmentableArray<UserRecordDataByPeriod>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  user_id: () => Promise<AsyncIterator<Int>>;
  anonUserId: () => Promise<AsyncIterator<Int>>;
  appServerSync: <
    T = Promise<AsyncIterator<AppServerSyncSubscription>>
  >(args?: {
    where?: AppServerSyncWhereInput;
    orderBy?: AppServerSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  country: <T = CountrySubscription>() => T;
  cupDataProcFlow: <
    T = Promise<AsyncIterator<CupDataProcFlowSubscription>>
  >(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcMdates: <
    T = Promise<AsyncIterator<CupDataProcMdateSubscription>>
  >(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptSaltString: () => Promise<AsyncIterator<String>>;
  ethnicity: <T = EthnicitySubscription>() => T;
  firstName: () => Promise<AsyncIterator<String>>;
  givenBirth: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userCoinHistory: <
    T = Promise<AsyncIterator<UserCoinHistorySubscription>>
  >(args?: {
    where?: UserCoinHistoryWhereInput;
    orderBy?: UserCoinHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCups: <T = Promise<AsyncIterator<UserCupSubscription>>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userInterviewData: <
    T = Promise<AsyncIterator<UserInterviewDatumSubscription>>
  >(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRecordDataByPeriod: <
    T = Promise<AsyncIterator<UserRecordDataByPeriodSubscription>>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  user_id: () => Promise<Int>;
  anonUserId: () => Promise<Int>;
  appServerSync: <T = FragmentableArray<AppServerSync>>(args?: {
    where?: AppServerSyncWhereInput;
    orderBy?: AppServerSyncOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  country: <T = CountryPromise>() => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(args?: {
    where?: CupDataProcFlowWhereInput;
    orderBy?: CupDataProcFlowOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(args?: {
    where?: CupDataProcMdateWhereInput;
    orderBy?: CupDataProcMdateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(args?: {
    where?: CupDataQaResponseWhereInput;
    orderBy?: CupDataQaResponseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(args?: {
    where?: CupDataUserRemoveWhereInput;
    orderBy?: CupDataUserRemoveOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  deleted: () => Promise<Boolean>;
  dob: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  encryptSaltString: () => Promise<String>;
  ethnicity: <T = EthnicityPromise>() => T;
  firstName: () => Promise<String>;
  givenBirth: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userCoinHistory: <T = FragmentableArray<UserCoinHistory>>(args?: {
    where?: UserCoinHistoryWhereInput;
    orderBy?: UserCoinHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userCups: <T = FragmentableArray<UserCup>>(args?: {
    where?: UserCupWhereInput;
    orderBy?: UserCupOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(args?: {
    where?: UserInterviewDatumWhereInput;
    orderBy?: UserInterviewDatumOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  userRecordDataByPeriod: <
    T = FragmentableArray<UserRecordDataByPeriod>
  >(args?: {
    where?: UserRecordDataByPeriodWhereInput;
    orderBy?: UserRecordDataByPeriodOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserRecordDataByDayPreviousValues {
  row_id: Int;
  crampsLevel?: Int;
  recordDate: DateTimeOutput;
}

export interface UserRecordDataByDayPreviousValuesPromise
  extends Promise<UserRecordDataByDayPreviousValues>,
    Fragmentable {
  row_id: () => Promise<Int>;
  crampsLevel: () => Promise<Int>;
  recordDate: () => Promise<DateTimeOutput>;
}

export interface UserRecordDataByDayPreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayPreviousValues>>,
    Fragmentable {
  row_id: () => Promise<AsyncIterator<Int>>;
  crampsLevel: () => Promise<AsyncIterator<Int>>;
  recordDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRecordDataByDaySubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByDay;
  updatedFields: String[];
  previousValues: UserRecordDataByDayPreviousValues;
}

export interface UserRecordDataByDaySubscriptionPayloadPromise
  extends Promise<UserRecordDataByDaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByDayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByDayPreviousValuesPromise>() => T;
}

export interface UserRecordDataByDaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByDaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByDaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByDayPreviousValuesSubscription>() => T;
}

export interface CupDatumConnection {
  pageInfo: PageInfo;
  edges: CupDatumEdge[];
}

export interface CupDatumConnectionPromise
  extends Promise<CupDatumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDatumEdge>>() => T;
  aggregate: <T = AggregateCupDatumPromise>() => T;
}

export interface CupDatumConnectionSubscription
  extends Promise<AsyncIterator<CupDatumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDatumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDatumSubscription>() => T;
}

export interface UserRecordDataByPeriodConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByPeriodEdge[];
}

export interface UserRecordDataByPeriodConnectionPromise
  extends Promise<UserRecordDataByPeriodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByPeriodEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByPeriodPromise>() => T;
}

export interface UserRecordDataByPeriodConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByPeriodEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByPeriodSubscription>() => T;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDataColourCalib {
  count: Int;
}

export interface AggregateCupDataColourCalibPromise
  extends Promise<AggregateCupDataColourCalib>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataColourCalibSubscription
  extends Promise<AsyncIterator<AggregateCupDataColourCalib>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataQuestionConnection {
  pageInfo: PageInfo;
  edges: CupDataQuestionEdge[];
}

export interface CupDataQuestionConnectionPromise
  extends Promise<CupDataQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataQuestionEdge>>() => T;
  aggregate: <T = AggregateCupDataQuestionPromise>() => T;
}

export interface CupDataQuestionConnectionSubscription
  extends Promise<AsyncIterator<CupDataQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataQuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataQuestionSubscription>() => T;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AnswerType",
    embedded: false
  },
  {
    name: "AppServerSync",
    embedded: false
  },
  {
    name: "AuthToken",
    embedded: false
  },
  {
    name: "Calibration",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Cup",
    embedded: false
  },
  {
    name: "CupAppSync",
    embedded: false
  },
  {
    name: "CupDataAnswer",
    embedded: false
  },
  {
    name: "CupDataColourCalc",
    embedded: false
  },
  {
    name: "CupDataColourCalib",
    embedded: false
  },
  {
    name: "CupDataManMdate",
    embedded: false
  },
  {
    name: "CupDataProcFlow",
    embedded: false
  },
  {
    name: "CupDataProcMdate",
    embedded: false
  },
  {
    name: "CupDataProcVolume",
    embedded: false
  },
  {
    name: "CupDataQaResponse",
    embedded: false
  },
  {
    name: "CupDataQuestion",
    embedded: false
  },
  {
    name: "CupDataRaw",
    embedded: false
  },
  {
    name: "CupDataRejection",
    embedded: false
  },
  {
    name: "CupDataUserRemove",
    embedded: false
  },
  {
    name: "CupDataUserRemoveExplain",
    embedded: false
  },
  {
    name: "CupDatum",
    embedded: false
  },
  {
    name: "Ethnicity",
    embedded: false
  },
  {
    name: "Firmware",
    embedded: false
  },
  {
    name: "Hardware",
    embedded: false
  },
  {
    name: "PlatformComp",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserCoinHistory",
    embedded: false
  },
  {
    name: "UserCup",
    embedded: false
  },
  {
    name: "UserInterviewDatum",
    embedded: false
  },
  {
    name: "UserInterviewQuestion",
    embedded: false
  },
  {
    name: "UserRecordDataByDay",
    embedded: false
  },
  {
    name: "UserRecordDataByPeriod",
    embedded: false
  },
  {
    name: "UserRecordDataByTime",
    embedded: false
  },
  {
    name: "UsersDataAnalysis",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
