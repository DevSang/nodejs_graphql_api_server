// Code generated by Prisma (prisma@1.30.5). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  answerType: (where?: AnswerTypeWhereInput) => Promise<boolean>;
  appServerSync: (where?: AppServerSyncWhereInput) => Promise<boolean>;
  authToken: (where?: AuthTokenWhereInput) => Promise<boolean>;
  calibration: (where?: CalibrationWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  country: (where?: CountryWhereInput) => Promise<boolean>;
  cup: (where?: CupWhereInput) => Promise<boolean>;
  cupAppSync: (where?: CupAppSyncWhereInput) => Promise<boolean>;
  cupDataAnswer: (where?: CupDataAnswerWhereInput) => Promise<boolean>;
  cupDataColourCalc: (where?: CupDataColourCalcWhereInput) => Promise<boolean>;
  cupDataColourCalib: (
    where?: CupDataColourCalibWhereInput
  ) => Promise<boolean>;
  cupDataManMdate: (where?: CupDataManMdateWhereInput) => Promise<boolean>;
  cupDataProcFlow: (where?: CupDataProcFlowWhereInput) => Promise<boolean>;
  cupDataProcMdate: (where?: CupDataProcMdateWhereInput) => Promise<boolean>;
  cupDataProcVolume: (where?: CupDataProcVolumeWhereInput) => Promise<boolean>;
  cupDataQaResponse: (where?: CupDataQaResponseWhereInput) => Promise<boolean>;
  cupDataQuestion: (where?: CupDataQuestionWhereInput) => Promise<boolean>;
  cupDataRaw: (where?: CupDataRawWhereInput) => Promise<boolean>;
  cupDataRejection: (where?: CupDataRejectionWhereInput) => Promise<boolean>;
  cupDataUserRemove: (where?: CupDataUserRemoveWhereInput) => Promise<boolean>;
  cupDataUserRemoveExplain: (
    where?: CupDataUserRemoveExplainWhereInput
  ) => Promise<boolean>;
  cupDatum: (where?: CupDatumWhereInput) => Promise<boolean>;
  ethnicity: (where?: EthnicityWhereInput) => Promise<boolean>;
  firmware: (where?: FirmwareWhereInput) => Promise<boolean>;
  hardware: (where?: HardwareWhereInput) => Promise<boolean>;
  platformComp: (where?: PlatformCompWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userCoinHistory: (where?: UserCoinHistoryWhereInput) => Promise<boolean>;
  userCup: (where?: UserCupWhereInput) => Promise<boolean>;
  userInterviewDatum: (
    where?: UserInterviewDatumWhereInput
  ) => Promise<boolean>;
  userInterviewQuestion: (
    where?: UserInterviewQuestionWhereInput
  ) => Promise<boolean>;
  userRecordDataByDay: (
    where?: UserRecordDataByDayWhereInput
  ) => Promise<boolean>;
  userRecordDataByPeriod: (
    where?: UserRecordDataByPeriodWhereInput
  ) => Promise<boolean>;
  userRecordDataByTime: (
    where?: UserRecordDataByTimeWhereInput
  ) => Promise<boolean>;
  usersDataAnalysis: (where?: UsersDataAnalysisWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  answerType: (where: AnswerTypeWhereUniqueInput) => AnswerTypePromise;
  answerTypes: (
    args?: {
      where?: AnswerTypeWhereInput;
      orderBy?: AnswerTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AnswerType>;
  answerTypesConnection: (
    args?: {
      where?: AnswerTypeWhereInput;
      orderBy?: AnswerTypeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AnswerTypeConnectionPromise;
  appServerSync: (where: AppServerSyncWhereUniqueInput) => AppServerSyncPromise;
  appServerSyncs: (
    args?: {
      where?: AppServerSyncWhereInput;
      orderBy?: AppServerSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AppServerSync>;
  appServerSyncsConnection: (
    args?: {
      where?: AppServerSyncWhereInput;
      orderBy?: AppServerSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AppServerSyncConnectionPromise;
  authToken: (where: AuthTokenWhereUniqueInput) => AuthTokenPromise;
  authTokens: (
    args?: {
      where?: AuthTokenWhereInput;
      orderBy?: AuthTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AuthToken>;
  authTokensConnection: (
    args?: {
      where?: AuthTokenWhereInput;
      orderBy?: AuthTokenOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AuthTokenConnectionPromise;
  calibration: (where: CalibrationWhereUniqueInput) => CalibrationPromise;
  calibrations: (
    args?: {
      where?: CalibrationWhereInput;
      orderBy?: CalibrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Calibration>;
  calibrationsConnection: (
    args?: {
      where?: CalibrationWhereInput;
      orderBy?: CalibrationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CalibrationConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyPromise;
  companies: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Company>;
  companiesConnection: (
    args?: {
      where?: CompanyWhereInput;
      orderBy?: CompanyOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CompanyConnectionPromise;
  country: (where: CountryWhereUniqueInput) => CountryPromise;
  countries: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Country>;
  countriesConnection: (
    args?: {
      where?: CountryWhereInput;
      orderBy?: CountryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CountryConnectionPromise;
  cup: (where: CupWhereUniqueInput) => CupPromise;
  cups: (
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Cup>;
  cupsConnection: (
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupConnectionPromise;
  cupAppSync: (where: CupAppSyncWhereUniqueInput) => CupAppSyncPromise;
  cupAppSyncs: (
    args?: {
      where?: CupAppSyncWhereInput;
      orderBy?: CupAppSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupAppSync>;
  cupAppSyncsConnection: (
    args?: {
      where?: CupAppSyncWhereInput;
      orderBy?: CupAppSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupAppSyncConnectionPromise;
  cupDataAnswer: (where: CupDataAnswerWhereUniqueInput) => CupDataAnswerPromise;
  cupDataAnswers: (
    args?: {
      where?: CupDataAnswerWhereInput;
      orderBy?: CupDataAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataAnswer>;
  cupDataAnswersConnection: (
    args?: {
      where?: CupDataAnswerWhereInput;
      orderBy?: CupDataAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataAnswerConnectionPromise;
  cupDataColourCalc: (
    where: CupDataColourCalcWhereUniqueInput
  ) => CupDataColourCalcPromise;
  cupDataColourCalcs: (
    args?: {
      where?: CupDataColourCalcWhereInput;
      orderBy?: CupDataColourCalcOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataColourCalc>;
  cupDataColourCalcsConnection: (
    args?: {
      where?: CupDataColourCalcWhereInput;
      orderBy?: CupDataColourCalcOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataColourCalcConnectionPromise;
  cupDataColourCalib: (
    where: CupDataColourCalibWhereUniqueInput
  ) => CupDataColourCalibPromise;
  cupDataColourCalibs: (
    args?: {
      where?: CupDataColourCalibWhereInput;
      orderBy?: CupDataColourCalibOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataColourCalib>;
  cupDataColourCalibsConnection: (
    args?: {
      where?: CupDataColourCalibWhereInput;
      orderBy?: CupDataColourCalibOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataColourCalibConnectionPromise;
  cupDataManMdate: (
    where: CupDataManMdateWhereUniqueInput
  ) => CupDataManMdatePromise;
  cupDataManMdates: (
    args?: {
      where?: CupDataManMdateWhereInput;
      orderBy?: CupDataManMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataManMdate>;
  cupDataManMdatesConnection: (
    args?: {
      where?: CupDataManMdateWhereInput;
      orderBy?: CupDataManMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataManMdateConnectionPromise;
  cupDataProcFlow: (
    where: CupDataProcFlowWhereUniqueInput
  ) => CupDataProcFlowPromise;
  cupDataProcFlows: (
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataProcFlow>;
  cupDataProcFlowsConnection: (
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataProcFlowConnectionPromise;
  cupDataProcMdate: (
    where: CupDataProcMdateWhereUniqueInput
  ) => CupDataProcMdatePromise;
  cupDataProcMdates: (
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataProcMdate>;
  cupDataProcMdatesConnection: (
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataProcMdateConnectionPromise;
  cupDataProcVolume: (
    where: CupDataProcVolumeWhereUniqueInput
  ) => CupDataProcVolumePromise;
  cupDataProcVolumes: (
    args?: {
      where?: CupDataProcVolumeWhereInput;
      orderBy?: CupDataProcVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataProcVolume>;
  cupDataProcVolumesConnection: (
    args?: {
      where?: CupDataProcVolumeWhereInput;
      orderBy?: CupDataProcVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataProcVolumeConnectionPromise;
  cupDataQaResponse: (
    where: CupDataQaResponseWhereUniqueInput
  ) => CupDataQaResponsePromise;
  cupDataQaResponses: (
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataQaResponse>;
  cupDataQaResponsesConnection: (
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataQaResponseConnectionPromise;
  cupDataQuestion: (
    where: CupDataQuestionWhereUniqueInput
  ) => CupDataQuestionPromise;
  cupDataQuestions: (
    args?: {
      where?: CupDataQuestionWhereInput;
      orderBy?: CupDataQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataQuestion>;
  cupDataQuestionsConnection: (
    args?: {
      where?: CupDataQuestionWhereInput;
      orderBy?: CupDataQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataQuestionConnectionPromise;
  cupDataRaw: (where: CupDataRawWhereUniqueInput) => CupDataRawPromise;
  cupDataRaws: (
    args?: {
      where?: CupDataRawWhereInput;
      orderBy?: CupDataRawOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataRaw>;
  cupDataRawsConnection: (
    args?: {
      where?: CupDataRawWhereInput;
      orderBy?: CupDataRawOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataRawConnectionPromise;
  cupDataRejection: (
    where: CupDataRejectionWhereUniqueInput
  ) => CupDataRejectionPromise;
  cupDataRejections: (
    args?: {
      where?: CupDataRejectionWhereInput;
      orderBy?: CupDataRejectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataRejection>;
  cupDataRejectionsConnection: (
    args?: {
      where?: CupDataRejectionWhereInput;
      orderBy?: CupDataRejectionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataRejectionConnectionPromise;
  cupDataUserRemove: (
    where: CupDataUserRemoveWhereUniqueInput
  ) => CupDataUserRemovePromise;
  cupDataUserRemoves: (
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataUserRemove>;
  cupDataUserRemovesConnection: (
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataUserRemoveConnectionPromise;
  cupDataUserRemoveExplain: (
    where: CupDataUserRemoveExplainWhereUniqueInput
  ) => CupDataUserRemoveExplainPromise;
  cupDataUserRemoveExplains: (
    args?: {
      where?: CupDataUserRemoveExplainWhereInput;
      orderBy?: CupDataUserRemoveExplainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDataUserRemoveExplain>;
  cupDataUserRemoveExplainsConnection: (
    args?: {
      where?: CupDataUserRemoveExplainWhereInput;
      orderBy?: CupDataUserRemoveExplainOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDataUserRemoveExplainConnectionPromise;
  cupDatum: (where: CupDatumWhereUniqueInput) => CupDatumPromise;
  cupData: (
    args?: {
      where?: CupDatumWhereInput;
      orderBy?: CupDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CupDatum>;
  cupDataConnection: (
    args?: {
      where?: CupDatumWhereInput;
      orderBy?: CupDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CupDatumConnectionPromise;
  ethnicity: (where: EthnicityWhereUniqueInput) => EthnicityPromise;
  ethnicities: (
    args?: {
      where?: EthnicityWhereInput;
      orderBy?: EthnicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Ethnicity>;
  ethnicitiesConnection: (
    args?: {
      where?: EthnicityWhereInput;
      orderBy?: EthnicityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EthnicityConnectionPromise;
  firmware: (where: FirmwareWhereUniqueInput) => FirmwarePromise;
  firmwares: (
    args?: {
      where?: FirmwareWhereInput;
      orderBy?: FirmwareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Firmware>;
  firmwaresConnection: (
    args?: {
      where?: FirmwareWhereInput;
      orderBy?: FirmwareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FirmwareConnectionPromise;
  hardware: (where: HardwareWhereUniqueInput) => HardwarePromise;
  hardwares: (
    args?: {
      where?: HardwareWhereInput;
      orderBy?: HardwareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Hardware>;
  hardwaresConnection: (
    args?: {
      where?: HardwareWhereInput;
      orderBy?: HardwareOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HardwareConnectionPromise;
  platformComp: (where: PlatformCompWhereUniqueInput) => PlatformCompPromise;
  platformComps: (
    args?: {
      where?: PlatformCompWhereInput;
      orderBy?: PlatformCompOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PlatformComp>;
  platformCompsConnection: (
    args?: {
      where?: PlatformCompWhereInput;
      orderBy?: PlatformCompOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PlatformCompConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userCoinHistory: (
    where: UserCoinHistoryWhereUniqueInput
  ) => UserCoinHistoryPromise;
  userCoinHistories: (
    args?: {
      where?: UserCoinHistoryWhereInput;
      orderBy?: UserCoinHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserCoinHistory>;
  userCoinHistoriesConnection: (
    args?: {
      where?: UserCoinHistoryWhereInput;
      orderBy?: UserCoinHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserCoinHistoryConnectionPromise;
  userCup: (where: UserCupWhereUniqueInput) => UserCupPromise;
  userCups: (
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserCup>;
  userCupsConnection: (
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserCupConnectionPromise;
  userInterviewDatum: (
    where: UserInterviewDatumWhereUniqueInput
  ) => UserInterviewDatumPromise;
  userInterviewData: (
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserInterviewDatum>;
  userInterviewDataConnection: (
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserInterviewDatumConnectionPromise;
  userInterviewQuestion: (
    where: UserInterviewQuestionWhereUniqueInput
  ) => UserInterviewQuestionPromise;
  userInterviewQuestions: (
    args?: {
      where?: UserInterviewQuestionWhereInput;
      orderBy?: UserInterviewQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserInterviewQuestion>;
  userInterviewQuestionsConnection: (
    args?: {
      where?: UserInterviewQuestionWhereInput;
      orderBy?: UserInterviewQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserInterviewQuestionConnectionPromise;
  userRecordDataByDay: (
    where: UserRecordDataByDayWhereUniqueInput
  ) => UserRecordDataByDayPromise;
  userRecordDataByDays: (
    args?: {
      where?: UserRecordDataByDayWhereInput;
      orderBy?: UserRecordDataByDayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRecordDataByDay>;
  userRecordDataByDaysConnection: (
    args?: {
      where?: UserRecordDataByDayWhereInput;
      orderBy?: UserRecordDataByDayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRecordDataByDayConnectionPromise;
  userRecordDataByPeriod: (
    where: UserRecordDataByPeriodWhereUniqueInput
  ) => UserRecordDataByPeriodPromise;
  userRecordDataByPeriods: (
    args?: {
      where?: UserRecordDataByPeriodWhereInput;
      orderBy?: UserRecordDataByPeriodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRecordDataByPeriod>;
  userRecordDataByPeriodsConnection: (
    args?: {
      where?: UserRecordDataByPeriodWhereInput;
      orderBy?: UserRecordDataByPeriodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRecordDataByPeriodConnectionPromise;
  userRecordDataByTime: (
    where: UserRecordDataByTimeWhereUniqueInput
  ) => UserRecordDataByTimePromise;
  userRecordDataByTimes: (
    args?: {
      where?: UserRecordDataByTimeWhereInput;
      orderBy?: UserRecordDataByTimeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRecordDataByTime>;
  userRecordDataByTimesConnection: (
    args?: {
      where?: UserRecordDataByTimeWhereInput;
      orderBy?: UserRecordDataByTimeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRecordDataByTimeConnectionPromise;
  usersDataAnalysis: (
    where: UsersDataAnalysisWhereUniqueInput
  ) => UsersDataAnalysisPromise;
  usersDataAnalyses: (
    args?: {
      where?: UsersDataAnalysisWhereInput;
      orderBy?: UsersDataAnalysisOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UsersDataAnalysis>;
  usersDataAnalysesConnection: (
    args?: {
      where?: UsersDataAnalysisWhereInput;
      orderBy?: UsersDataAnalysisOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UsersDataAnalysisConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAnswerType: (data: AnswerTypeCreateInput) => AnswerTypePromise;
  updateAnswerType: (
    args: { data: AnswerTypeUpdateInput; where: AnswerTypeWhereUniqueInput }
  ) => AnswerTypePromise;
  updateManyAnswerTypes: (
    args: {
      data: AnswerTypeUpdateManyMutationInput;
      where?: AnswerTypeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAnswerType: (
    args: {
      where: AnswerTypeWhereUniqueInput;
      create: AnswerTypeCreateInput;
      update: AnswerTypeUpdateInput;
    }
  ) => AnswerTypePromise;
  deleteAnswerType: (where: AnswerTypeWhereUniqueInput) => AnswerTypePromise;
  deleteManyAnswerTypes: (where?: AnswerTypeWhereInput) => BatchPayloadPromise;
  createAppServerSync: (data: AppServerSyncCreateInput) => AppServerSyncPromise;
  updateAppServerSync: (
    args: {
      data: AppServerSyncUpdateInput;
      where: AppServerSyncWhereUniqueInput;
    }
  ) => AppServerSyncPromise;
  updateManyAppServerSyncs: (
    args: {
      data: AppServerSyncUpdateManyMutationInput;
      where?: AppServerSyncWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAppServerSync: (
    args: {
      where: AppServerSyncWhereUniqueInput;
      create: AppServerSyncCreateInput;
      update: AppServerSyncUpdateInput;
    }
  ) => AppServerSyncPromise;
  deleteAppServerSync: (
    where: AppServerSyncWhereUniqueInput
  ) => AppServerSyncPromise;
  deleteManyAppServerSyncs: (
    where?: AppServerSyncWhereInput
  ) => BatchPayloadPromise;
  createAuthToken: () => AuthTokenPromise;
  deleteAuthToken: (where: AuthTokenWhereUniqueInput) => AuthTokenPromise;
  deleteManyAuthTokens: (where?: AuthTokenWhereInput) => BatchPayloadPromise;
  createCalibration: (data: CalibrationCreateInput) => CalibrationPromise;
  updateCalibration: (
    args: { data: CalibrationUpdateInput; where: CalibrationWhereUniqueInput }
  ) => CalibrationPromise;
  updateManyCalibrations: (
    args: {
      data: CalibrationUpdateManyMutationInput;
      where?: CalibrationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCalibration: (
    args: {
      where: CalibrationWhereUniqueInput;
      create: CalibrationCreateInput;
      update: CalibrationUpdateInput;
    }
  ) => CalibrationPromise;
  deleteCalibration: (where: CalibrationWhereUniqueInput) => CalibrationPromise;
  deleteManyCalibrations: (
    where?: CalibrationWhereInput
  ) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (
    args: { data: CompanyUpdateInput; where: CompanyWhereUniqueInput }
  ) => CompanyPromise;
  updateManyCompanies: (
    args: { data: CompanyUpdateManyMutationInput; where?: CompanyWhereInput }
  ) => BatchPayloadPromise;
  upsertCompany: (
    args: {
      where: CompanyWhereUniqueInput;
      create: CompanyCreateInput;
      update: CompanyUpdateInput;
    }
  ) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createCountry: (data: CountryCreateInput) => CountryPromise;
  updateCountry: (
    args: { data: CountryUpdateInput; where: CountryWhereUniqueInput }
  ) => CountryPromise;
  updateManyCountries: (
    args: { data: CountryUpdateManyMutationInput; where?: CountryWhereInput }
  ) => BatchPayloadPromise;
  upsertCountry: (
    args: {
      where: CountryWhereUniqueInput;
      create: CountryCreateInput;
      update: CountryUpdateInput;
    }
  ) => CountryPromise;
  deleteCountry: (where: CountryWhereUniqueInput) => CountryPromise;
  deleteManyCountries: (where?: CountryWhereInput) => BatchPayloadPromise;
  createCup: (data: CupCreateInput) => CupPromise;
  updateCup: (
    args: { data: CupUpdateInput; where: CupWhereUniqueInput }
  ) => CupPromise;
  updateManyCups: (
    args: { data: CupUpdateManyMutationInput; where?: CupWhereInput }
  ) => BatchPayloadPromise;
  upsertCup: (
    args: {
      where: CupWhereUniqueInput;
      create: CupCreateInput;
      update: CupUpdateInput;
    }
  ) => CupPromise;
  deleteCup: (where: CupWhereUniqueInput) => CupPromise;
  deleteManyCups: (where?: CupWhereInput) => BatchPayloadPromise;
  createCupAppSync: (data: CupAppSyncCreateInput) => CupAppSyncPromise;
  updateCupAppSync: (
    args: { data: CupAppSyncUpdateInput; where: CupAppSyncWhereUniqueInput }
  ) => CupAppSyncPromise;
  updateManyCupAppSyncs: (
    args: {
      data: CupAppSyncUpdateManyMutationInput;
      where?: CupAppSyncWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupAppSync: (
    args: {
      where: CupAppSyncWhereUniqueInput;
      create: CupAppSyncCreateInput;
      update: CupAppSyncUpdateInput;
    }
  ) => CupAppSyncPromise;
  deleteCupAppSync: (where: CupAppSyncWhereUniqueInput) => CupAppSyncPromise;
  deleteManyCupAppSyncs: (where?: CupAppSyncWhereInput) => BatchPayloadPromise;
  createCupDataAnswer: (data: CupDataAnswerCreateInput) => CupDataAnswerPromise;
  updateCupDataAnswer: (
    args: {
      data: CupDataAnswerUpdateInput;
      where: CupDataAnswerWhereUniqueInput;
    }
  ) => CupDataAnswerPromise;
  updateManyCupDataAnswers: (
    args: {
      data: CupDataAnswerUpdateManyMutationInput;
      where?: CupDataAnswerWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataAnswer: (
    args: {
      where: CupDataAnswerWhereUniqueInput;
      create: CupDataAnswerCreateInput;
      update: CupDataAnswerUpdateInput;
    }
  ) => CupDataAnswerPromise;
  deleteCupDataAnswer: (
    where: CupDataAnswerWhereUniqueInput
  ) => CupDataAnswerPromise;
  deleteManyCupDataAnswers: (
    where?: CupDataAnswerWhereInput
  ) => BatchPayloadPromise;
  createCupDataColourCalc: (
    data: CupDataColourCalcCreateInput
  ) => CupDataColourCalcPromise;
  updateCupDataColourCalc: (
    args: {
      data: CupDataColourCalcUpdateInput;
      where: CupDataColourCalcWhereUniqueInput;
    }
  ) => CupDataColourCalcPromise;
  updateManyCupDataColourCalcs: (
    args: {
      data: CupDataColourCalcUpdateManyMutationInput;
      where?: CupDataColourCalcWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataColourCalc: (
    args: {
      where: CupDataColourCalcWhereUniqueInput;
      create: CupDataColourCalcCreateInput;
      update: CupDataColourCalcUpdateInput;
    }
  ) => CupDataColourCalcPromise;
  deleteCupDataColourCalc: (
    where: CupDataColourCalcWhereUniqueInput
  ) => CupDataColourCalcPromise;
  deleteManyCupDataColourCalcs: (
    where?: CupDataColourCalcWhereInput
  ) => BatchPayloadPromise;
  createCupDataColourCalib: (
    data: CupDataColourCalibCreateInput
  ) => CupDataColourCalibPromise;
  updateCupDataColourCalib: (
    args: {
      data: CupDataColourCalibUpdateInput;
      where: CupDataColourCalibWhereUniqueInput;
    }
  ) => CupDataColourCalibPromise;
  updateManyCupDataColourCalibs: (
    args: {
      data: CupDataColourCalibUpdateManyMutationInput;
      where?: CupDataColourCalibWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataColourCalib: (
    args: {
      where: CupDataColourCalibWhereUniqueInput;
      create: CupDataColourCalibCreateInput;
      update: CupDataColourCalibUpdateInput;
    }
  ) => CupDataColourCalibPromise;
  deleteCupDataColourCalib: (
    where: CupDataColourCalibWhereUniqueInput
  ) => CupDataColourCalibPromise;
  deleteManyCupDataColourCalibs: (
    where?: CupDataColourCalibWhereInput
  ) => BatchPayloadPromise;
  createCupDataManMdate: (
    data: CupDataManMdateCreateInput
  ) => CupDataManMdatePromise;
  updateCupDataManMdate: (
    args: {
      data: CupDataManMdateUpdateInput;
      where: CupDataManMdateWhereUniqueInput;
    }
  ) => CupDataManMdatePromise;
  updateManyCupDataManMdates: (
    args: {
      data: CupDataManMdateUpdateManyMutationInput;
      where?: CupDataManMdateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataManMdate: (
    args: {
      where: CupDataManMdateWhereUniqueInput;
      create: CupDataManMdateCreateInput;
      update: CupDataManMdateUpdateInput;
    }
  ) => CupDataManMdatePromise;
  deleteCupDataManMdate: (
    where: CupDataManMdateWhereUniqueInput
  ) => CupDataManMdatePromise;
  deleteManyCupDataManMdates: (
    where?: CupDataManMdateWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcFlow: (
    data: CupDataProcFlowCreateInput
  ) => CupDataProcFlowPromise;
  updateCupDataProcFlow: (
    args: {
      data: CupDataProcFlowUpdateInput;
      where: CupDataProcFlowWhereUniqueInput;
    }
  ) => CupDataProcFlowPromise;
  updateManyCupDataProcFlows: (
    args: {
      data: CupDataProcFlowUpdateManyMutationInput;
      where?: CupDataProcFlowWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataProcFlow: (
    args: {
      where: CupDataProcFlowWhereUniqueInput;
      create: CupDataProcFlowCreateInput;
      update: CupDataProcFlowUpdateInput;
    }
  ) => CupDataProcFlowPromise;
  deleteCupDataProcFlow: (
    where: CupDataProcFlowWhereUniqueInput
  ) => CupDataProcFlowPromise;
  deleteManyCupDataProcFlows: (
    where?: CupDataProcFlowWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcMdate: (
    data: CupDataProcMdateCreateInput
  ) => CupDataProcMdatePromise;
  updateCupDataProcMdate: (
    args: {
      data: CupDataProcMdateUpdateInput;
      where: CupDataProcMdateWhereUniqueInput;
    }
  ) => CupDataProcMdatePromise;
  updateManyCupDataProcMdates: (
    args: {
      data: CupDataProcMdateUpdateManyMutationInput;
      where?: CupDataProcMdateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataProcMdate: (
    args: {
      where: CupDataProcMdateWhereUniqueInput;
      create: CupDataProcMdateCreateInput;
      update: CupDataProcMdateUpdateInput;
    }
  ) => CupDataProcMdatePromise;
  deleteCupDataProcMdate: (
    where: CupDataProcMdateWhereUniqueInput
  ) => CupDataProcMdatePromise;
  deleteManyCupDataProcMdates: (
    where?: CupDataProcMdateWhereInput
  ) => BatchPayloadPromise;
  createCupDataProcVolume: (
    data: CupDataProcVolumeCreateInput
  ) => CupDataProcVolumePromise;
  updateCupDataProcVolume: (
    args: {
      data: CupDataProcVolumeUpdateInput;
      where: CupDataProcVolumeWhereUniqueInput;
    }
  ) => CupDataProcVolumePromise;
  updateManyCupDataProcVolumes: (
    args: {
      data: CupDataProcVolumeUpdateManyMutationInput;
      where?: CupDataProcVolumeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataProcVolume: (
    args: {
      where: CupDataProcVolumeWhereUniqueInput;
      create: CupDataProcVolumeCreateInput;
      update: CupDataProcVolumeUpdateInput;
    }
  ) => CupDataProcVolumePromise;
  deleteCupDataProcVolume: (
    where: CupDataProcVolumeWhereUniqueInput
  ) => CupDataProcVolumePromise;
  deleteManyCupDataProcVolumes: (
    where?: CupDataProcVolumeWhereInput
  ) => BatchPayloadPromise;
  createCupDataQaResponse: (
    data: CupDataQaResponseCreateInput
  ) => CupDataQaResponsePromise;
  updateCupDataQaResponse: (
    args: {
      data: CupDataQaResponseUpdateInput;
      where: CupDataQaResponseWhereUniqueInput;
    }
  ) => CupDataQaResponsePromise;
  updateManyCupDataQaResponses: (
    args: {
      data: CupDataQaResponseUpdateManyMutationInput;
      where?: CupDataQaResponseWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataQaResponse: (
    args: {
      where: CupDataQaResponseWhereUniqueInput;
      create: CupDataQaResponseCreateInput;
      update: CupDataQaResponseUpdateInput;
    }
  ) => CupDataQaResponsePromise;
  deleteCupDataQaResponse: (
    where: CupDataQaResponseWhereUniqueInput
  ) => CupDataQaResponsePromise;
  deleteManyCupDataQaResponses: (
    where?: CupDataQaResponseWhereInput
  ) => BatchPayloadPromise;
  createCupDataQuestion: (
    data: CupDataQuestionCreateInput
  ) => CupDataQuestionPromise;
  updateCupDataQuestion: (
    args: {
      data: CupDataQuestionUpdateInput;
      where: CupDataQuestionWhereUniqueInput;
    }
  ) => CupDataQuestionPromise;
  updateManyCupDataQuestions: (
    args: {
      data: CupDataQuestionUpdateManyMutationInput;
      where?: CupDataQuestionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataQuestion: (
    args: {
      where: CupDataQuestionWhereUniqueInput;
      create: CupDataQuestionCreateInput;
      update: CupDataQuestionUpdateInput;
    }
  ) => CupDataQuestionPromise;
  deleteCupDataQuestion: (
    where: CupDataQuestionWhereUniqueInput
  ) => CupDataQuestionPromise;
  deleteManyCupDataQuestions: (
    where?: CupDataQuestionWhereInput
  ) => BatchPayloadPromise;
  createCupDataRaw: (data: CupDataRawCreateInput) => CupDataRawPromise;
  updateCupDataRaw: (
    args: { data: CupDataRawUpdateInput; where: CupDataRawWhereUniqueInput }
  ) => CupDataRawPromise;
  updateManyCupDataRaws: (
    args: {
      data: CupDataRawUpdateManyMutationInput;
      where?: CupDataRawWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataRaw: (
    args: {
      where: CupDataRawWhereUniqueInput;
      create: CupDataRawCreateInput;
      update: CupDataRawUpdateInput;
    }
  ) => CupDataRawPromise;
  deleteCupDataRaw: (where: CupDataRawWhereUniqueInput) => CupDataRawPromise;
  deleteManyCupDataRaws: (where?: CupDataRawWhereInput) => BatchPayloadPromise;
  createCupDataRejection: (
    data: CupDataRejectionCreateInput
  ) => CupDataRejectionPromise;
  updateCupDataRejection: (
    args: {
      data: CupDataRejectionUpdateInput;
      where: CupDataRejectionWhereUniqueInput;
    }
  ) => CupDataRejectionPromise;
  updateManyCupDataRejections: (
    args: {
      data: CupDataRejectionUpdateManyMutationInput;
      where?: CupDataRejectionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataRejection: (
    args: {
      where: CupDataRejectionWhereUniqueInput;
      create: CupDataRejectionCreateInput;
      update: CupDataRejectionUpdateInput;
    }
  ) => CupDataRejectionPromise;
  deleteCupDataRejection: (
    where: CupDataRejectionWhereUniqueInput
  ) => CupDataRejectionPromise;
  deleteManyCupDataRejections: (
    where?: CupDataRejectionWhereInput
  ) => BatchPayloadPromise;
  createCupDataUserRemove: (
    data: CupDataUserRemoveCreateInput
  ) => CupDataUserRemovePromise;
  updateCupDataUserRemove: (
    args: {
      data: CupDataUserRemoveUpdateInput;
      where: CupDataUserRemoveWhereUniqueInput;
    }
  ) => CupDataUserRemovePromise;
  updateManyCupDataUserRemoves: (
    args: {
      data: CupDataUserRemoveUpdateManyMutationInput;
      where?: CupDataUserRemoveWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataUserRemove: (
    args: {
      where: CupDataUserRemoveWhereUniqueInput;
      create: CupDataUserRemoveCreateInput;
      update: CupDataUserRemoveUpdateInput;
    }
  ) => CupDataUserRemovePromise;
  deleteCupDataUserRemove: (
    where: CupDataUserRemoveWhereUniqueInput
  ) => CupDataUserRemovePromise;
  deleteManyCupDataUserRemoves: (
    where?: CupDataUserRemoveWhereInput
  ) => BatchPayloadPromise;
  createCupDataUserRemoveExplain: (
    data: CupDataUserRemoveExplainCreateInput
  ) => CupDataUserRemoveExplainPromise;
  updateCupDataUserRemoveExplain: (
    args: {
      data: CupDataUserRemoveExplainUpdateInput;
      where: CupDataUserRemoveExplainWhereUniqueInput;
    }
  ) => CupDataUserRemoveExplainPromise;
  updateManyCupDataUserRemoveExplains: (
    args: {
      data: CupDataUserRemoveExplainUpdateManyMutationInput;
      where?: CupDataUserRemoveExplainWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCupDataUserRemoveExplain: (
    args: {
      where: CupDataUserRemoveExplainWhereUniqueInput;
      create: CupDataUserRemoveExplainCreateInput;
      update: CupDataUserRemoveExplainUpdateInput;
    }
  ) => CupDataUserRemoveExplainPromise;
  deleteCupDataUserRemoveExplain: (
    where: CupDataUserRemoveExplainWhereUniqueInput
  ) => CupDataUserRemoveExplainPromise;
  deleteManyCupDataUserRemoveExplains: (
    where?: CupDataUserRemoveExplainWhereInput
  ) => BatchPayloadPromise;
  createCupDatum: (data: CupDatumCreateInput) => CupDatumPromise;
  updateCupDatum: (
    args: { data: CupDatumUpdateInput; where: CupDatumWhereUniqueInput }
  ) => CupDatumPromise;
  updateManyCupData: (
    args: { data: CupDatumUpdateManyMutationInput; where?: CupDatumWhereInput }
  ) => BatchPayloadPromise;
  upsertCupDatum: (
    args: {
      where: CupDatumWhereUniqueInput;
      create: CupDatumCreateInput;
      update: CupDatumUpdateInput;
    }
  ) => CupDatumPromise;
  deleteCupDatum: (where: CupDatumWhereUniqueInput) => CupDatumPromise;
  deleteManyCupData: (where?: CupDatumWhereInput) => BatchPayloadPromise;
  createEthnicity: (data: EthnicityCreateInput) => EthnicityPromise;
  updateEthnicity: (
    args: { data: EthnicityUpdateInput; where: EthnicityWhereUniqueInput }
  ) => EthnicityPromise;
  updateManyEthnicities: (
    args: {
      data: EthnicityUpdateManyMutationInput;
      where?: EthnicityWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertEthnicity: (
    args: {
      where: EthnicityWhereUniqueInput;
      create: EthnicityCreateInput;
      update: EthnicityUpdateInput;
    }
  ) => EthnicityPromise;
  deleteEthnicity: (where: EthnicityWhereUniqueInput) => EthnicityPromise;
  deleteManyEthnicities: (where?: EthnicityWhereInput) => BatchPayloadPromise;
  createFirmware: (data: FirmwareCreateInput) => FirmwarePromise;
  updateFirmware: (
    args: { data: FirmwareUpdateInput; where: FirmwareWhereUniqueInput }
  ) => FirmwarePromise;
  updateManyFirmwares: (
    args: { data: FirmwareUpdateManyMutationInput; where?: FirmwareWhereInput }
  ) => BatchPayloadPromise;
  upsertFirmware: (
    args: {
      where: FirmwareWhereUniqueInput;
      create: FirmwareCreateInput;
      update: FirmwareUpdateInput;
    }
  ) => FirmwarePromise;
  deleteFirmware: (where: FirmwareWhereUniqueInput) => FirmwarePromise;
  deleteManyFirmwares: (where?: FirmwareWhereInput) => BatchPayloadPromise;
  createHardware: (data: HardwareCreateInput) => HardwarePromise;
  updateHardware: (
    args: { data: HardwareUpdateInput; where: HardwareWhereUniqueInput }
  ) => HardwarePromise;
  updateManyHardwares: (
    args: { data: HardwareUpdateManyMutationInput; where?: HardwareWhereInput }
  ) => BatchPayloadPromise;
  upsertHardware: (
    args: {
      where: HardwareWhereUniqueInput;
      create: HardwareCreateInput;
      update: HardwareUpdateInput;
    }
  ) => HardwarePromise;
  deleteHardware: (where: HardwareWhereUniqueInput) => HardwarePromise;
  deleteManyHardwares: (where?: HardwareWhereInput) => BatchPayloadPromise;
  createPlatformComp: (data: PlatformCompCreateInput) => PlatformCompPromise;
  updatePlatformComp: (
    args: { data: PlatformCompUpdateInput; where: PlatformCompWhereUniqueInput }
  ) => PlatformCompPromise;
  updateManyPlatformComps: (
    args: {
      data: PlatformCompUpdateManyMutationInput;
      where?: PlatformCompWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPlatformComp: (
    args: {
      where: PlatformCompWhereUniqueInput;
      create: PlatformCompCreateInput;
      update: PlatformCompUpdateInput;
    }
  ) => PlatformCompPromise;
  deletePlatformComp: (
    where: PlatformCompWhereUniqueInput
  ) => PlatformCompPromise;
  deleteManyPlatformComps: (
    where?: PlatformCompWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserCoinHistory: (
    data: UserCoinHistoryCreateInput
  ) => UserCoinHistoryPromise;
  updateUserCoinHistory: (
    args: {
      data: UserCoinHistoryUpdateInput;
      where: UserCoinHistoryWhereUniqueInput;
    }
  ) => UserCoinHistoryPromise;
  updateManyUserCoinHistories: (
    args: {
      data: UserCoinHistoryUpdateManyMutationInput;
      where?: UserCoinHistoryWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserCoinHistory: (
    args: {
      where: UserCoinHistoryWhereUniqueInput;
      create: UserCoinHistoryCreateInput;
      update: UserCoinHistoryUpdateInput;
    }
  ) => UserCoinHistoryPromise;
  deleteUserCoinHistory: (
    where: UserCoinHistoryWhereUniqueInput
  ) => UserCoinHistoryPromise;
  deleteManyUserCoinHistories: (
    where?: UserCoinHistoryWhereInput
  ) => BatchPayloadPromise;
  createUserCup: (data: UserCupCreateInput) => UserCupPromise;
  updateUserCup: (
    args: { data: UserCupUpdateInput; where: UserCupWhereUniqueInput }
  ) => UserCupPromise;
  upsertUserCup: (
    args: {
      where: UserCupWhereUniqueInput;
      create: UserCupCreateInput;
      update: UserCupUpdateInput;
    }
  ) => UserCupPromise;
  deleteUserCup: (where: UserCupWhereUniqueInput) => UserCupPromise;
  deleteManyUserCups: (where?: UserCupWhereInput) => BatchPayloadPromise;
  createUserInterviewDatum: (
    data: UserInterviewDatumCreateInput
  ) => UserInterviewDatumPromise;
  updateUserInterviewDatum: (
    args: {
      data: UserInterviewDatumUpdateInput;
      where: UserInterviewDatumWhereUniqueInput;
    }
  ) => UserInterviewDatumPromise;
  updateManyUserInterviewData: (
    args: {
      data: UserInterviewDatumUpdateManyMutationInput;
      where?: UserInterviewDatumWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserInterviewDatum: (
    args: {
      where: UserInterviewDatumWhereUniqueInput;
      create: UserInterviewDatumCreateInput;
      update: UserInterviewDatumUpdateInput;
    }
  ) => UserInterviewDatumPromise;
  deleteUserInterviewDatum: (
    where: UserInterviewDatumWhereUniqueInput
  ) => UserInterviewDatumPromise;
  deleteManyUserInterviewData: (
    where?: UserInterviewDatumWhereInput
  ) => BatchPayloadPromise;
  createUserInterviewQuestion: (
    data: UserInterviewQuestionCreateInput
  ) => UserInterviewQuestionPromise;
  updateUserInterviewQuestion: (
    args: {
      data: UserInterviewQuestionUpdateInput;
      where: UserInterviewQuestionWhereUniqueInput;
    }
  ) => UserInterviewQuestionPromise;
  updateManyUserInterviewQuestions: (
    args: {
      data: UserInterviewQuestionUpdateManyMutationInput;
      where?: UserInterviewQuestionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserInterviewQuestion: (
    args: {
      where: UserInterviewQuestionWhereUniqueInput;
      create: UserInterviewQuestionCreateInput;
      update: UserInterviewQuestionUpdateInput;
    }
  ) => UserInterviewQuestionPromise;
  deleteUserInterviewQuestion: (
    where: UserInterviewQuestionWhereUniqueInput
  ) => UserInterviewQuestionPromise;
  deleteManyUserInterviewQuestions: (
    where?: UserInterviewQuestionWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByDay: (
    data: UserRecordDataByDayCreateInput
  ) => UserRecordDataByDayPromise;
  updateUserRecordDataByDay: (
    args: {
      data: UserRecordDataByDayUpdateInput;
      where: UserRecordDataByDayWhereUniqueInput;
    }
  ) => UserRecordDataByDayPromise;
  updateManyUserRecordDataByDays: (
    args: {
      data: UserRecordDataByDayUpdateManyMutationInput;
      where?: UserRecordDataByDayWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserRecordDataByDay: (
    args: {
      where: UserRecordDataByDayWhereUniqueInput;
      create: UserRecordDataByDayCreateInput;
      update: UserRecordDataByDayUpdateInput;
    }
  ) => UserRecordDataByDayPromise;
  deleteUserRecordDataByDay: (
    where: UserRecordDataByDayWhereUniqueInput
  ) => UserRecordDataByDayPromise;
  deleteManyUserRecordDataByDays: (
    where?: UserRecordDataByDayWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByPeriod: (
    data: UserRecordDataByPeriodCreateInput
  ) => UserRecordDataByPeriodPromise;
  updateUserRecordDataByPeriod: (
    args: {
      data: UserRecordDataByPeriodUpdateInput;
      where: UserRecordDataByPeriodWhereUniqueInput;
    }
  ) => UserRecordDataByPeriodPromise;
  updateManyUserRecordDataByPeriods: (
    args: {
      data: UserRecordDataByPeriodUpdateManyMutationInput;
      where?: UserRecordDataByPeriodWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserRecordDataByPeriod: (
    args: {
      where: UserRecordDataByPeriodWhereUniqueInput;
      create: UserRecordDataByPeriodCreateInput;
      update: UserRecordDataByPeriodUpdateInput;
    }
  ) => UserRecordDataByPeriodPromise;
  deleteUserRecordDataByPeriod: (
    where: UserRecordDataByPeriodWhereUniqueInput
  ) => UserRecordDataByPeriodPromise;
  deleteManyUserRecordDataByPeriods: (
    where?: UserRecordDataByPeriodWhereInput
  ) => BatchPayloadPromise;
  createUserRecordDataByTime: (
    data: UserRecordDataByTimeCreateInput
  ) => UserRecordDataByTimePromise;
  updateUserRecordDataByTime: (
    args: {
      data: UserRecordDataByTimeUpdateInput;
      where: UserRecordDataByTimeWhereUniqueInput;
    }
  ) => UserRecordDataByTimePromise;
  updateManyUserRecordDataByTimes: (
    args: {
      data: UserRecordDataByTimeUpdateManyMutationInput;
      where?: UserRecordDataByTimeWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUserRecordDataByTime: (
    args: {
      where: UserRecordDataByTimeWhereUniqueInput;
      create: UserRecordDataByTimeCreateInput;
      update: UserRecordDataByTimeUpdateInput;
    }
  ) => UserRecordDataByTimePromise;
  deleteUserRecordDataByTime: (
    where: UserRecordDataByTimeWhereUniqueInput
  ) => UserRecordDataByTimePromise;
  deleteManyUserRecordDataByTimes: (
    where?: UserRecordDataByTimeWhereInput
  ) => BatchPayloadPromise;
  createUsersDataAnalysis: (
    data: UsersDataAnalysisCreateInput
  ) => UsersDataAnalysisPromise;
  updateUsersDataAnalysis: (
    args: {
      data: UsersDataAnalysisUpdateInput;
      where: UsersDataAnalysisWhereUniqueInput;
    }
  ) => UsersDataAnalysisPromise;
  updateManyUsersDataAnalyses: (
    args: {
      data: UsersDataAnalysisUpdateManyMutationInput;
      where?: UsersDataAnalysisWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertUsersDataAnalysis: (
    args: {
      where: UsersDataAnalysisWhereUniqueInput;
      create: UsersDataAnalysisCreateInput;
      update: UsersDataAnalysisUpdateInput;
    }
  ) => UsersDataAnalysisPromise;
  deleteUsersDataAnalysis: (
    where: UsersDataAnalysisWhereUniqueInput
  ) => UsersDataAnalysisPromise;
  deleteManyUsersDataAnalyses: (
    where?: UsersDataAnalysisWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  answerType: (
    where?: AnswerTypeSubscriptionWhereInput
  ) => AnswerTypeSubscriptionPayloadSubscription;
  appServerSync: (
    where?: AppServerSyncSubscriptionWhereInput
  ) => AppServerSyncSubscriptionPayloadSubscription;
  authToken: (
    where?: AuthTokenSubscriptionWhereInput
  ) => AuthTokenSubscriptionPayloadSubscription;
  calibration: (
    where?: CalibrationSubscriptionWhereInput
  ) => CalibrationSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  country: (
    where?: CountrySubscriptionWhereInput
  ) => CountrySubscriptionPayloadSubscription;
  cup: (
    where?: CupSubscriptionWhereInput
  ) => CupSubscriptionPayloadSubscription;
  cupAppSync: (
    where?: CupAppSyncSubscriptionWhereInput
  ) => CupAppSyncSubscriptionPayloadSubscription;
  cupDataAnswer: (
    where?: CupDataAnswerSubscriptionWhereInput
  ) => CupDataAnswerSubscriptionPayloadSubscription;
  cupDataColourCalc: (
    where?: CupDataColourCalcSubscriptionWhereInput
  ) => CupDataColourCalcSubscriptionPayloadSubscription;
  cupDataColourCalib: (
    where?: CupDataColourCalibSubscriptionWhereInput
  ) => CupDataColourCalibSubscriptionPayloadSubscription;
  cupDataManMdate: (
    where?: CupDataManMdateSubscriptionWhereInput
  ) => CupDataManMdateSubscriptionPayloadSubscription;
  cupDataProcFlow: (
    where?: CupDataProcFlowSubscriptionWhereInput
  ) => CupDataProcFlowSubscriptionPayloadSubscription;
  cupDataProcMdate: (
    where?: CupDataProcMdateSubscriptionWhereInput
  ) => CupDataProcMdateSubscriptionPayloadSubscription;
  cupDataProcVolume: (
    where?: CupDataProcVolumeSubscriptionWhereInput
  ) => CupDataProcVolumeSubscriptionPayloadSubscription;
  cupDataQaResponse: (
    where?: CupDataQaResponseSubscriptionWhereInput
  ) => CupDataQaResponseSubscriptionPayloadSubscription;
  cupDataQuestion: (
    where?: CupDataQuestionSubscriptionWhereInput
  ) => CupDataQuestionSubscriptionPayloadSubscription;
  cupDataRaw: (
    where?: CupDataRawSubscriptionWhereInput
  ) => CupDataRawSubscriptionPayloadSubscription;
  cupDataRejection: (
    where?: CupDataRejectionSubscriptionWhereInput
  ) => CupDataRejectionSubscriptionPayloadSubscription;
  cupDataUserRemove: (
    where?: CupDataUserRemoveSubscriptionWhereInput
  ) => CupDataUserRemoveSubscriptionPayloadSubscription;
  cupDataUserRemoveExplain: (
    where?: CupDataUserRemoveExplainSubscriptionWhereInput
  ) => CupDataUserRemoveExplainSubscriptionPayloadSubscription;
  cupDatum: (
    where?: CupDatumSubscriptionWhereInput
  ) => CupDatumSubscriptionPayloadSubscription;
  ethnicity: (
    where?: EthnicitySubscriptionWhereInput
  ) => EthnicitySubscriptionPayloadSubscription;
  firmware: (
    where?: FirmwareSubscriptionWhereInput
  ) => FirmwareSubscriptionPayloadSubscription;
  hardware: (
    where?: HardwareSubscriptionWhereInput
  ) => HardwareSubscriptionPayloadSubscription;
  platformComp: (
    where?: PlatformCompSubscriptionWhereInput
  ) => PlatformCompSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userCoinHistory: (
    where?: UserCoinHistorySubscriptionWhereInput
  ) => UserCoinHistorySubscriptionPayloadSubscription;
  userCup: (
    where?: UserCupSubscriptionWhereInput
  ) => UserCupSubscriptionPayloadSubscription;
  userInterviewDatum: (
    where?: UserInterviewDatumSubscriptionWhereInput
  ) => UserInterviewDatumSubscriptionPayloadSubscription;
  userInterviewQuestion: (
    where?: UserInterviewQuestionSubscriptionWhereInput
  ) => UserInterviewQuestionSubscriptionPayloadSubscription;
  userRecordDataByDay: (
    where?: UserRecordDataByDaySubscriptionWhereInput
  ) => UserRecordDataByDaySubscriptionPayloadSubscription;
  userRecordDataByPeriod: (
    where?: UserRecordDataByPeriodSubscriptionWhereInput
  ) => UserRecordDataByPeriodSubscriptionPayloadSubscription;
  userRecordDataByTime: (
    where?: UserRecordDataByTimeSubscriptionWhereInput
  ) => UserRecordDataByTimeSubscriptionPayloadSubscription;
  usersDataAnalysis: (
    where?: UsersDataAnalysisSubscriptionWhereInput
  ) => UsersDataAnalysisSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserCoinHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "coin_ASC"
  | "coin_DESC"
  | "contents_ASC"
  | "contents_DESC"
  | "date_ASC"
  | "date_DESC"
  | "txhash_ASC"
  | "txhash_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserInterviewQuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "question_ASC"
  | "question_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserCupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UsersDataAnalysisOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "password_ASC"
  | "password_DESC"
  | "userId_ASC"
  | "userId_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataRawOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "pageData_ASC"
  | "pageData_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HardwareOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "hwVersion_ASC"
  | "hwVersion_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataColourCalibOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blue_ASC"
  | "blue_DESC"
  | "c_ASC"
  | "c_DESC"
  | "green_ASC"
  | "green_DESC"
  | "red_ASC"
  | "red_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EthnicityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "ethnicity_ASC"
  | "ethnicity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataProcVolumeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "confidenceL_ASC"
  | "confidenceL_DESC"
  | "confidenceR_ASC"
  | "confidenceR_DESC"
  | "inVitro_ASC"
  | "inVitro_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "volumeAdj_ASC"
  | "volumeAdj_DESC"
  | "volumeL_ASC"
  | "volumeL_DESC"
  | "volumeR_ASC"
  | "volumeR_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataRejectionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "rejectionDescription_ASC"
  | "rejectionDescription_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataColourCalcOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "blue_ASC"
  | "blue_DESC"
  | "green_ASC"
  | "green_DESC"
  | "red_ASC"
  | "red_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CountryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "countryName_ASC"
  | "countryName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDatumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "battery_ASC"
  | "battery_DESC"
  | "calibFlag_ASC"
  | "calibFlag_DESC"
  | "ch1_ASC"
  | "ch1_DESC"
  | "ch10_ASC"
  | "ch10_DESC"
  | "ch11_ASC"
  | "ch11_DESC"
  | "ch12_ASC"
  | "ch12_DESC"
  | "ch13_ASC"
  | "ch13_DESC"
  | "ch14_ASC"
  | "ch14_DESC"
  | "ch2_ASC"
  | "ch2_DESC"
  | "ch3_ASC"
  | "ch3_DESC"
  | "ch4_ASC"
  | "ch4_DESC"
  | "ch5_ASC"
  | "ch5_DESC"
  | "ch6_ASC"
  | "ch6_DESC"
  | "ch7_ASC"
  | "ch7_DESC"
  | "ch8_ASC"
  | "ch8_DESC"
  | "ch9_ASC"
  | "ch9_DESC"
  | "colourB_ASC"
  | "colourB_DESC"
  | "colourC_ASC"
  | "colourC_DESC"
  | "colourG_ASC"
  | "colourG_DESC"
  | "colourR_ASC"
  | "colourR_DESC"
  | "date_ASC"
  | "date_DESC"
  | "day_ASC"
  | "day_DESC"
  | "hour_ASC"
  | "hour_DESC"
  | "line_ASC"
  | "line_DESC"
  | "minute_ASC"
  | "minute_DESC"
  | "month_ASC"
  | "month_DESC"
  | "page_ASC"
  | "page_DESC"
  | "rawTotalVolume_ASC"
  | "rawTotalVolume_DESC"
  | "rawVolumeL_ASC"
  | "rawVolumeL_DESC"
  | "rawVolumeR_ASC"
  | "rawVolumeR_DESC"
  | "temperature_ASC"
  | "temperature_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "year_ASC"
  | "year_DESC"
  | "z_ASC"
  | "z_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CalibrationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "calibVersion_ASC"
  | "calibVersion_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupAppSyncOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "appSynchTime_ASC"
  | "appSynchTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AnswerTypeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "answerType_ASC"
  | "answerType_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "anonSerialNumber_ASC"
  | "anonSerialNumber_DESC"
  | "encryptionKey_ASC"
  | "encryptionKey_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRecordDataByDayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "crampsLevel_ASC"
  | "crampsLevel_DESC"
  | "recordDate_ASC"
  | "recordDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataUserRemoveOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "changeTime_ASC"
  | "changeTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CupDataAnswerOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "answerText_ASC"
  | "answerText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FirmwareOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fwVersion_ASC"
  | "fwVersion_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataQaResponseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "qaDate_ASC"
  | "qaDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataQuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "questionText_ASC"
  | "questionText_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataProcMdateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "dataRejected_ASC"
  | "dataRejected_DESC"
  | "dataVerified_ASC"
  | "dataVerified_DESC"
  | "menFinish_ASC"
  | "menFinish_DESC"
  | "menStart_ASC"
  | "menStart_DESC"
  | "rewardAmount_ASC"
  | "rewardAmount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AuthTokenOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataManMdateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "menFinish_ASC"
  | "menFinish_DESC"
  | "menStart_ASC"
  | "menStart_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRecordDataByPeriodOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "coinHistoryRowId_ASC"
  | "coinHistoryRowId_DESC"
  | "isTakePill_ASC"
  | "isTakePill_DESC"
  | "mensFinish_ASC"
  | "mensFinish_DESC"
  | "mensStart_ASC"
  | "mensStart_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserInterviewDatumOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "answerRange_ASC"
  | "answerRange_DESC"
  | "answerText_ASC"
  | "answerText_DESC"
  | "answerYn_ASC"
  | "answerYn_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AppServerSyncOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "serverSynchTime_ASC"
  | "serverSynchTime_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "anonUserId_ASC"
  | "anonUserId_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "dob_ASC"
  | "dob_DESC"
  | "email_ASC"
  | "email_DESC"
  | "encryptSaltString_ASC"
  | "encryptSaltString_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "givenBirth_ASC"
  | "givenBirth_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataProcFlowOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "hourlyFlow_ASC"
  | "hourlyFlow_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PlatformCompOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "phoneId_ASC"
  | "phoneId_DESC"
  | "platformId_ASC"
  | "platformId_DESC"
  | "problemHistory_ASC"
  | "problemHistory_DESC"
  | "softwareId_ASC"
  | "softwareId_DESC"
  | "successHistory_ASC"
  | "successHistory_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRecordDataByTimeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "changeTime_ASC"
  | "changeTime_DESC"
  | "colorB_ASC"
  | "colorB_DESC"
  | "colorG_ASC"
  | "colorG_DESC"
  | "colorR_ASC"
  | "colorR_DESC"
  | "leakage_ASC"
  | "leakage_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "companyName_ASC"
  | "companyName_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CupDataUserRemoveExplainOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "explain_ASC"
  | "explain_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CupDataColourCalibUpdateWithoutSerialNumberDataInput {
  blue?: Int;
  c?: Int;
  green?: Int;
  red?: Int;
}

export type AnswerTypeWhereUniqueInput = AtLeastOne<{
  id: Int;
  answerType?: String;
}>;

export interface AppServerSyncUpdateWithWhereUniqueWithoutUserIdInput {
  where: AppServerSyncWhereUniqueInput;
  data: AppServerSyncUpdateWithoutUserIdDataInput;
}

export interface CupDataQaResponseUpdateInput {
  answerId?: CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput;
  qaDate?: DateTimeInput;
  questionId?: CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput;
  userId?: UserUpdateOneRequiredWithoutCupDataQaResponseInput;
}

export interface AppServerSyncUpdateWithoutUserIdDataInput {
  serverSynchTime?: DateTimeInput;
}

export interface UserCupUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: UserCupWhereUniqueInput;
  data: UserCupUpdateWithoutSerialNumberDataInput;
}

export interface AppServerSyncUpsertWithWhereUniqueWithoutUserIdInput {
  where: AppServerSyncWhereUniqueInput;
  update: AppServerSyncUpdateWithoutUserIdDataInput;
  create: AppServerSyncCreateWithoutUserIdInput;
}

export interface UserRecordDataByDayWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  crampsLevel?: Int;
  crampsLevel_not?: Int;
  crampsLevel_in?: Int[] | Int;
  crampsLevel_not_in?: Int[] | Int;
  crampsLevel_lt?: Int;
  crampsLevel_lte?: Int;
  crampsLevel_gt?: Int;
  crampsLevel_gte?: Int;
  recordDate?: DateTimeInput;
  recordDate_not?: DateTimeInput;
  recordDate_in?: DateTimeInput[] | DateTimeInput;
  recordDate_not_in?: DateTimeInput[] | DateTimeInput;
  recordDate_lt?: DateTimeInput;
  recordDate_lte?: DateTimeInput;
  recordDate_gt?: DateTimeInput;
  recordDate_gte?: DateTimeInput;
  recordPeriodRowId?: UserRecordDataByPeriodWhereInput;
  userRecordDataByTime_every?: UserRecordDataByTimeWhereInput;
  userRecordDataByTime_some?: UserRecordDataByTimeWhereInput;
  userRecordDataByTime_none?: UserRecordDataByTimeWhereInput;
  AND?: UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput;
  OR?: UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput;
  NOT?: UserRecordDataByDayWhereInput[] | UserRecordDataByDayWhereInput;
}

export interface AppServerSyncScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  serverSynchTime?: DateTimeInput;
  serverSynchTime_not?: DateTimeInput;
  serverSynchTime_in?: DateTimeInput[] | DateTimeInput;
  serverSynchTime_not_in?: DateTimeInput[] | DateTimeInput;
  serverSynchTime_lt?: DateTimeInput;
  serverSynchTime_lte?: DateTimeInput;
  serverSynchTime_gt?: DateTimeInput;
  serverSynchTime_gte?: DateTimeInput;
  AND?: AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput;
  OR?: AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput;
  NOT?: AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput;
}

export interface UserRecordDataByPeriodSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRecordDataByPeriodWhereInput;
  AND?:
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput;
  OR?:
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput;
  NOT?:
    | UserRecordDataByPeriodSubscriptionWhereInput[]
    | UserRecordDataByPeriodSubscriptionWhereInput;
}

export interface AppServerSyncUpdateManyWithWhereNestedInput {
  where: AppServerSyncScalarWhereInput;
  data: AppServerSyncUpdateManyDataInput;
}

export interface UserRecordDataByDaySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRecordDataByDayWhereInput;
  AND?:
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput;
  OR?:
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput;
  NOT?:
    | UserRecordDataByDaySubscriptionWhereInput[]
    | UserRecordDataByDaySubscriptionWhereInput;
}

export interface AppServerSyncUpdateManyDataInput {
  serverSynchTime?: DateTimeInput;
}

export interface UserCoinHistoryWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  category?: String;
  category_not?: String;
  category_in?: String[] | String;
  category_not_in?: String[] | String;
  category_lt?: String;
  category_lte?: String;
  category_gt?: String;
  category_gte?: String;
  category_contains?: String;
  category_not_contains?: String;
  category_starts_with?: String;
  category_not_starts_with?: String;
  category_ends_with?: String;
  category_not_ends_with?: String;
  coin?: Int;
  coin_not?: Int;
  coin_in?: Int[] | Int;
  coin_not_in?: Int[] | Int;
  coin_lt?: Int;
  coin_lte?: Int;
  coin_gt?: Int;
  coin_gte?: Int;
  contents?: String;
  contents_not?: String;
  contents_in?: String[] | String;
  contents_not_in?: String[] | String;
  contents_lt?: String;
  contents_lte?: String;
  contents_gt?: String;
  contents_gte?: String;
  contents_contains?: String;
  contents_not_contains?: String;
  contents_starts_with?: String;
  contents_not_starts_with?: String;
  contents_ends_with?: String;
  contents_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  txhash?: String;
  txhash_not?: String;
  txhash_in?: String[] | String;
  txhash_not_in?: String[] | String;
  txhash_lt?: String;
  txhash_lte?: String;
  txhash_gt?: String;
  txhash_gte?: String;
  txhash_contains?: String;
  txhash_not_contains?: String;
  txhash_starts_with?: String;
  txhash_not_starts_with?: String;
  txhash_ends_with?: String;
  txhash_not_ends_with?: String;
  userId?: UserWhereInput;
  AND?: UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput;
  OR?: UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput;
  NOT?: UserCoinHistoryWhereInput[] | UserCoinHistoryWhereInput;
}

export interface CountryUpdateOneWithoutUsersInput {
  create?: CountryCreateWithoutUsersInput;
  update?: CountryUpdateWithoutUsersDataInput;
  upsert?: CountryUpsertWithoutUsersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CountryWhereUniqueInput;
}

export interface UserInterviewDatumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserInterviewDatumWhereInput;
  AND?:
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput;
  OR?:
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput;
  NOT?:
    | UserInterviewDatumSubscriptionWhereInput[]
    | UserInterviewDatumSubscriptionWhereInput;
}

export interface CountryUpdateWithoutUsersDataInput {
  countryName?: String;
}

export interface UserCupWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  serialNumber?: CupWhereInput;
  userId?: UserWhereInput;
  AND?: UserCupWhereInput[] | UserCupWhereInput;
  OR?: UserCupWhereInput[] | UserCupWhereInput;
  NOT?: UserCupWhereInput[] | UserCupWhereInput;
}

export interface CountryUpsertWithoutUsersInput {
  update: CountryUpdateWithoutUsersDataInput;
  create: CountryCreateWithoutUsersInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CupDataProcFlowUpdateManyWithoutUserIdInput {
  create?:
    | CupDataProcFlowCreateWithoutUserIdInput[]
    | CupDataProcFlowCreateWithoutUserIdInput;
  delete?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  connect?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  set?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  disconnect?:
    | CupDataProcFlowWhereUniqueInput[]
    | CupDataProcFlowWhereUniqueInput;
  update?:
    | CupDataProcFlowUpdateWithWhereUniqueWithoutUserIdInput[]
    | CupDataProcFlowUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | CupDataProcFlowUpsertWithWhereUniqueWithoutUserIdInput[]
    | CupDataProcFlowUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | CupDataProcFlowScalarWhereInput[]
    | CupDataProcFlowScalarWhereInput;
  updateMany?:
    | CupDataProcFlowUpdateManyWithWhereNestedInput[]
    | CupDataProcFlowUpdateManyWithWhereNestedInput;
}

export interface FirmwareWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cup_every?: CupWhereInput;
  cup_some?: CupWhereInput;
  cup_none?: CupWhereInput;
  fwVersion?: String;
  fwVersion_not?: String;
  fwVersion_in?: String[] | String;
  fwVersion_not_in?: String[] | String;
  fwVersion_lt?: String;
  fwVersion_lte?: String;
  fwVersion_gt?: String;
  fwVersion_gte?: String;
  fwVersion_contains?: String;
  fwVersion_not_contains?: String;
  fwVersion_starts_with?: String;
  fwVersion_not_starts_with?: String;
  fwVersion_ends_with?: String;
  fwVersion_not_ends_with?: String;
  AND?: FirmwareWhereInput[] | FirmwareWhereInput;
  OR?: FirmwareWhereInput[] | FirmwareWhereInput;
  NOT?: FirmwareWhereInput[] | FirmwareWhereInput;
}

export interface CupDataProcFlowUpdateWithWhereUniqueWithoutUserIdInput {
  where: CupDataProcFlowWhereUniqueInput;
  data: CupDataProcFlowUpdateWithoutUserIdDataInput;
}

export interface HardwareSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HardwareWhereInput;
  AND?: HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput;
  OR?: HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput;
  NOT?: HardwareSubscriptionWhereInput[] | HardwareSubscriptionWhereInput;
}

export interface CupDataProcFlowUpdateWithoutUserIdDataInput {
  date?: DateTimeInput;
  hourlyFlow?: Int;
  mdateRowId?: CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput;
}

export interface CupDataRawWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  pageData?: String;
  pageData_not?: String;
  pageData_in?: String[] | String;
  pageData_not_in?: String[] | String;
  pageData_lt?: String;
  pageData_lte?: String;
  pageData_gt?: String;
  pageData_gte?: String;
  pageData_contains?: String;
  pageData_not_contains?: String;
  pageData_starts_with?: String;
  pageData_not_starts_with?: String;
  pageData_ends_with?: String;
  pageData_not_ends_with?: String;
  serialNumber?: CupWhereInput;
  AND?: CupDataRawWhereInput[] | CupDataRawWhereInput;
  OR?: CupDataRawWhereInput[] | CupDataRawWhereInput;
  NOT?: CupDataRawWhereInput[] | CupDataRawWhereInput;
}

export interface CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput {
  create?: CupDataProcMdateCreateWithoutCupDataProcFlowInput;
  update?: CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput;
  upsert?: CupDataProcMdateUpsertWithoutCupDataProcFlowInput;
  connect?: CupDataProcMdateWhereUniqueInput;
}

export interface EthnicitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EthnicityWhereInput;
  AND?: EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput;
  OR?: EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput;
  NOT?: EthnicitySubscriptionWhereInput[] | EthnicitySubscriptionWhereInput;
}

export interface CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput {
  cupDataManMdates?: CupDataManMdateUpdateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rejectId?: CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId?: UserUpdateOneRequiredWithoutCupDataProcMdatesInput;
}

export interface CupDataUserRemoveExplainSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataUserRemoveExplainWhereInput;
  AND?:
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput;
  OR?:
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput;
  NOT?:
    | CupDataUserRemoveExplainSubscriptionWhereInput[]
    | CupDataUserRemoveExplainSubscriptionWhereInput;
}

export interface CupDataManMdateUpdateManyWithoutMdateRowIdInput {
  create?:
    | CupDataManMdateCreateWithoutMdateRowIdInput[]
    | CupDataManMdateCreateWithoutMdateRowIdInput;
  delete?: CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput;
  connect?: CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput;
  set?: CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput;
  disconnect?:
    | CupDataManMdateWhereUniqueInput[]
    | CupDataManMdateWhereUniqueInput;
  update?:
    | CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowIdInput[]
    | CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowIdInput;
  upsert?:
    | CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowIdInput[]
    | CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowIdInput;
  deleteMany?:
    | CupDataManMdateScalarWhereInput[]
    | CupDataManMdateScalarWhereInput;
  updateMany?:
    | CupDataManMdateUpdateManyWithWhereNestedInput[]
    | CupDataManMdateUpdateManyWithWhereNestedInput;
}

export interface CupDataProcVolumeWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  confidenceL?: Int;
  confidenceL_not?: Int;
  confidenceL_in?: Int[] | Int;
  confidenceL_not_in?: Int[] | Int;
  confidenceL_lt?: Int;
  confidenceL_lte?: Int;
  confidenceL_gt?: Int;
  confidenceL_gte?: Int;
  confidenceR?: Int;
  confidenceR_not?: Int;
  confidenceR_in?: Int[] | Int;
  confidenceR_not_in?: Int[] | Int;
  confidenceR_lt?: Int;
  confidenceR_lte?: Int;
  confidenceR_gt?: Int;
  confidenceR_gte?: Int;
  cupDataRowId?: CupDatumWhereInput;
  inVitro?: Boolean;
  inVitro_not?: Boolean;
  volume?: Int;
  volume_not?: Int;
  volume_in?: Int[] | Int;
  volume_not_in?: Int[] | Int;
  volume_lt?: Int;
  volume_lte?: Int;
  volume_gt?: Int;
  volume_gte?: Int;
  volumeAdj?: Int;
  volumeAdj_not?: Int;
  volumeAdj_in?: Int[] | Int;
  volumeAdj_not_in?: Int[] | Int;
  volumeAdj_lt?: Int;
  volumeAdj_lte?: Int;
  volumeAdj_gt?: Int;
  volumeAdj_gte?: Int;
  volumeL?: Int;
  volumeL_not?: Int;
  volumeL_in?: Int[] | Int;
  volumeL_not_in?: Int[] | Int;
  volumeL_lt?: Int;
  volumeL_lte?: Int;
  volumeL_gt?: Int;
  volumeL_gte?: Int;
  volumeR?: Int;
  volumeR_not?: Int;
  volumeR_in?: Int[] | Int;
  volumeR_not_in?: Int[] | Int;
  volumeR_lt?: Int;
  volumeR_lte?: Int;
  volumeR_gt?: Int;
  volumeR_gte?: Int;
  AND?: CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput;
  OR?: CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput;
  NOT?: CupDataProcVolumeWhereInput[] | CupDataProcVolumeWhereInput;
}

export interface CupDataManMdateUpdateWithWhereUniqueWithoutMdateRowIdInput {
  where: CupDataManMdateWhereUniqueInput;
  data: CupDataManMdateUpdateWithoutMdateRowIdDataInput;
}

export interface CupDataColourCalcWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  blue?: Int;
  blue_not?: Int;
  blue_in?: Int[] | Int;
  blue_not_in?: Int[] | Int;
  blue_lt?: Int;
  blue_lte?: Int;
  blue_gt?: Int;
  blue_gte?: Int;
  cupDataRowId?: CupDatumWhereInput;
  green?: Int;
  green_not?: Int;
  green_in?: Int[] | Int;
  green_not_in?: Int[] | Int;
  green_lt?: Int;
  green_lte?: Int;
  green_gt?: Int;
  green_gte?: Int;
  red?: Int;
  red_not?: Int;
  red_in?: Int[] | Int;
  red_not_in?: Int[] | Int;
  red_lt?: Int;
  red_lte?: Int;
  red_gt?: Int;
  red_gte?: Int;
  AND?: CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput;
  OR?: CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput;
  NOT?: CupDataColourCalcWhereInput[] | CupDataColourCalcWhereInput;
}

export interface CupDataManMdateUpdateWithoutMdateRowIdDataInput {
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface CupDatumWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  battery?: Int;
  battery_not?: Int;
  battery_in?: Int[] | Int;
  battery_not_in?: Int[] | Int;
  battery_lt?: Int;
  battery_lte?: Int;
  battery_gt?: Int;
  battery_gte?: Int;
  calibFlag?: Boolean;
  calibFlag_not?: Boolean;
  ch1?: Int;
  ch1_not?: Int;
  ch1_in?: Int[] | Int;
  ch1_not_in?: Int[] | Int;
  ch1_lt?: Int;
  ch1_lte?: Int;
  ch1_gt?: Int;
  ch1_gte?: Int;
  ch10?: Int;
  ch10_not?: Int;
  ch10_in?: Int[] | Int;
  ch10_not_in?: Int[] | Int;
  ch10_lt?: Int;
  ch10_lte?: Int;
  ch10_gt?: Int;
  ch10_gte?: Int;
  ch11?: Int;
  ch11_not?: Int;
  ch11_in?: Int[] | Int;
  ch11_not_in?: Int[] | Int;
  ch11_lt?: Int;
  ch11_lte?: Int;
  ch11_gt?: Int;
  ch11_gte?: Int;
  ch12?: Int;
  ch12_not?: Int;
  ch12_in?: Int[] | Int;
  ch12_not_in?: Int[] | Int;
  ch12_lt?: Int;
  ch12_lte?: Int;
  ch12_gt?: Int;
  ch12_gte?: Int;
  ch13?: Int;
  ch13_not?: Int;
  ch13_in?: Int[] | Int;
  ch13_not_in?: Int[] | Int;
  ch13_lt?: Int;
  ch13_lte?: Int;
  ch13_gt?: Int;
  ch13_gte?: Int;
  ch14?: Int;
  ch14_not?: Int;
  ch14_in?: Int[] | Int;
  ch14_not_in?: Int[] | Int;
  ch14_lt?: Int;
  ch14_lte?: Int;
  ch14_gt?: Int;
  ch14_gte?: Int;
  ch2?: Int;
  ch2_not?: Int;
  ch2_in?: Int[] | Int;
  ch2_not_in?: Int[] | Int;
  ch2_lt?: Int;
  ch2_lte?: Int;
  ch2_gt?: Int;
  ch2_gte?: Int;
  ch3?: Int;
  ch3_not?: Int;
  ch3_in?: Int[] | Int;
  ch3_not_in?: Int[] | Int;
  ch3_lt?: Int;
  ch3_lte?: Int;
  ch3_gt?: Int;
  ch3_gte?: Int;
  ch4?: Int;
  ch4_not?: Int;
  ch4_in?: Int[] | Int;
  ch4_not_in?: Int[] | Int;
  ch4_lt?: Int;
  ch4_lte?: Int;
  ch4_gt?: Int;
  ch4_gte?: Int;
  ch5?: Int;
  ch5_not?: Int;
  ch5_in?: Int[] | Int;
  ch5_not_in?: Int[] | Int;
  ch5_lt?: Int;
  ch5_lte?: Int;
  ch5_gt?: Int;
  ch5_gte?: Int;
  ch6?: Int;
  ch6_not?: Int;
  ch6_in?: Int[] | Int;
  ch6_not_in?: Int[] | Int;
  ch6_lt?: Int;
  ch6_lte?: Int;
  ch6_gt?: Int;
  ch6_gte?: Int;
  ch7?: Int;
  ch7_not?: Int;
  ch7_in?: Int[] | Int;
  ch7_not_in?: Int[] | Int;
  ch7_lt?: Int;
  ch7_lte?: Int;
  ch7_gt?: Int;
  ch7_gte?: Int;
  ch8?: Int;
  ch8_not?: Int;
  ch8_in?: Int[] | Int;
  ch8_not_in?: Int[] | Int;
  ch8_lt?: Int;
  ch8_lte?: Int;
  ch8_gt?: Int;
  ch8_gte?: Int;
  ch9?: Int;
  ch9_not?: Int;
  ch9_in?: Int[] | Int;
  ch9_not_in?: Int[] | Int;
  ch9_lt?: Int;
  ch9_lte?: Int;
  ch9_gt?: Int;
  ch9_gte?: Int;
  colourB?: Int;
  colourB_not?: Int;
  colourB_in?: Int[] | Int;
  colourB_not_in?: Int[] | Int;
  colourB_lt?: Int;
  colourB_lte?: Int;
  colourB_gt?: Int;
  colourB_gte?: Int;
  colourC?: Int;
  colourC_not?: Int;
  colourC_in?: Int[] | Int;
  colourC_not_in?: Int[] | Int;
  colourC_lt?: Int;
  colourC_lte?: Int;
  colourC_gt?: Int;
  colourC_gte?: Int;
  colourG?: Int;
  colourG_not?: Int;
  colourG_in?: Int[] | Int;
  colourG_not_in?: Int[] | Int;
  colourG_lt?: Int;
  colourG_lte?: Int;
  colourG_gt?: Int;
  colourG_gte?: Int;
  colourR?: Int;
  colourR_not?: Int;
  colourR_in?: Int[] | Int;
  colourR_not_in?: Int[] | Int;
  colourR_lt?: Int;
  colourR_lte?: Int;
  colourR_gt?: Int;
  colourR_gte?: Int;
  cupDataColourCalc_every?: CupDataColourCalcWhereInput;
  cupDataColourCalc_some?: CupDataColourCalcWhereInput;
  cupDataColourCalc_none?: CupDataColourCalcWhereInput;
  cupDataProcVolume_every?: CupDataProcVolumeWhereInput;
  cupDataProcVolume_some?: CupDataProcVolumeWhereInput;
  cupDataProcVolume_none?: CupDataProcVolumeWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  day?: Int;
  day_not?: Int;
  day_in?: Int[] | Int;
  day_not_in?: Int[] | Int;
  day_lt?: Int;
  day_lte?: Int;
  day_gt?: Int;
  day_gte?: Int;
  hour?: Int;
  hour_not?: Int;
  hour_in?: Int[] | Int;
  hour_not_in?: Int[] | Int;
  hour_lt?: Int;
  hour_lte?: Int;
  hour_gt?: Int;
  hour_gte?: Int;
  line?: Int;
  line_not?: Int;
  line_in?: Int[] | Int;
  line_not_in?: Int[] | Int;
  line_lt?: Int;
  line_lte?: Int;
  line_gt?: Int;
  line_gte?: Int;
  minute?: Int;
  minute_not?: Int;
  minute_in?: Int[] | Int;
  minute_not_in?: Int[] | Int;
  minute_lt?: Int;
  minute_lte?: Int;
  minute_gt?: Int;
  minute_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  page?: Int;
  page_not?: Int;
  page_in?: Int[] | Int;
  page_not_in?: Int[] | Int;
  page_lt?: Int;
  page_lte?: Int;
  page_gt?: Int;
  page_gte?: Int;
  rawTotalVolume?: Int;
  rawTotalVolume_not?: Int;
  rawTotalVolume_in?: Int[] | Int;
  rawTotalVolume_not_in?: Int[] | Int;
  rawTotalVolume_lt?: Int;
  rawTotalVolume_lte?: Int;
  rawTotalVolume_gt?: Int;
  rawTotalVolume_gte?: Int;
  rawVolumeL?: Int;
  rawVolumeL_not?: Int;
  rawVolumeL_in?: Int[] | Int;
  rawVolumeL_not_in?: Int[] | Int;
  rawVolumeL_lt?: Int;
  rawVolumeL_lte?: Int;
  rawVolumeL_gt?: Int;
  rawVolumeL_gte?: Int;
  rawVolumeR?: Int;
  rawVolumeR_not?: Int;
  rawVolumeR_in?: Int[] | Int;
  rawVolumeR_not_in?: Int[] | Int;
  rawVolumeR_lt?: Int;
  rawVolumeR_lte?: Int;
  rawVolumeR_gt?: Int;
  rawVolumeR_gte?: Int;
  serialNumber?: CupWhereInput;
  temperature?: Int;
  temperature_not?: Int;
  temperature_in?: Int[] | Int;
  temperature_not_in?: Int[] | Int;
  temperature_lt?: Int;
  temperature_lte?: Int;
  temperature_gt?: Int;
  temperature_gte?: Int;
  x?: Int;
  x_not?: Int;
  x_in?: Int[] | Int;
  x_not_in?: Int[] | Int;
  x_lt?: Int;
  x_lte?: Int;
  x_gt?: Int;
  x_gte?: Int;
  y?: Int;
  y_not?: Int;
  y_in?: Int[] | Int;
  y_not_in?: Int[] | Int;
  y_lt?: Int;
  y_lte?: Int;
  y_gt?: Int;
  y_gte?: Int;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  z?: Int;
  z_not?: Int;
  z_in?: Int[] | Int;
  z_not_in?: Int[] | Int;
  z_lt?: Int;
  z_lte?: Int;
  z_gt?: Int;
  z_gte?: Int;
  AND?: CupDatumWhereInput[] | CupDatumWhereInput;
  OR?: CupDatumWhereInput[] | CupDatumWhereInput;
  NOT?: CupDatumWhereInput[] | CupDatumWhereInput;
}

export interface CupDataManMdateUpsertWithWhereUniqueWithoutMdateRowIdInput {
  where: CupDataManMdateWhereUniqueInput;
  update: CupDataManMdateUpdateWithoutMdateRowIdDataInput;
  create: CupDataManMdateCreateWithoutMdateRowIdInput;
}

export interface CupAppSyncWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  appSynchTime?: DateTimeInput;
  appSynchTime_not?: DateTimeInput;
  appSynchTime_in?: DateTimeInput[] | DateTimeInput;
  appSynchTime_not_in?: DateTimeInput[] | DateTimeInput;
  appSynchTime_lt?: DateTimeInput;
  appSynchTime_lte?: DateTimeInput;
  appSynchTime_gt?: DateTimeInput;
  appSynchTime_gte?: DateTimeInput;
  serialNumber?: CupWhereInput;
  AND?: CupAppSyncWhereInput[] | CupAppSyncWhereInput;
  OR?: CupAppSyncWhereInput[] | CupAppSyncWhereInput;
  NOT?: CupAppSyncWhereInput[] | CupAppSyncWhereInput;
}

export interface CupDataManMdateScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  menFinish?: DateTimeInput;
  menFinish_not?: DateTimeInput;
  menFinish_in?: DateTimeInput[] | DateTimeInput;
  menFinish_not_in?: DateTimeInput[] | DateTimeInput;
  menFinish_lt?: DateTimeInput;
  menFinish_lte?: DateTimeInput;
  menFinish_gt?: DateTimeInput;
  menFinish_gte?: DateTimeInput;
  menStart?: DateTimeInput;
  menStart_not?: DateTimeInput;
  menStart_in?: DateTimeInput[] | DateTimeInput;
  menStart_not_in?: DateTimeInput[] | DateTimeInput;
  menStart_lt?: DateTimeInput;
  menStart_lte?: DateTimeInput;
  menStart_gt?: DateTimeInput;
  menStart_gte?: DateTimeInput;
  AND?: CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput;
  OR?: CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput;
  NOT?: CupDataManMdateScalarWhereInput[] | CupDataManMdateScalarWhereInput;
}

export interface CompanyWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  companyName?: String;
  companyName_not?: String;
  companyName_in?: String[] | String;
  companyName_not_in?: String[] | String;
  companyName_lt?: String;
  companyName_lte?: String;
  companyName_gt?: String;
  companyName_gte?: String;
  companyName_contains?: String;
  companyName_not_contains?: String;
  companyName_starts_with?: String;
  companyName_not_starts_with?: String;
  companyName_ends_with?: String;
  companyName_not_ends_with?: String;
  cup_every?: CupWhereInput;
  cup_some?: CupWhereInput;
  cup_none?: CupWhereInput;
  AND?: CompanyWhereInput[] | CompanyWhereInput;
  OR?: CompanyWhereInput[] | CompanyWhereInput;
  NOT?: CompanyWhereInput[] | CompanyWhereInput;
}

export interface CupDataManMdateUpdateManyWithWhereNestedInput {
  where: CupDataManMdateScalarWhereInput;
  data: CupDataManMdateUpdateManyDataInput;
}

export interface CalibrationWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  calibVersion?: String;
  calibVersion_not?: String;
  calibVersion_in?: String[] | String;
  calibVersion_not_in?: String[] | String;
  calibVersion_lt?: String;
  calibVersion_lte?: String;
  calibVersion_gt?: String;
  calibVersion_gte?: String;
  calibVersion_contains?: String;
  calibVersion_not_contains?: String;
  calibVersion_starts_with?: String;
  calibVersion_not_starts_with?: String;
  calibVersion_ends_with?: String;
  calibVersion_not_ends_with?: String;
  cup_every?: CupWhereInput;
  cup_some?: CupWhereInput;
  cup_none?: CupWhereInput;
  AND?: CalibrationWhereInput[] | CalibrationWhereInput;
  OR?: CalibrationWhereInput[] | CalibrationWhereInput;
  NOT?: CalibrationWhereInput[] | CalibrationWhereInput;
}

export interface CupDataManMdateUpdateManyDataInput {
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface CupWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  anonSerialNumber?: Int;
  anonSerialNumber_not?: Int;
  anonSerialNumber_in?: Int[] | Int;
  anonSerialNumber_not_in?: Int[] | Int;
  anonSerialNumber_lt?: Int;
  anonSerialNumber_lte?: Int;
  anonSerialNumber_gt?: Int;
  anonSerialNumber_gte?: Int;
  calibId?: CalibrationWhereInput;
  companyId?: CompanyWhereInput;
  cupAppSync_every?: CupAppSyncWhereInput;
  cupAppSync_some?: CupAppSyncWhereInput;
  cupAppSync_none?: CupAppSyncWhereInput;
  cupData_every?: CupDatumWhereInput;
  cupData_some?: CupDatumWhereInput;
  cupData_none?: CupDatumWhereInput;
  cupDataColourCalib_every?: CupDataColourCalibWhereInput;
  cupDataColourCalib_some?: CupDataColourCalibWhereInput;
  cupDataColourCalib_none?: CupDataColourCalibWhereInput;
  cupDataRaw_every?: CupDataRawWhereInput;
  cupDataRaw_some?: CupDataRawWhereInput;
  cupDataRaw_none?: CupDataRawWhereInput;
  cupDataUserRemove_every?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_some?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_none?: CupDataUserRemoveWhereInput;
  encryptionKey?: Int;
  encryptionKey_not?: Int;
  encryptionKey_in?: Int[] | Int;
  encryptionKey_not_in?: Int[] | Int;
  encryptionKey_lt?: Int;
  encryptionKey_lte?: Int;
  encryptionKey_gt?: Int;
  encryptionKey_gte?: Int;
  fwId?: FirmwareWhereInput;
  hwId?: HardwareWhereInput;
  userCups_every?: UserCupWhereInput;
  userCups_some?: UserCupWhereInput;
  userCups_none?: UserCupWhereInput;
  AND?: CupWhereInput[] | CupWhereInput;
  OR?: CupWhereInput[] | CupWhereInput;
  NOT?: CupWhereInput[] | CupWhereInput;
}

export interface CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput {
  create?: CupDataRejectionCreateWithoutCupDataProcMdatesInput;
  update?: CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput;
  upsert?: CupDataRejectionUpsertWithoutCupDataProcMdatesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CupDataRejectionWhereUniqueInput;
}

export interface CupDataManMdateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataManMdateWhereInput;
  AND?:
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput;
  OR?:
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput;
  NOT?:
    | CupDataManMdateSubscriptionWhereInput[]
    | CupDataManMdateSubscriptionWhereInput;
}

export interface CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput {
  rejectionDescription?: String;
}

export interface CupDataUserRemoveExplainWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cupDataUserRemove_every?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_some?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_none?: CupDataUserRemoveWhereInput;
  explain?: String;
  explain_not?: String;
  explain_in?: String[] | String;
  explain_not_in?: String[] | String;
  explain_lt?: String;
  explain_lte?: String;
  explain_gt?: String;
  explain_gte?: String;
  explain_contains?: String;
  explain_not_contains?: String;
  explain_starts_with?: String;
  explain_not_starts_with?: String;
  explain_ends_with?: String;
  explain_not_ends_with?: String;
  AND?:
    | CupDataUserRemoveExplainWhereInput[]
    | CupDataUserRemoveExplainWhereInput;
  OR?:
    | CupDataUserRemoveExplainWhereInput[]
    | CupDataUserRemoveExplainWhereInput;
  NOT?:
    | CupDataUserRemoveExplainWhereInput[]
    | CupDataUserRemoveExplainWhereInput;
}

export interface CupDataRejectionUpsertWithoutCupDataProcMdatesInput {
  update: CupDataRejectionUpdateWithoutCupDataProcMdatesDataInput;
  create: CupDataRejectionCreateWithoutCupDataProcMdatesInput;
}

export interface CupDataAnswerSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataAnswerWhereInput;
  AND?:
    | CupDataAnswerSubscriptionWhereInput[]
    | CupDataAnswerSubscriptionWhereInput;
  OR?:
    | CupDataAnswerSubscriptionWhereInput[]
    | CupDataAnswerSubscriptionWhereInput;
  NOT?:
    | CupDataAnswerSubscriptionWhereInput[]
    | CupDataAnswerSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutCupDataProcMdatesInput {
  create?: UserCreateWithoutCupDataProcMdatesInput;
  update?: UserUpdateWithoutCupDataProcMdatesDataInput;
  upsert?: UserUpsertWithoutCupDataProcMdatesInput;
  connect?: UserWhereUniqueInput;
}

export interface CupAppSyncSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupAppSyncWhereInput;
  AND?: CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput;
  OR?: CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput;
  NOT?: CupAppSyncSubscriptionWhereInput[] | CupAppSyncSubscriptionWhereInput;
}

export interface UserUpdateWithoutCupDataProcMdatesDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupWhereInput;
  AND?: CupSubscriptionWhereInput[] | CupSubscriptionWhereInput;
  OR?: CupSubscriptionWhereInput[] | CupSubscriptionWhereInput;
  NOT?: CupSubscriptionWhereInput[] | CupSubscriptionWhereInput;
}

export interface CupDataQaResponseUpdateManyWithoutUserIdInput {
  create?:
    | CupDataQaResponseCreateWithoutUserIdInput[]
    | CupDataQaResponseCreateWithoutUserIdInput;
  delete?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  set?: CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput;
  disconnect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  update?:
    | CupDataQaResponseUpdateWithWhereUniqueWithoutUserIdInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | CupDataQaResponseUpsertWithWhereUniqueWithoutUserIdInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | CupDataQaResponseScalarWhereInput[]
    | CupDataQaResponseScalarWhereInput;
  updateMany?:
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput;
}

export interface CountrySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CountryWhereInput;
  AND?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  OR?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
  NOT?: CountrySubscriptionWhereInput[] | CountrySubscriptionWhereInput;
}

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutUserIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutUserIdDataInput;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CompanyWhereInput;
  AND?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  OR?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
  NOT?: CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput;
}

export interface CupDataQaResponseUpdateWithoutUserIdDataInput {
  answerId?: CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput;
  qaDate?: DateTimeInput;
  questionId?: CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput;
}

export interface CalibrationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CalibrationWhereInput;
  AND?: CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput;
  OR?: CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput;
  NOT?: CalibrationSubscriptionWhereInput[] | CalibrationSubscriptionWhereInput;
}

export interface CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: CupDataAnswerCreateWithoutCupDataQaResponseInput;
  update?: CupDataAnswerUpdateWithoutCupDataQaResponseDataInput;
  upsert?: CupDataAnswerUpsertWithoutCupDataQaResponseInput;
  connect?: CupDataAnswerWhereUniqueInput;
}

export interface AppServerSyncSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AppServerSyncWhereInput;
  AND?:
    | AppServerSyncSubscriptionWhereInput[]
    | AppServerSyncSubscriptionWhereInput;
  OR?:
    | AppServerSyncSubscriptionWhereInput[]
    | AppServerSyncSubscriptionWhereInput;
  NOT?:
    | AppServerSyncSubscriptionWhereInput[]
    | AppServerSyncSubscriptionWhereInput;
}

export interface CupDataAnswerUpdateWithoutCupDataQaResponseDataInput {
  answerText?: String;
  questionId?: CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput;
}

export type AppServerSyncWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput {
  create?: CupDataQuestionCreateWithoutCupDataAnswerInput;
  update?: CupDataQuestionUpdateWithoutCupDataAnswerDataInput;
  upsert?: CupDataQuestionUpsertWithoutCupDataAnswerInput;
  connect?: CupDataQuestionWhereUniqueInput;
}

export interface UsersDataAnalysisUpdateInput {
  email?: String;
  firstName?: String;
  lastName?: String;
  password?: String;
  userId?: String;
}

export interface CupDataQuestionUpdateWithoutCupDataAnswerDataInput {
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutQuestionIdInput;
  questionText?: String;
}

export type AuthTokenWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataQaResponseUpdateManyWithoutQuestionIdInput {
  create?:
    | CupDataQaResponseCreateWithoutQuestionIdInput[]
    | CupDataQaResponseCreateWithoutQuestionIdInput;
  delete?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  set?: CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput;
  disconnect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  update?:
    | CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionIdInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionIdInput;
  upsert?:
    | CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionIdInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionIdInput;
  deleteMany?:
    | CupDataQaResponseScalarWhereInput[]
    | CupDataQaResponseScalarWhereInput;
  updateMany?:
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput;
}

export interface AuthTokenWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  AND?: AuthTokenWhereInput[] | AuthTokenWhereInput;
  OR?: AuthTokenWhereInput[] | AuthTokenWhereInput;
  NOT?: AuthTokenWhereInput[] | AuthTokenWhereInput;
}

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutQuestionIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutQuestionIdDataInput;
}

export interface UserRecordDataByDayUpsertWithoutUserRecordDataByTimeInput {
  update: UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput;
  create: UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput;
}

export interface CupDataQaResponseUpdateWithoutQuestionIdDataInput {
  answerId?: CupDataAnswerUpdateOneRequiredWithoutCupDataQaResponseInput;
  qaDate?: DateTimeInput;
  userId?: UserUpdateOneRequiredWithoutCupDataQaResponseInput;
}

export interface UserRecordDataByDayUpdateOneWithoutUserRecordDataByTimeInput {
  create?: UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput;
  update?: UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput;
  upsert?: UserRecordDataByDayUpsertWithoutUserRecordDataByTimeInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserRecordDataByDayWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: UserCreateWithoutCupDataQaResponseInput;
  update?: UserUpdateWithoutCupDataQaResponseDataInput;
  upsert?: UserUpsertWithoutCupDataQaResponseInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataProcMdateWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cupDataManMdates_every?: CupDataManMdateWhereInput;
  cupDataManMdates_some?: CupDataManMdateWhereInput;
  cupDataManMdates_none?: CupDataManMdateWhereInput;
  cupDataProcFlow_every?: CupDataProcFlowWhereInput;
  cupDataProcFlow_some?: CupDataProcFlowWhereInput;
  cupDataProcFlow_none?: CupDataProcFlowWhereInput;
  dataRejected?: Boolean;
  dataRejected_not?: Boolean;
  dataVerified?: Boolean;
  dataVerified_not?: Boolean;
  menFinish?: DateTimeInput;
  menFinish_not?: DateTimeInput;
  menFinish_in?: DateTimeInput[] | DateTimeInput;
  menFinish_not_in?: DateTimeInput[] | DateTimeInput;
  menFinish_lt?: DateTimeInput;
  menFinish_lte?: DateTimeInput;
  menFinish_gt?: DateTimeInput;
  menFinish_gte?: DateTimeInput;
  menStart?: DateTimeInput;
  menStart_not?: DateTimeInput;
  menStart_in?: DateTimeInput[] | DateTimeInput;
  menStart_not_in?: DateTimeInput[] | DateTimeInput;
  menStart_lt?: DateTimeInput;
  menStart_lte?: DateTimeInput;
  menStart_gt?: DateTimeInput;
  menStart_gte?: DateTimeInput;
  rejectId?: CupDataRejectionWhereInput;
  rewardAmount?: Int;
  rewardAmount_not?: Int;
  rewardAmount_in?: Int[] | Int;
  rewardAmount_not_in?: Int[] | Int;
  rewardAmount_lt?: Int;
  rewardAmount_lte?: Int;
  rewardAmount_gt?: Int;
  rewardAmount_gte?: Int;
  userId?: UserWhereInput;
  AND?: CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput;
  OR?: CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput;
  NOT?: CupDataProcMdateWhereInput[] | CupDataProcMdateWhereInput;
}

export interface UserUpdateWithoutCupDataQaResponseDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput {
  crampsLevel?: Int;
  recordDate: DateTimeInput;
  recordPeriodRowId?: UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput;
}

export interface CupDataProcMdateUpdateManyWithoutUserIdInput {
  create?:
    | CupDataProcMdateCreateWithoutUserIdInput[]
    | CupDataProcMdateCreateWithoutUserIdInput;
  delete?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  connect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  set?: CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput;
  disconnect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  update?:
    | CupDataProcMdateUpdateWithWhereUniqueWithoutUserIdInput[]
    | CupDataProcMdateUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | CupDataProcMdateUpsertWithWhereUniqueWithoutUserIdInput[]
    | CupDataProcMdateUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | CupDataProcMdateScalarWhereInput[]
    | CupDataProcMdateScalarWhereInput;
  updateMany?:
    | CupDataProcMdateUpdateManyWithWhereNestedInput[]
    | CupDataProcMdateUpdateManyWithWhereNestedInput;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Int;
  companyName?: String;
}>;

export interface CupDataProcMdateUpdateWithWhereUniqueWithoutUserIdInput {
  where: CupDataProcMdateWhereUniqueInput;
  data: CupDataProcMdateUpdateWithoutUserIdDataInput;
}

export interface UserRecordDataByTimeCreateInput {
  changeTime: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  recordDayRowId?: UserRecordDataByDayCreateOneWithoutUserRecordDataByTimeInput;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface CupDataProcMdateUpdateWithoutUserIdDataInput {
  cupDataManMdates?: CupDataManMdateUpdateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rejectId?: CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
}

export interface UserRecordDataByPeriodUpdateInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userId?: UserUpdateOneWithoutUserRecordDataByPeriodInput;
  userRecordDataByDay?: UserRecordDataByDayUpdateManyWithoutRecordPeriodRowIdInput;
}

export interface CupDataProcFlowUpdateManyWithoutMdateRowIdInput {
  create?:
    | CupDataProcFlowCreateWithoutMdateRowIdInput[]
    | CupDataProcFlowCreateWithoutMdateRowIdInput;
  delete?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  connect?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  set?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
  disconnect?:
    | CupDataProcFlowWhereUniqueInput[]
    | CupDataProcFlowWhereUniqueInput;
  update?:
    | CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowIdInput[]
    | CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowIdInput;
  upsert?:
    | CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowIdInput[]
    | CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowIdInput;
  deleteMany?:
    | CupDataProcFlowScalarWhereInput[]
    | CupDataProcFlowScalarWhereInput;
  updateMany?:
    | CupDataProcFlowUpdateManyWithWhereNestedInput[]
    | CupDataProcFlowUpdateManyWithWhereNestedInput;
}

export interface CountryWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  countryName?: String;
  countryName_not?: String;
  countryName_in?: String[] | String;
  countryName_not_in?: String[] | String;
  countryName_lt?: String;
  countryName_lte?: String;
  countryName_gt?: String;
  countryName_gte?: String;
  countryName_contains?: String;
  countryName_not_contains?: String;
  countryName_starts_with?: String;
  countryName_not_starts_with?: String;
  countryName_ends_with?: String;
  countryName_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: CountryWhereInput[] | CountryWhereInput;
  OR?: CountryWhereInput[] | CountryWhereInput;
  NOT?: CountryWhereInput[] | CountryWhereInput;
}

export interface CupDataProcFlowUpdateWithWhereUniqueWithoutMdateRowIdInput {
  where: CupDataProcFlowWhereUniqueInput;
  data: CupDataProcFlowUpdateWithoutMdateRowIdDataInput;
}

export interface UserRecordDataByDayUpdateManyMutationInput {
  crampsLevel?: Int;
  recordDate?: DateTimeInput;
}

export interface CupDataProcFlowUpdateWithoutMdateRowIdDataInput {
  date?: DateTimeInput;
  hourlyFlow?: Int;
  userId?: UserUpdateOneRequiredWithoutCupDataProcFlowInput;
}

export type CupWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface UserUpdateOneRequiredWithoutCupDataProcFlowInput {
  create?: UserCreateWithoutCupDataProcFlowInput;
  update?: UserUpdateWithoutCupDataProcFlowDataInput;
  upsert?: UserUpsertWithoutCupDataProcFlowInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutUserRecordDataByPeriodDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
}

export interface UserUpdateWithoutCupDataProcFlowDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export type CupAppSyncWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataUserRemoveUpdateManyWithoutUserIdInput {
  create?:
    | CupDataUserRemoveCreateWithoutUserIdInput[]
    | CupDataUserRemoveCreateWithoutUserIdInput;
  delete?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  set?: CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput;
  disconnect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  update?:
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutUserIdInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutUserIdInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | CupDataUserRemoveScalarWhereInput[]
    | CupDataUserRemoveScalarWhereInput;
  updateMany?:
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput;
}

export interface UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput {
  create?: UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput;
  update?: UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput;
  upsert?: UserRecordDataByPeriodUpsertWithoutUserRecordDataByDayInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserRecordDataByPeriodWhereUniqueInput;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutUserIdInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutUserIdDataInput;
}

export type CupDataAnswerWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataUserRemoveUpdateWithoutUserIdDataInput {
  changeTime?: DateTimeInput;
  explainId?: CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput;
  serialNumber?: CupUpdateOneRequiredWithoutCupDataUserRemoveInput;
}

export interface UserCreateOneWithoutUserRecordDataByPeriodInput {
  create?: UserCreateWithoutUserRecordDataByPeriodInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput;
  update?: CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput;
  upsert?: CupDataUserRemoveExplainUpsertWithoutCupDataUserRemoveInput;
  connect?: CupDataUserRemoveExplainWhereUniqueInput;
}

export type CupDataColourCalcWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput {
  explain?: String;
}

export interface UserRecordDataByDayCreateInput {
  crampsLevel?: Int;
  recordDate: DateTimeInput;
  recordPeriodRowId?: UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput;
  userRecordDataByTime?: UserRecordDataByTimeCreateManyWithoutRecordDayRowIdInput;
}

export interface CupDataUserRemoveExplainUpsertWithoutCupDataUserRemoveInput {
  update: CupDataUserRemoveExplainUpdateWithoutCupDataUserRemoveDataInput;
  create: CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput;
}

export type CupDataColourCalibWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: CupCreateWithoutCupDataUserRemoveInput;
  update?: CupUpdateWithoutCupDataUserRemoveDataInput;
  upsert?: CupUpsertWithoutCupDataUserRemoveInput;
  connect?: CupWhereUniqueInput;
}

export interface UserInterviewQuestionCreateInput {
  answerTypeId: AnswerTypeCreateOneWithoutUserInterviewQuestionsInput;
  question: String;
  userInterviewData?: UserInterviewDatumCreateManyWithoutQuestionIdInput;
}

export interface CupUpdateWithoutCupDataUserRemoveDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export type CupDataManMdateWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CalibrationUpdateOneWithoutCupInput {
  create?: CalibrationCreateWithoutCupInput;
  update?: CalibrationUpdateWithoutCupDataInput;
  upsert?: CalibrationUpsertWithoutCupInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CalibrationWhereUniqueInput;
}

export interface UserInterviewDatumCreateInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeInput;
  questionId: UserInterviewQuestionCreateOneWithoutUserInterviewDataInput;
  userId: UserCreateOneWithoutUserInterviewDataInput;
}

export interface CalibrationUpdateWithoutCupDataInput {
  calibVersion?: String;
}

export type CupDataProcFlowWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CalibrationUpsertWithoutCupInput {
  update: CalibrationUpdateWithoutCupDataInput;
  create: CalibrationCreateWithoutCupInput;
}

export interface UserCoinHistoryUpdateManyMutationInput {
  category?: String;
  coin?: Int;
  contents?: String;
  date?: DateTimeInput;
  txhash?: String;
}

export interface CompanyUpdateOneWithoutCupInput {
  create?: CompanyCreateWithoutCupInput;
  update?: CompanyUpdateWithoutCupDataInput;
  upsert?: CompanyUpsertWithoutCupInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CompanyWhereUniqueInput;
}

export type CupDataProcMdateWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CompanyUpdateWithoutCupDataInput {
  companyName?: String;
}

export interface UserUpdateOneWithoutUserCoinHistoryInput {
  create?: UserCreateWithoutUserCoinHistoryInput;
  update?: UserUpdateWithoutUserCoinHistoryDataInput;
  upsert?: UserUpsertWithoutUserCoinHistoryInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface CompanyUpsertWithoutCupInput {
  update: CompanyUpdateWithoutCupDataInput;
  create: CompanyCreateWithoutCupInput;
}

export type CupDataProcVolumeWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupAppSyncUpdateManyWithoutSerialNumberInput {
  create?:
    | CupAppSyncCreateWithoutSerialNumberInput[]
    | CupAppSyncCreateWithoutSerialNumberInput;
  delete?: CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput;
  connect?: CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput;
  set?: CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput;
  disconnect?: CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput;
  update?:
    | CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?: CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput;
  updateMany?:
    | CupAppSyncUpdateManyWithWhereNestedInput[]
    | CupAppSyncUpdateManyWithWhereNestedInput;
}

export interface UserCreateOneWithoutUserCoinHistoryInput {
  create?: UserCreateWithoutUserCoinHistoryInput;
  connect?: UserWhereUniqueInput;
}

export interface CupAppSyncUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupAppSyncWhereUniqueInput;
  data: CupAppSyncUpdateWithoutSerialNumberDataInput;
}

export type CupDataQaResponseWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupAppSyncUpdateWithoutSerialNumberDataInput {
  appSynchTime?: DateTimeInput;
}

export interface UserUpdateInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupAppSyncUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupAppSyncWhereUniqueInput;
  update: CupAppSyncUpdateWithoutSerialNumberDataInput;
  create: CupAppSyncCreateWithoutSerialNumberInput;
}

export type CupDataQuestionWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupAppSyncScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  appSynchTime?: DateTimeInput;
  appSynchTime_not?: DateTimeInput;
  appSynchTime_in?: DateTimeInput[] | DateTimeInput;
  appSynchTime_not_in?: DateTimeInput[] | DateTimeInput;
  appSynchTime_lt?: DateTimeInput;
  appSynchTime_lte?: DateTimeInput;
  appSynchTime_gt?: DateTimeInput;
  appSynchTime_gte?: DateTimeInput;
  AND?: CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput;
  OR?: CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput;
  NOT?: CupAppSyncScalarWhereInput[] | CupAppSyncScalarWhereInput;
}

export interface PlatformCompUpdateManyMutationInput {
  phoneId?: Int;
  platformId?: Int;
  problemHistory?: Boolean;
  softwareId?: Int;
  successHistory?: Boolean;
}

export interface CupAppSyncUpdateManyWithWhereNestedInput {
  where: CupAppSyncScalarWhereInput;
  data: CupAppSyncUpdateManyDataInput;
}

export interface PlatformCompCreateInput {
  phoneId: Int;
  platformId: Int;
  problemHistory?: Boolean;
  softwareId: Int;
  successHistory?: Boolean;
}

export interface CupAppSyncUpdateManyDataInput {
  appSynchTime?: DateTimeInput;
}

export interface HardwareUpdateManyMutationInput {
  hwVersion?: String;
}

export interface CupDatumUpdateManyWithoutSerialNumberInput {
  create?:
    | CupDatumCreateWithoutSerialNumberInput[]
    | CupDatumCreateWithoutSerialNumberInput;
  delete?: CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput;
  connect?: CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput;
  set?: CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput;
  disconnect?: CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput;
  update?:
    | CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?: CupDatumScalarWhereInput[] | CupDatumScalarWhereInput;
  updateMany?:
    | CupDatumUpdateManyWithWhereNestedInput[]
    | CupDatumUpdateManyWithWhereNestedInput;
}

export interface CupUpdateWithoutHwIdDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface CupDatumUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDatumWhereUniqueInput;
  data: CupDatumUpdateWithoutSerialNumberDataInput;
}

export interface UserWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  anonUserId?: Int;
  anonUserId_not?: Int;
  anonUserId_in?: Int[] | Int;
  anonUserId_not_in?: Int[] | Int;
  anonUserId_lt?: Int;
  anonUserId_lte?: Int;
  anonUserId_gt?: Int;
  anonUserId_gte?: Int;
  appServerSync_every?: AppServerSyncWhereInput;
  appServerSync_some?: AppServerSyncWhereInput;
  appServerSync_none?: AppServerSyncWhereInput;
  countryId?: CountryWhereInput;
  cupDataProcFlow_every?: CupDataProcFlowWhereInput;
  cupDataProcFlow_some?: CupDataProcFlowWhereInput;
  cupDataProcFlow_none?: CupDataProcFlowWhereInput;
  cupDataProcMdates_every?: CupDataProcMdateWhereInput;
  cupDataProcMdates_some?: CupDataProcMdateWhereInput;
  cupDataProcMdates_none?: CupDataProcMdateWhereInput;
  cupDataQaResponse_every?: CupDataQaResponseWhereInput;
  cupDataQaResponse_some?: CupDataQaResponseWhereInput;
  cupDataQaResponse_none?: CupDataQaResponseWhereInput;
  cupDataUserRemove_every?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_some?: CupDataUserRemoveWhereInput;
  cupDataUserRemove_none?: CupDataUserRemoveWhereInput;
  deleted?: Boolean;
  deleted_not?: Boolean;
  dob?: DateTimeInput;
  dob_not?: DateTimeInput;
  dob_in?: DateTimeInput[] | DateTimeInput;
  dob_not_in?: DateTimeInput[] | DateTimeInput;
  dob_lt?: DateTimeInput;
  dob_lte?: DateTimeInput;
  dob_gt?: DateTimeInput;
  dob_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  encryptSaltString?: String;
  encryptSaltString_not?: String;
  encryptSaltString_in?: String[] | String;
  encryptSaltString_not_in?: String[] | String;
  encryptSaltString_lt?: String;
  encryptSaltString_lte?: String;
  encryptSaltString_gt?: String;
  encryptSaltString_gte?: String;
  encryptSaltString_contains?: String;
  encryptSaltString_not_contains?: String;
  encryptSaltString_starts_with?: String;
  encryptSaltString_not_starts_with?: String;
  encryptSaltString_ends_with?: String;
  encryptSaltString_not_ends_with?: String;
  ethnicityId?: EthnicityWhereInput;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  givenBirth?: Boolean;
  givenBirth_not?: Boolean;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  userCoinHistory_every?: UserCoinHistoryWhereInput;
  userCoinHistory_some?: UserCoinHistoryWhereInput;
  userCoinHistory_none?: UserCoinHistoryWhereInput;
  userCups_every?: UserCupWhereInput;
  userCups_some?: UserCupWhereInput;
  userCups_none?: UserCupWhereInput;
  userInterviewData_every?: UserInterviewDatumWhereInput;
  userInterviewData_some?: UserInterviewDatumWhereInput;
  userInterviewData_none?: UserInterviewDatumWhereInput;
  userRecordDataByPeriod_every?: UserRecordDataByPeriodWhereInput;
  userRecordDataByPeriod_some?: UserRecordDataByPeriodWhereInput;
  userRecordDataByPeriod_none?: UserRecordDataByPeriodWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CupDatumUpdateWithoutSerialNumberDataInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  cupDataColourCalc?: CupDataColourCalcUpdateManyWithoutCupDataRowIdInput;
  cupDataProcVolume?: CupDataProcVolumeUpdateManyWithoutCupDataRowIdInput;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export interface CupUpdateManyWithoutHwIdInput {
  create?: CupCreateWithoutHwIdInput[] | CupCreateWithoutHwIdInput;
  delete?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  set?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  disconnect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  update?:
    | CupUpdateWithWhereUniqueWithoutHwIdInput[]
    | CupUpdateWithWhereUniqueWithoutHwIdInput;
  upsert?:
    | CupUpsertWithWhereUniqueWithoutHwIdInput[]
    | CupUpsertWithWhereUniqueWithoutHwIdInput;
  deleteMany?: CupScalarWhereInput[] | CupScalarWhereInput;
  updateMany?:
    | CupUpdateManyWithWhereNestedInput[]
    | CupUpdateManyWithWhereNestedInput;
}

export interface CupDataColourCalcUpdateManyWithoutCupDataRowIdInput {
  create?:
    | CupDataColourCalcCreateWithoutCupDataRowIdInput[]
    | CupDataColourCalcCreateWithoutCupDataRowIdInput;
  delete?:
    | CupDataColourCalcWhereUniqueInput[]
    | CupDataColourCalcWhereUniqueInput;
  connect?:
    | CupDataColourCalcWhereUniqueInput[]
    | CupDataColourCalcWhereUniqueInput;
  set?: CupDataColourCalcWhereUniqueInput[] | CupDataColourCalcWhereUniqueInput;
  disconnect?:
    | CupDataColourCalcWhereUniqueInput[]
    | CupDataColourCalcWhereUniqueInput;
  update?:
    | CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowIdInput[]
    | CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowIdInput;
  upsert?:
    | CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowIdInput[]
    | CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowIdInput;
  deleteMany?:
    | CupDataColourCalcScalarWhereInput[]
    | CupDataColourCalcScalarWhereInput;
  updateMany?:
    | CupDataColourCalcUpdateManyWithWhereNestedInput[]
    | CupDataColourCalcUpdateManyWithWhereNestedInput;
}

export type CupDataUserRemoveWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataColourCalcUpdateWithWhereUniqueWithoutCupDataRowIdInput {
  where: CupDataColourCalcWhereUniqueInput;
  data: CupDataColourCalcUpdateWithoutCupDataRowIdDataInput;
}

export interface CupCreateManyWithoutHwIdInput {
  create?: CupCreateWithoutHwIdInput[] | CupCreateWithoutHwIdInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
}

export interface CupDataColourCalcUpdateWithoutCupDataRowIdDataInput {
  blue?: Int;
  green?: Int;
  red?: Int;
}

export type CupDataUserRemoveExplainWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataColourCalcUpsertWithWhereUniqueWithoutCupDataRowIdInput {
  where: CupDataColourCalcWhereUniqueInput;
  update: CupDataColourCalcUpdateWithoutCupDataRowIdDataInput;
  create: CupDataColourCalcCreateWithoutCupDataRowIdInput;
}

export interface CupUpsertWithWhereUniqueWithoutFwIdInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutFwIdDataInput;
  create: CupCreateWithoutFwIdInput;
}

export interface CupDataColourCalcScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  blue?: Int;
  blue_not?: Int;
  blue_in?: Int[] | Int;
  blue_not_in?: Int[] | Int;
  blue_lt?: Int;
  blue_lte?: Int;
  blue_gt?: Int;
  blue_gte?: Int;
  green?: Int;
  green_not?: Int;
  green_in?: Int[] | Int;
  green_not_in?: Int[] | Int;
  green_lt?: Int;
  green_lte?: Int;
  green_gt?: Int;
  green_gte?: Int;
  red?: Int;
  red_not?: Int;
  red_in?: Int[] | Int;
  red_not_in?: Int[] | Int;
  red_lt?: Int;
  red_lte?: Int;
  red_gt?: Int;
  red_gte?: Int;
  AND?: CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput;
  OR?: CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput;
  NOT?: CupDataColourCalcScalarWhereInput[] | CupDataColourCalcScalarWhereInput;
}

export interface CupUpdateWithWhereUniqueWithoutFwIdInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutFwIdDataInput;
}

export interface CupDataColourCalcUpdateManyWithWhereNestedInput {
  where: CupDataColourCalcScalarWhereInput;
  data: CupDataColourCalcUpdateManyDataInput;
}

export interface CupUpdateManyWithoutFwIdInput {
  create?: CupCreateWithoutFwIdInput[] | CupCreateWithoutFwIdInput;
  delete?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  set?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  disconnect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  update?:
    | CupUpdateWithWhereUniqueWithoutFwIdInput[]
    | CupUpdateWithWhereUniqueWithoutFwIdInput;
  upsert?:
    | CupUpsertWithWhereUniqueWithoutFwIdInput[]
    | CupUpsertWithWhereUniqueWithoutFwIdInput;
  deleteMany?: CupScalarWhereInput[] | CupScalarWhereInput;
  updateMany?:
    | CupUpdateManyWithWhereNestedInput[]
    | CupUpdateManyWithWhereNestedInput;
}

export interface CupDataColourCalcUpdateManyDataInput {
  blue?: Int;
  green?: Int;
  red?: Int;
}

export interface CupCreateWithoutFwIdInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface CupDataProcVolumeUpdateManyWithoutCupDataRowIdInput {
  create?:
    | CupDataProcVolumeCreateWithoutCupDataRowIdInput[]
    | CupDataProcVolumeCreateWithoutCupDataRowIdInput;
  delete?:
    | CupDataProcVolumeWhereUniqueInput[]
    | CupDataProcVolumeWhereUniqueInput;
  connect?:
    | CupDataProcVolumeWhereUniqueInput[]
    | CupDataProcVolumeWhereUniqueInput;
  set?: CupDataProcVolumeWhereUniqueInput[] | CupDataProcVolumeWhereUniqueInput;
  disconnect?:
    | CupDataProcVolumeWhereUniqueInput[]
    | CupDataProcVolumeWhereUniqueInput;
  update?:
    | CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowIdInput[]
    | CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowIdInput;
  upsert?:
    | CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowIdInput[]
    | CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowIdInput;
  deleteMany?:
    | CupDataProcVolumeScalarWhereInput[]
    | CupDataProcVolumeScalarWhereInput;
  updateMany?:
    | CupDataProcVolumeUpdateManyWithWhereNestedInput[]
    | CupDataProcVolumeUpdateManyWithWhereNestedInput;
}

export interface CupCreateManyWithoutFwIdInput {
  create?: CupCreateWithoutFwIdInput[] | CupCreateWithoutFwIdInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
}

export interface CupDataProcVolumeUpdateWithWhereUniqueWithoutCupDataRowIdInput {
  where: CupDataProcVolumeWhereUniqueInput;
  data: CupDataProcVolumeUpdateWithoutCupDataRowIdDataInput;
}

export interface EthnicityUpdateManyMutationInput {
  ethnicity?: String;
}

export interface CupDataProcVolumeUpdateWithoutCupDataRowIdDataInput {
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export type FirmwareWhereUniqueInput = AtLeastOne<{
  id: Int;
  fwVersion?: String;
}>;

export interface CupDataProcVolumeUpsertWithWhereUniqueWithoutCupDataRowIdInput {
  where: CupDataProcVolumeWhereUniqueInput;
  update: CupDataProcVolumeUpdateWithoutCupDataRowIdDataInput;
  create: CupDataProcVolumeCreateWithoutCupDataRowIdInput;
}

export interface UserUpdateWithoutEthnicityIdDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupDataProcVolumeScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  confidenceL?: Int;
  confidenceL_not?: Int;
  confidenceL_in?: Int[] | Int;
  confidenceL_not_in?: Int[] | Int;
  confidenceL_lt?: Int;
  confidenceL_lte?: Int;
  confidenceL_gt?: Int;
  confidenceL_gte?: Int;
  confidenceR?: Int;
  confidenceR_not?: Int;
  confidenceR_in?: Int[] | Int;
  confidenceR_not_in?: Int[] | Int;
  confidenceR_lt?: Int;
  confidenceR_lte?: Int;
  confidenceR_gt?: Int;
  confidenceR_gte?: Int;
  inVitro?: Boolean;
  inVitro_not?: Boolean;
  volume?: Int;
  volume_not?: Int;
  volume_in?: Int[] | Int;
  volume_not_in?: Int[] | Int;
  volume_lt?: Int;
  volume_lte?: Int;
  volume_gt?: Int;
  volume_gte?: Int;
  volumeAdj?: Int;
  volumeAdj_not?: Int;
  volumeAdj_in?: Int[] | Int;
  volumeAdj_not_in?: Int[] | Int;
  volumeAdj_lt?: Int;
  volumeAdj_lte?: Int;
  volumeAdj_gt?: Int;
  volumeAdj_gte?: Int;
  volumeL?: Int;
  volumeL_not?: Int;
  volumeL_in?: Int[] | Int;
  volumeL_not_in?: Int[] | Int;
  volumeL_lt?: Int;
  volumeL_lte?: Int;
  volumeL_gt?: Int;
  volumeL_gte?: Int;
  volumeR?: Int;
  volumeR_not?: Int;
  volumeR_in?: Int[] | Int;
  volumeR_not_in?: Int[] | Int;
  volumeR_lt?: Int;
  volumeR_lte?: Int;
  volumeR_gt?: Int;
  volumeR_gte?: Int;
  AND?: CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput;
  OR?: CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput;
  NOT?: CupDataProcVolumeScalarWhereInput[] | CupDataProcVolumeScalarWhereInput;
}

export interface UserUpdateManyWithoutEthnicityIdInput {
  create?:
    | UserCreateWithoutEthnicityIdInput[]
    | UserCreateWithoutEthnicityIdInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutEthnicityIdInput[]
    | UserUpdateWithWhereUniqueWithoutEthnicityIdInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutEthnicityIdInput[]
    | UserUpsertWithWhereUniqueWithoutEthnicityIdInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface CupDataProcVolumeUpdateManyWithWhereNestedInput {
  where: CupDataProcVolumeScalarWhereInput;
  data: CupDataProcVolumeUpdateManyDataInput;
}

export interface AnswerTypeWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerType?: String;
  answerType_not?: String;
  answerType_in?: String[] | String;
  answerType_not_in?: String[] | String;
  answerType_lt?: String;
  answerType_lte?: String;
  answerType_gt?: String;
  answerType_gte?: String;
  answerType_contains?: String;
  answerType_not_contains?: String;
  answerType_starts_with?: String;
  answerType_not_starts_with?: String;
  answerType_ends_with?: String;
  answerType_not_ends_with?: String;
  userInterviewQuestions_every?: UserInterviewQuestionWhereInput;
  userInterviewQuestions_some?: UserInterviewQuestionWhereInput;
  userInterviewQuestions_none?: UserInterviewQuestionWhereInput;
  AND?: AnswerTypeWhereInput[] | AnswerTypeWhereInput;
  OR?: AnswerTypeWhereInput[] | AnswerTypeWhereInput;
  NOT?: AnswerTypeWhereInput[] | AnswerTypeWhereInput;
}

export interface CupDataProcVolumeUpdateManyDataInput {
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface UserCreateWithoutEthnicityIdInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface CupDatumUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDatumWhereUniqueInput;
  update: CupDatumUpdateWithoutSerialNumberDataInput;
  create: CupDatumCreateWithoutSerialNumberInput;
}

export type PlatformCompWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDatumScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  battery?: Int;
  battery_not?: Int;
  battery_in?: Int[] | Int;
  battery_not_in?: Int[] | Int;
  battery_lt?: Int;
  battery_lte?: Int;
  battery_gt?: Int;
  battery_gte?: Int;
  calibFlag?: Boolean;
  calibFlag_not?: Boolean;
  ch1?: Int;
  ch1_not?: Int;
  ch1_in?: Int[] | Int;
  ch1_not_in?: Int[] | Int;
  ch1_lt?: Int;
  ch1_lte?: Int;
  ch1_gt?: Int;
  ch1_gte?: Int;
  ch10?: Int;
  ch10_not?: Int;
  ch10_in?: Int[] | Int;
  ch10_not_in?: Int[] | Int;
  ch10_lt?: Int;
  ch10_lte?: Int;
  ch10_gt?: Int;
  ch10_gte?: Int;
  ch11?: Int;
  ch11_not?: Int;
  ch11_in?: Int[] | Int;
  ch11_not_in?: Int[] | Int;
  ch11_lt?: Int;
  ch11_lte?: Int;
  ch11_gt?: Int;
  ch11_gte?: Int;
  ch12?: Int;
  ch12_not?: Int;
  ch12_in?: Int[] | Int;
  ch12_not_in?: Int[] | Int;
  ch12_lt?: Int;
  ch12_lte?: Int;
  ch12_gt?: Int;
  ch12_gte?: Int;
  ch13?: Int;
  ch13_not?: Int;
  ch13_in?: Int[] | Int;
  ch13_not_in?: Int[] | Int;
  ch13_lt?: Int;
  ch13_lte?: Int;
  ch13_gt?: Int;
  ch13_gte?: Int;
  ch14?: Int;
  ch14_not?: Int;
  ch14_in?: Int[] | Int;
  ch14_not_in?: Int[] | Int;
  ch14_lt?: Int;
  ch14_lte?: Int;
  ch14_gt?: Int;
  ch14_gte?: Int;
  ch2?: Int;
  ch2_not?: Int;
  ch2_in?: Int[] | Int;
  ch2_not_in?: Int[] | Int;
  ch2_lt?: Int;
  ch2_lte?: Int;
  ch2_gt?: Int;
  ch2_gte?: Int;
  ch3?: Int;
  ch3_not?: Int;
  ch3_in?: Int[] | Int;
  ch3_not_in?: Int[] | Int;
  ch3_lt?: Int;
  ch3_lte?: Int;
  ch3_gt?: Int;
  ch3_gte?: Int;
  ch4?: Int;
  ch4_not?: Int;
  ch4_in?: Int[] | Int;
  ch4_not_in?: Int[] | Int;
  ch4_lt?: Int;
  ch4_lte?: Int;
  ch4_gt?: Int;
  ch4_gte?: Int;
  ch5?: Int;
  ch5_not?: Int;
  ch5_in?: Int[] | Int;
  ch5_not_in?: Int[] | Int;
  ch5_lt?: Int;
  ch5_lte?: Int;
  ch5_gt?: Int;
  ch5_gte?: Int;
  ch6?: Int;
  ch6_not?: Int;
  ch6_in?: Int[] | Int;
  ch6_not_in?: Int[] | Int;
  ch6_lt?: Int;
  ch6_lte?: Int;
  ch6_gt?: Int;
  ch6_gte?: Int;
  ch7?: Int;
  ch7_not?: Int;
  ch7_in?: Int[] | Int;
  ch7_not_in?: Int[] | Int;
  ch7_lt?: Int;
  ch7_lte?: Int;
  ch7_gt?: Int;
  ch7_gte?: Int;
  ch8?: Int;
  ch8_not?: Int;
  ch8_in?: Int[] | Int;
  ch8_not_in?: Int[] | Int;
  ch8_lt?: Int;
  ch8_lte?: Int;
  ch8_gt?: Int;
  ch8_gte?: Int;
  ch9?: Int;
  ch9_not?: Int;
  ch9_in?: Int[] | Int;
  ch9_not_in?: Int[] | Int;
  ch9_lt?: Int;
  ch9_lte?: Int;
  ch9_gt?: Int;
  ch9_gte?: Int;
  colourB?: Int;
  colourB_not?: Int;
  colourB_in?: Int[] | Int;
  colourB_not_in?: Int[] | Int;
  colourB_lt?: Int;
  colourB_lte?: Int;
  colourB_gt?: Int;
  colourB_gte?: Int;
  colourC?: Int;
  colourC_not?: Int;
  colourC_in?: Int[] | Int;
  colourC_not_in?: Int[] | Int;
  colourC_lt?: Int;
  colourC_lte?: Int;
  colourC_gt?: Int;
  colourC_gte?: Int;
  colourG?: Int;
  colourG_not?: Int;
  colourG_in?: Int[] | Int;
  colourG_not_in?: Int[] | Int;
  colourG_lt?: Int;
  colourG_lte?: Int;
  colourG_gt?: Int;
  colourG_gte?: Int;
  colourR?: Int;
  colourR_not?: Int;
  colourR_in?: Int[] | Int;
  colourR_not_in?: Int[] | Int;
  colourR_lt?: Int;
  colourR_lte?: Int;
  colourR_gt?: Int;
  colourR_gte?: Int;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  day?: Int;
  day_not?: Int;
  day_in?: Int[] | Int;
  day_not_in?: Int[] | Int;
  day_lt?: Int;
  day_lte?: Int;
  day_gt?: Int;
  day_gte?: Int;
  hour?: Int;
  hour_not?: Int;
  hour_in?: Int[] | Int;
  hour_not_in?: Int[] | Int;
  hour_lt?: Int;
  hour_lte?: Int;
  hour_gt?: Int;
  hour_gte?: Int;
  line?: Int;
  line_not?: Int;
  line_in?: Int[] | Int;
  line_not_in?: Int[] | Int;
  line_lt?: Int;
  line_lte?: Int;
  line_gt?: Int;
  line_gte?: Int;
  minute?: Int;
  minute_not?: Int;
  minute_in?: Int[] | Int;
  minute_not_in?: Int[] | Int;
  minute_lt?: Int;
  minute_lte?: Int;
  minute_gt?: Int;
  minute_gte?: Int;
  month?: Int;
  month_not?: Int;
  month_in?: Int[] | Int;
  month_not_in?: Int[] | Int;
  month_lt?: Int;
  month_lte?: Int;
  month_gt?: Int;
  month_gte?: Int;
  page?: Int;
  page_not?: Int;
  page_in?: Int[] | Int;
  page_not_in?: Int[] | Int;
  page_lt?: Int;
  page_lte?: Int;
  page_gt?: Int;
  page_gte?: Int;
  rawTotalVolume?: Int;
  rawTotalVolume_not?: Int;
  rawTotalVolume_in?: Int[] | Int;
  rawTotalVolume_not_in?: Int[] | Int;
  rawTotalVolume_lt?: Int;
  rawTotalVolume_lte?: Int;
  rawTotalVolume_gt?: Int;
  rawTotalVolume_gte?: Int;
  rawVolumeL?: Int;
  rawVolumeL_not?: Int;
  rawVolumeL_in?: Int[] | Int;
  rawVolumeL_not_in?: Int[] | Int;
  rawVolumeL_lt?: Int;
  rawVolumeL_lte?: Int;
  rawVolumeL_gt?: Int;
  rawVolumeL_gte?: Int;
  rawVolumeR?: Int;
  rawVolumeR_not?: Int;
  rawVolumeR_in?: Int[] | Int;
  rawVolumeR_not_in?: Int[] | Int;
  rawVolumeR_lt?: Int;
  rawVolumeR_lte?: Int;
  rawVolumeR_gt?: Int;
  rawVolumeR_gte?: Int;
  temperature?: Int;
  temperature_not?: Int;
  temperature_in?: Int[] | Int;
  temperature_not_in?: Int[] | Int;
  temperature_lt?: Int;
  temperature_lte?: Int;
  temperature_gt?: Int;
  temperature_gte?: Int;
  x?: Int;
  x_not?: Int;
  x_in?: Int[] | Int;
  x_not_in?: Int[] | Int;
  x_lt?: Int;
  x_lte?: Int;
  x_gt?: Int;
  x_gte?: Int;
  y?: Int;
  y_not?: Int;
  y_in?: Int[] | Int;
  y_not_in?: Int[] | Int;
  y_lt?: Int;
  y_lte?: Int;
  y_gt?: Int;
  y_gte?: Int;
  year?: Int;
  year_not?: Int;
  year_in?: Int[] | Int;
  year_not_in?: Int[] | Int;
  year_lt?: Int;
  year_lte?: Int;
  year_gt?: Int;
  year_gte?: Int;
  z?: Int;
  z_not?: Int;
  z_in?: Int[] | Int;
  z_not_in?: Int[] | Int;
  z_lt?: Int;
  z_lte?: Int;
  z_gt?: Int;
  z_gte?: Int;
  AND?: CupDatumScalarWhereInput[] | CupDatumScalarWhereInput;
  OR?: CupDatumScalarWhereInput[] | CupDatumScalarWhereInput;
  NOT?: CupDatumScalarWhereInput[] | CupDatumScalarWhereInput;
}

export interface PlatformCompWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  phoneId?: Int;
  phoneId_not?: Int;
  phoneId_in?: Int[] | Int;
  phoneId_not_in?: Int[] | Int;
  phoneId_lt?: Int;
  phoneId_lte?: Int;
  phoneId_gt?: Int;
  phoneId_gte?: Int;
  platformId?: Int;
  platformId_not?: Int;
  platformId_in?: Int[] | Int;
  platformId_not_in?: Int[] | Int;
  platformId_lt?: Int;
  platformId_lte?: Int;
  platformId_gt?: Int;
  platformId_gte?: Int;
  problemHistory?: Boolean;
  problemHistory_not?: Boolean;
  softwareId?: Int;
  softwareId_not?: Int;
  softwareId_in?: Int[] | Int;
  softwareId_not_in?: Int[] | Int;
  softwareId_lt?: Int;
  softwareId_lte?: Int;
  softwareId_gt?: Int;
  softwareId_gte?: Int;
  successHistory?: Boolean;
  successHistory_not?: Boolean;
  AND?: PlatformCompWhereInput[] | PlatformCompWhereInput;
  OR?: PlatformCompWhereInput[] | PlatformCompWhereInput;
  NOT?: PlatformCompWhereInput[] | PlatformCompWhereInput;
}

export interface CupDatumUpdateManyWithWhereNestedInput {
  where: CupDatumScalarWhereInput;
  data: CupDatumUpdateManyDataInput;
}

export interface CupDatumUpdateManyMutationInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export interface CupDatumUpdateManyDataInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export interface CupDatumCreateInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: CupDataColourCalcCreateManyWithoutCupDataRowIdInput;
  cupDataProcVolume?: CupDataProcVolumeCreateManyWithoutCupDataRowIdInput;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupCreateOneWithoutCupDataInput;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDataColourCalibUpdateManyWithoutSerialNumberInput {
  create?:
    | CupDataColourCalibCreateWithoutSerialNumberInput[]
    | CupDataColourCalibCreateWithoutSerialNumberInput;
  delete?:
    | CupDataColourCalibWhereUniqueInput[]
    | CupDataColourCalibWhereUniqueInput;
  connect?:
    | CupDataColourCalibWhereUniqueInput[]
    | CupDataColourCalibWhereUniqueInput;
  set?:
    | CupDataColourCalibWhereUniqueInput[]
    | CupDataColourCalibWhereUniqueInput;
  disconnect?:
    | CupDataColourCalibWhereUniqueInput[]
    | CupDataColourCalibWhereUniqueInput;
  update?:
    | CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?:
    | CupDataColourCalibScalarWhereInput[]
    | CupDataColourCalibScalarWhereInput;
  updateMany?:
    | CupDataColourCalibUpdateManyWithWhereNestedInput[]
    | CupDataColourCalibUpdateManyWithWhereNestedInput;
}

export interface CupDataUserRemoveExplainUpdateManyMutationInput {
  explain?: String;
}

export interface CupDataColourCalibUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataColourCalibWhereUniqueInput;
  data: CupDataColourCalibUpdateWithoutSerialNumberDataInput;
}

export interface CupDataUserRemoveUpdateWithoutExplainIdDataInput {
  changeTime?: DateTimeInput;
  serialNumber?: CupUpdateOneRequiredWithoutCupDataUserRemoveInput;
  userId?: UserUpdateOneRequiredWithoutCupDataUserRemoveInput;
}

export interface CupDataQuestionUpdateInput {
  cupDataAnswer?: CupDataAnswerUpdateManyWithoutQuestionIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutQuestionIdInput;
  questionText?: String;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainIdInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutExplainIdDataInput;
}

export interface CupDataColourCalibUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataColourCalibWhereUniqueInput;
  update: CupDataColourCalibUpdateWithoutSerialNumberDataInput;
  create: CupDataColourCalibCreateWithoutSerialNumberInput;
}

export interface CupDataUserRemoveExplainUpdateInput {
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutExplainIdInput;
  explain?: String;
}

export interface CupDataColourCalibScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  blue?: Int;
  blue_not?: Int;
  blue_in?: Int[] | Int;
  blue_not_in?: Int[] | Int;
  blue_lt?: Int;
  blue_lte?: Int;
  blue_gt?: Int;
  blue_gte?: Int;
  c?: Int;
  c_not?: Int;
  c_in?: Int[] | Int;
  c_not_in?: Int[] | Int;
  c_lt?: Int;
  c_lte?: Int;
  c_gt?: Int;
  c_gte?: Int;
  green?: Int;
  green_not?: Int;
  green_in?: Int[] | Int;
  green_not_in?: Int[] | Int;
  green_lt?: Int;
  green_lte?: Int;
  green_gt?: Int;
  green_gte?: Int;
  red?: Int;
  red_not?: Int;
  red_in?: Int[] | Int;
  red_not_in?: Int[] | Int;
  red_lt?: Int;
  red_lte?: Int;
  red_gt?: Int;
  red_gte?: Int;
  AND?:
    | CupDataColourCalibScalarWhereInput[]
    | CupDataColourCalibScalarWhereInput;
  OR?:
    | CupDataColourCalibScalarWhereInput[]
    | CupDataColourCalibScalarWhereInput;
  NOT?:
    | CupDataColourCalibScalarWhereInput[]
    | CupDataColourCalibScalarWhereInput;
}

export interface CupDataUserRemoveCreateWithoutExplainIdInput {
  changeTime: DateTimeInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
  userId: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface CupDataColourCalibUpdateManyWithWhereNestedInput {
  where: CupDataColourCalibScalarWhereInput;
  data: CupDataColourCalibUpdateManyDataInput;
}

export interface CupDataUserRemoveExplainCreateInput {
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutExplainIdInput;
  explain: String;
}

export interface CupDataColourCalibUpdateManyDataInput {
  blue?: Int;
  c?: Int;
  green?: Int;
  red?: Int;
}

export interface CupDataUserRemoveUpdateManyMutationInput {
  changeTime?: DateTimeInput;
}

export interface CupDataRawUpdateManyWithoutSerialNumberInput {
  create?:
    | CupDataRawCreateWithoutSerialNumberInput[]
    | CupDataRawCreateWithoutSerialNumberInput;
  delete?: CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput;
  connect?: CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput;
  set?: CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput;
  disconnect?: CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput;
  update?:
    | CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?: CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput;
  updateMany?:
    | CupDataRawUpdateManyWithWhereNestedInput[]
    | CupDataRawUpdateManyWithWhereNestedInput;
}

export interface CupDataUserRemoveCreateInput {
  changeTime: DateTimeInput;
  explainId: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
  userId: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface CupDataRawUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataRawWhereUniqueInput;
  data: CupDataRawUpdateWithoutSerialNumberDataInput;
}

export interface CupDataRejectionUpdateManyMutationInput {
  rejectionDescription?: String;
}

export interface CupDataRawUpdateWithoutSerialNumberDataInput {
  pageData?: String;
}

export interface CupDataProcMdateUpdateWithoutRejectIdDataInput {
  cupDataManMdates?: CupDataManMdateUpdateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rewardAmount?: Int;
  userId?: UserUpdateOneRequiredWithoutCupDataProcMdatesInput;
}

export interface CupDataRawUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataRawWhereUniqueInput;
  update: CupDataRawUpdateWithoutSerialNumberDataInput;
  create: CupDataRawCreateWithoutSerialNumberInput;
}

export interface CupDataProcMdateUpdateWithWhereUniqueWithoutRejectIdInput {
  where: CupDataProcMdateWhereUniqueInput;
  data: CupDataProcMdateUpdateWithoutRejectIdDataInput;
}

export interface CupDataRawScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  pageData?: String;
  pageData_not?: String;
  pageData_in?: String[] | String;
  pageData_not_in?: String[] | String;
  pageData_lt?: String;
  pageData_lte?: String;
  pageData_gt?: String;
  pageData_gte?: String;
  pageData_contains?: String;
  pageData_not_contains?: String;
  pageData_starts_with?: String;
  pageData_not_starts_with?: String;
  pageData_ends_with?: String;
  pageData_not_ends_with?: String;
  AND?: CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput;
  OR?: CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput;
  NOT?: CupDataRawScalarWhereInput[] | CupDataRawScalarWhereInput;
}

export interface CupDataRejectionUpdateInput {
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutRejectIdInput;
  rejectionDescription?: String;
}

export interface CupDataRawUpdateManyWithWhereNestedInput {
  where: CupDataRawScalarWhereInput;
  data: CupDataRawUpdateManyDataInput;
}

export interface CupDataProcMdateCreateWithoutRejectIdInput {
  cupDataManMdates?: CupDataManMdateCreateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rewardAmount?: Int;
  userId: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface CupDataRawUpdateManyDataInput {
  pageData?: String;
}

export interface CupDataRejectionCreateInput {
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutRejectIdInput;
  rejectionDescription: String;
}

export interface FirmwareUpdateOneWithoutCupInput {
  create?: FirmwareCreateWithoutCupInput;
  update?: FirmwareUpdateWithoutCupDataInput;
  upsert?: FirmwareUpsertWithoutCupInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: FirmwareWhereUniqueInput;
}

export interface CupDataRawUpdateManyMutationInput {
  pageData?: String;
}

export interface FirmwareUpdateWithoutCupDataInput {
  fwVersion?: String;
}

export interface CupUpdateWithoutCupDataRawDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface FirmwareUpsertWithoutCupInput {
  update: FirmwareUpdateWithoutCupDataInput;
  create: FirmwareCreateWithoutCupInput;
}

export interface CupUpdateOneWithoutCupDataRawInput {
  create?: CupCreateWithoutCupDataRawInput;
  update?: CupUpdateWithoutCupDataRawDataInput;
  upsert?: CupUpsertWithoutCupDataRawInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CupWhereUniqueInput;
}

export interface HardwareUpdateOneWithoutCupInput {
  create?: HardwareCreateWithoutCupInput;
  update?: HardwareUpdateWithoutCupDataInput;
  upsert?: HardwareUpsertWithoutCupInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HardwareWhereUniqueInput;
}

export interface CupDataRawUpdateInput {
  pageData?: String;
  serialNumber?: CupUpdateOneWithoutCupDataRawInput;
}

export interface HardwareUpdateWithoutCupDataInput {
  hwVersion?: String;
}

export interface CupCreateOneWithoutCupDataRawInput {
  create?: CupCreateWithoutCupDataRawInput;
  connect?: CupWhereUniqueInput;
}

export interface HardwareUpsertWithoutCupInput {
  update: HardwareUpdateWithoutCupDataInput;
  create: HardwareCreateWithoutCupInput;
}

export interface CupDataQuestionUpdateManyMutationInput {
  questionText?: String;
}

export interface UserCupUpdateManyWithoutSerialNumberInput {
  create?:
    | UserCupCreateWithoutSerialNumberInput[]
    | UserCupCreateWithoutSerialNumberInput;
  delete?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  connect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  set?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  disconnect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  update?:
    | UserCupUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | UserCupUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | UserCupUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | UserCupUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?: UserCupScalarWhereInput[] | UserCupScalarWhereInput;
}

export interface AnswerTypeCreateInput {
  answerType: String;
  userInterviewQuestions?: UserInterviewQuestionCreateManyWithoutAnswerTypeIdInput;
}

export interface UserRecordDataByTimeWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  changeTime?: DateTimeInput;
  changeTime_not?: DateTimeInput;
  changeTime_in?: DateTimeInput[] | DateTimeInput;
  changeTime_not_in?: DateTimeInput[] | DateTimeInput;
  changeTime_lt?: DateTimeInput;
  changeTime_lte?: DateTimeInput;
  changeTime_gt?: DateTimeInput;
  changeTime_gte?: DateTimeInput;
  colorB?: Int;
  colorB_not?: Int;
  colorB_in?: Int[] | Int;
  colorB_not_in?: Int[] | Int;
  colorB_lt?: Int;
  colorB_lte?: Int;
  colorB_gt?: Int;
  colorB_gte?: Int;
  colorG?: Int;
  colorG_not?: Int;
  colorG_in?: Int[] | Int;
  colorG_not_in?: Int[] | Int;
  colorG_lt?: Int;
  colorG_lte?: Int;
  colorG_gt?: Int;
  colorG_gte?: Int;
  colorR?: Int;
  colorR_not?: Int;
  colorR_in?: Int[] | Int;
  colorR_not_in?: Int[] | Int;
  colorR_lt?: Int;
  colorR_lte?: Int;
  colorR_gt?: Int;
  colorR_gte?: Int;
  leakage?: String;
  leakage_not?: String;
  leakage_in?: String[] | String;
  leakage_not_in?: String[] | String;
  leakage_lt?: String;
  leakage_lte?: String;
  leakage_gt?: String;
  leakage_gte?: String;
  leakage_contains?: String;
  leakage_not_contains?: String;
  leakage_starts_with?: String;
  leakage_not_starts_with?: String;
  leakage_ends_with?: String;
  leakage_not_ends_with?: String;
  recordDayRowId?: UserRecordDataByDayWhereInput;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  volume?: Float;
  volume_not?: Float;
  volume_in?: Float[] | Float;
  volume_not_in?: Float[] | Float;
  volume_lt?: Float;
  volume_lte?: Float;
  volume_gt?: Float;
  volume_gte?: Float;
  AND?: UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput;
  OR?: UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput;
  NOT?: UserRecordDataByTimeWhereInput[] | UserRecordDataByTimeWhereInput;
}

export interface UserInterviewQuestionCreateWithoutAnswerTypeIdInput {
  question: String;
  userInterviewData?: UserInterviewDatumCreateManyWithoutQuestionIdInput;
}

export interface UserCupUpdateWithoutSerialNumberDataInput {
  userId?: UserUpdateOneWithoutUserCupsInput;
}

export interface UserInterviewDatumCreateWithoutQuestionIdInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeInput;
  userId: UserCreateOneWithoutUserInterviewDataInput;
}

export interface UserUpdateOneWithoutUserCupsInput {
  create?: UserCreateWithoutUserCupsInput;
  update?: UserUpdateWithoutUserCupsDataInput;
  upsert?: UserUpsertWithoutUserCupsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutUserInterviewDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserUpdateWithoutUserCupsDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface AppServerSyncCreateWithoutUserIdInput {
  serverSynchTime: DateTimeInput;
}

export interface EthnicityUpdateOneWithoutUsersInput {
  create?: EthnicityCreateWithoutUsersInput;
  update?: EthnicityUpdateWithoutUsersDataInput;
  upsert?: EthnicityUpsertWithoutUsersInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EthnicityWhereUniqueInput;
}

export interface CountryCreateWithoutUsersInput {
  countryName: String;
}

export interface EthnicityUpdateWithoutUsersDataInput {
  ethnicity?: String;
}

export interface CupDataProcFlowCreateWithoutUserIdInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  mdateRowId: CupDataProcMdateCreateOneWithoutCupDataProcFlowInput;
}

export interface EthnicityUpsertWithoutUsersInput {
  update: EthnicityUpdateWithoutUsersDataInput;
  create: EthnicityCreateWithoutUsersInput;
}

export interface CupDataProcMdateCreateWithoutCupDataProcFlowInput {
  cupDataManMdates?: CupDataManMdateCreateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rejectId?: CupDataRejectionCreateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface UserCoinHistoryUpdateManyWithoutUserIdInput {
  create?:
    | UserCoinHistoryCreateWithoutUserIdInput[]
    | UserCoinHistoryCreateWithoutUserIdInput;
  delete?: UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput;
  connect?: UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput;
  set?: UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput;
  disconnect?:
    | UserCoinHistoryWhereUniqueInput[]
    | UserCoinHistoryWhereUniqueInput;
  update?:
    | UserCoinHistoryUpdateWithWhereUniqueWithoutUserIdInput[]
    | UserCoinHistoryUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | UserCoinHistoryUpsertWithWhereUniqueWithoutUserIdInput[]
    | UserCoinHistoryUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | UserCoinHistoryScalarWhereInput[]
    | UserCoinHistoryScalarWhereInput;
  updateMany?:
    | UserCoinHistoryUpdateManyWithWhereNestedInput[]
    | UserCoinHistoryUpdateManyWithWhereNestedInput;
}

export interface CupDataManMdateCreateWithoutMdateRowIdInput {
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface UserCoinHistoryUpdateWithWhereUniqueWithoutUserIdInput {
  where: UserCoinHistoryWhereUniqueInput;
  data: UserCoinHistoryUpdateWithoutUserIdDataInput;
}

export interface CupDataRejectionCreateWithoutCupDataProcMdatesInput {
  rejectionDescription: String;
}

export interface UserCoinHistoryUpdateWithoutUserIdDataInput {
  category?: String;
  coin?: Int;
  contents?: String;
  date?: DateTimeInput;
  txhash?: String;
}

export interface UserCreateWithoutCupDataProcMdatesInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserCoinHistoryUpsertWithWhereUniqueWithoutUserIdInput {
  where: UserCoinHistoryWhereUniqueInput;
  update: UserCoinHistoryUpdateWithoutUserIdDataInput;
  create: UserCoinHistoryCreateWithoutUserIdInput;
}

export interface CupDataQaResponseCreateWithoutUserIdInput {
  answerId: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  questionId: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
}

export interface UserCoinHistoryScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  category?: String;
  category_not?: String;
  category_in?: String[] | String;
  category_not_in?: String[] | String;
  category_lt?: String;
  category_lte?: String;
  category_gt?: String;
  category_gte?: String;
  category_contains?: String;
  category_not_contains?: String;
  category_starts_with?: String;
  category_not_starts_with?: String;
  category_ends_with?: String;
  category_not_ends_with?: String;
  coin?: Int;
  coin_not?: Int;
  coin_in?: Int[] | Int;
  coin_not_in?: Int[] | Int;
  coin_lt?: Int;
  coin_lte?: Int;
  coin_gt?: Int;
  coin_gte?: Int;
  contents?: String;
  contents_not?: String;
  contents_in?: String[] | String;
  contents_not_in?: String[] | String;
  contents_lt?: String;
  contents_lte?: String;
  contents_gt?: String;
  contents_gte?: String;
  contents_contains?: String;
  contents_not_contains?: String;
  contents_starts_with?: String;
  contents_not_starts_with?: String;
  contents_ends_with?: String;
  contents_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  txhash?: String;
  txhash_not?: String;
  txhash_in?: String[] | String;
  txhash_not_in?: String[] | String;
  txhash_lt?: String;
  txhash_lte?: String;
  txhash_gt?: String;
  txhash_gte?: String;
  txhash_contains?: String;
  txhash_not_contains?: String;
  txhash_starts_with?: String;
  txhash_not_starts_with?: String;
  txhash_ends_with?: String;
  txhash_not_ends_with?: String;
  AND?: UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput;
  OR?: UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput;
  NOT?: UserCoinHistoryScalarWhereInput[] | UserCoinHistoryScalarWhereInput;
}

export interface CupDataAnswerCreateWithoutCupDataQaResponseInput {
  answerText: String;
  questionId: CupDataQuestionCreateOneWithoutCupDataAnswerInput;
}

export interface UserCoinHistoryUpdateManyWithWhereNestedInput {
  where: UserCoinHistoryScalarWhereInput;
  data: UserCoinHistoryUpdateManyDataInput;
}

export interface CupDataQuestionCreateWithoutCupDataAnswerInput {
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutQuestionIdInput;
  questionText: String;
}

export interface UserCoinHistoryUpdateManyDataInput {
  category?: String;
  coin?: Int;
  contents?: String;
  date?: DateTimeInput;
  txhash?: String;
}

export interface CupDataQaResponseCreateWithoutQuestionIdInput {
  answerId: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  userId: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface UserInterviewDatumUpdateManyWithoutUserIdInput {
  create?:
    | UserInterviewDatumCreateWithoutUserIdInput[]
    | UserInterviewDatumCreateWithoutUserIdInput;
  delete?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  connect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  set?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  disconnect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  update?:
    | UserInterviewDatumUpdateWithWhereUniqueWithoutUserIdInput[]
    | UserInterviewDatumUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | UserInterviewDatumUpsertWithWhereUniqueWithoutUserIdInput[]
    | UserInterviewDatumUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | UserInterviewDatumScalarWhereInput[]
    | UserInterviewDatumScalarWhereInput;
  updateMany?:
    | UserInterviewDatumUpdateManyWithWhereNestedInput[]
    | UserInterviewDatumUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutCupDataQaResponseInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserInterviewDatumUpdateWithWhereUniqueWithoutUserIdInput {
  where: UserInterviewDatumWhereUniqueInput;
  data: UserInterviewDatumUpdateWithoutUserIdDataInput;
}

export interface CupDataProcMdateCreateWithoutUserIdInput {
  cupDataManMdates?: CupDataManMdateCreateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rejectId?: CupDataRejectionCreateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
}

export interface UserInterviewDatumUpdateWithoutUserIdDataInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date?: DateTimeInput;
  questionId?: UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput;
}

export interface CupDataProcFlowCreateWithoutMdateRowIdInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  userId: UserCreateOneWithoutCupDataProcFlowInput;
}

export interface UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput {
  create?: UserInterviewQuestionCreateWithoutUserInterviewDataInput;
  update?: UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput;
  upsert?: UserInterviewQuestionUpsertWithoutUserInterviewDataInput;
  connect?: UserInterviewQuestionWhereUniqueInput;
}

export interface UserCreateWithoutCupDataProcFlowInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput {
  answerTypeId?: AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput;
  question?: String;
}

export interface CupDataUserRemoveCreateWithoutUserIdInput {
  changeTime: DateTimeInput;
  explainId: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  serialNumber: CupCreateOneWithoutCupDataUserRemoveInput;
}

export interface AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput {
  create?: AnswerTypeCreateWithoutUserInterviewQuestionsInput;
  update?: AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput;
  upsert?: AnswerTypeUpsertWithoutUserInterviewQuestionsInput;
  connect?: AnswerTypeWhereUniqueInput;
}

export interface CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput {
  explain: String;
}

export interface AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput {
  answerType?: String;
}

export interface CupCreateWithoutCupDataUserRemoveInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface AnswerTypeUpsertWithoutUserInterviewQuestionsInput {
  update: AnswerTypeUpdateWithoutUserInterviewQuestionsDataInput;
  create: AnswerTypeCreateWithoutUserInterviewQuestionsInput;
}

export interface CalibrationCreateWithoutCupInput {
  calibVersion: String;
}

export interface UserInterviewQuestionUpsertWithoutUserInterviewDataInput {
  update: UserInterviewQuestionUpdateWithoutUserInterviewDataDataInput;
  create: UserInterviewQuestionCreateWithoutUserInterviewDataInput;
}

export interface CompanyCreateWithoutCupInput {
  companyName: String;
}

export interface UserInterviewDatumUpsertWithWhereUniqueWithoutUserIdInput {
  where: UserInterviewDatumWhereUniqueInput;
  update: UserInterviewDatumUpdateWithoutUserIdDataInput;
  create: UserInterviewDatumCreateWithoutUserIdInput;
}

export interface CupAppSyncCreateWithoutSerialNumberInput {
  appSynchTime: DateTimeInput;
}

export interface UserInterviewDatumScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerRange?: Int;
  answerRange_not?: Int;
  answerRange_in?: Int[] | Int;
  answerRange_not_in?: Int[] | Int;
  answerRange_lt?: Int;
  answerRange_lte?: Int;
  answerRange_gt?: Int;
  answerRange_gte?: Int;
  answerText?: String;
  answerText_not?: String;
  answerText_in?: String[] | String;
  answerText_not_in?: String[] | String;
  answerText_lt?: String;
  answerText_lte?: String;
  answerText_gt?: String;
  answerText_gte?: String;
  answerText_contains?: String;
  answerText_not_contains?: String;
  answerText_starts_with?: String;
  answerText_not_starts_with?: String;
  answerText_ends_with?: String;
  answerText_not_ends_with?: String;
  answerYn?: Boolean;
  answerYn_not?: Boolean;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?:
    | UserInterviewDatumScalarWhereInput[]
    | UserInterviewDatumScalarWhereInput;
  OR?:
    | UserInterviewDatumScalarWhereInput[]
    | UserInterviewDatumScalarWhereInput;
  NOT?:
    | UserInterviewDatumScalarWhereInput[]
    | UserInterviewDatumScalarWhereInput;
}

export interface CupDatumCreateWithoutSerialNumberInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: CupDataColourCalcCreateManyWithoutCupDataRowIdInput;
  cupDataProcVolume?: CupDataProcVolumeCreateManyWithoutCupDataRowIdInput;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface UserInterviewDatumUpdateManyWithWhereNestedInput {
  where: UserInterviewDatumScalarWhereInput;
  data: UserInterviewDatumUpdateManyDataInput;
}

export interface CupDataColourCalcCreateWithoutCupDataRowIdInput {
  blue: Int;
  green: Int;
  red: Int;
}

export interface UserInterviewDatumUpdateManyDataInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date?: DateTimeInput;
}

export interface CupDataProcVolumeCreateWithoutCupDataRowIdInput {
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface UserRecordDataByPeriodUpdateManyWithoutUserIdInput {
  create?:
    | UserRecordDataByPeriodCreateWithoutUserIdInput[]
    | UserRecordDataByPeriodCreateWithoutUserIdInput;
  delete?:
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput;
  connect?:
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput;
  set?:
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput;
  disconnect?:
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput;
  update?:
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserIdInput[]
    | UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserIdInput[]
    | UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?:
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput;
  updateMany?:
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput[]
    | UserRecordDataByPeriodUpdateManyWithWhereNestedInput;
}

export interface CupDataColourCalibCreateWithoutSerialNumberInput {
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface UserRecordDataByPeriodUpdateWithWhereUniqueWithoutUserIdInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  data: UserRecordDataByPeriodUpdateWithoutUserIdDataInput;
}

export interface CupDataRawCreateWithoutSerialNumberInput {
  pageData: String;
}

export interface UserRecordDataByPeriodUpdateWithoutUserIdDataInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userRecordDataByDay?: UserRecordDataByDayUpdateManyWithoutRecordPeriodRowIdInput;
}

export interface FirmwareCreateWithoutCupInput {
  fwVersion: String;
}

export interface UserRecordDataByDayUpdateManyWithoutRecordPeriodRowIdInput {
  create?:
    | UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput[]
    | UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput;
  delete?:
    | UserRecordDataByDayWhereUniqueInput[]
    | UserRecordDataByDayWhereUniqueInput;
  connect?:
    | UserRecordDataByDayWhereUniqueInput[]
    | UserRecordDataByDayWhereUniqueInput;
  set?:
    | UserRecordDataByDayWhereUniqueInput[]
    | UserRecordDataByDayWhereUniqueInput;
  disconnect?:
    | UserRecordDataByDayWhereUniqueInput[]
    | UserRecordDataByDayWhereUniqueInput;
  update?:
    | UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowIdInput[]
    | UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowIdInput;
  upsert?:
    | UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowIdInput[]
    | UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowIdInput;
  deleteMany?:
    | UserRecordDataByDayScalarWhereInput[]
    | UserRecordDataByDayScalarWhereInput;
  updateMany?:
    | UserRecordDataByDayUpdateManyWithWhereNestedInput[]
    | UserRecordDataByDayUpdateManyWithWhereNestedInput;
}

export interface HardwareCreateWithoutCupInput {
  hwVersion: String;
}

export interface UserRecordDataByDayUpdateWithWhereUniqueWithoutRecordPeriodRowIdInput {
  where: UserRecordDataByDayWhereUniqueInput;
  data: UserRecordDataByDayUpdateWithoutRecordPeriodRowIdDataInput;
}

export interface UserCupCreateWithoutSerialNumberInput {
  userId?: UserCreateOneWithoutUserCupsInput;
}

export interface UserRecordDataByDayUpdateWithoutRecordPeriodRowIdDataInput {
  crampsLevel?: Int;
  recordDate?: DateTimeInput;
  userRecordDataByTime?: UserRecordDataByTimeUpdateManyWithoutRecordDayRowIdInput;
}

export interface UserCreateWithoutUserCupsInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserRecordDataByTimeUpdateManyWithoutRecordDayRowIdInput {
  create?:
    | UserRecordDataByTimeCreateWithoutRecordDayRowIdInput[]
    | UserRecordDataByTimeCreateWithoutRecordDayRowIdInput;
  delete?:
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput;
  connect?:
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput;
  set?:
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput;
  disconnect?:
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput;
  update?:
    | UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowIdInput[]
    | UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowIdInput;
  upsert?:
    | UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowIdInput[]
    | UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowIdInput;
  deleteMany?:
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput;
  updateMany?:
    | UserRecordDataByTimeUpdateManyWithWhereNestedInput[]
    | UserRecordDataByTimeUpdateManyWithWhereNestedInput;
}

export interface EthnicityCreateWithoutUsersInput {
  ethnicity: String;
}

export interface UserRecordDataByTimeUpdateWithWhereUniqueWithoutRecordDayRowIdInput {
  where: UserRecordDataByTimeWhereUniqueInput;
  data: UserRecordDataByTimeUpdateWithoutRecordDayRowIdDataInput;
}

export interface UserCoinHistoryCreateWithoutUserIdInput {
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeInput;
  txhash: String;
}

export interface UserRecordDataByTimeUpdateWithoutRecordDayRowIdDataInput {
  changeTime?: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface UserInterviewDatumCreateWithoutUserIdInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeInput;
  questionId: UserInterviewQuestionCreateOneWithoutUserInterviewDataInput;
}

export interface UserRecordDataByTimeUpsertWithWhereUniqueWithoutRecordDayRowIdInput {
  where: UserRecordDataByTimeWhereUniqueInput;
  update: UserRecordDataByTimeUpdateWithoutRecordDayRowIdDataInput;
  create: UserRecordDataByTimeCreateWithoutRecordDayRowIdInput;
}

export interface UserInterviewQuestionCreateWithoutUserInterviewDataInput {
  answerTypeId: AnswerTypeCreateOneWithoutUserInterviewQuestionsInput;
  question: String;
}

export interface UserRecordDataByTimeScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  changeTime?: DateTimeInput;
  changeTime_not?: DateTimeInput;
  changeTime_in?: DateTimeInput[] | DateTimeInput;
  changeTime_not_in?: DateTimeInput[] | DateTimeInput;
  changeTime_lt?: DateTimeInput;
  changeTime_lte?: DateTimeInput;
  changeTime_gt?: DateTimeInput;
  changeTime_gte?: DateTimeInput;
  colorB?: Int;
  colorB_not?: Int;
  colorB_in?: Int[] | Int;
  colorB_not_in?: Int[] | Int;
  colorB_lt?: Int;
  colorB_lte?: Int;
  colorB_gt?: Int;
  colorB_gte?: Int;
  colorG?: Int;
  colorG_not?: Int;
  colorG_in?: Int[] | Int;
  colorG_not_in?: Int[] | Int;
  colorG_lt?: Int;
  colorG_lte?: Int;
  colorG_gt?: Int;
  colorG_gte?: Int;
  colorR?: Int;
  colorR_not?: Int;
  colorR_in?: Int[] | Int;
  colorR_not_in?: Int[] | Int;
  colorR_lt?: Int;
  colorR_lte?: Int;
  colorR_gt?: Int;
  colorR_gte?: Int;
  leakage?: String;
  leakage_not?: String;
  leakage_in?: String[] | String;
  leakage_not_in?: String[] | String;
  leakage_lt?: String;
  leakage_lte?: String;
  leakage_gt?: String;
  leakage_gte?: String;
  leakage_contains?: String;
  leakage_not_contains?: String;
  leakage_starts_with?: String;
  leakage_not_starts_with?: String;
  leakage_ends_with?: String;
  leakage_not_ends_with?: String;
  startTime?: DateTimeInput;
  startTime_not?: DateTimeInput;
  startTime_in?: DateTimeInput[] | DateTimeInput;
  startTime_not_in?: DateTimeInput[] | DateTimeInput;
  startTime_lt?: DateTimeInput;
  startTime_lte?: DateTimeInput;
  startTime_gt?: DateTimeInput;
  startTime_gte?: DateTimeInput;
  volume?: Float;
  volume_not?: Float;
  volume_in?: Float[] | Float;
  volume_not_in?: Float[] | Float;
  volume_lt?: Float;
  volume_lte?: Float;
  volume_gt?: Float;
  volume_gte?: Float;
  AND?:
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput;
  OR?:
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput;
  NOT?:
    | UserRecordDataByTimeScalarWhereInput[]
    | UserRecordDataByTimeScalarWhereInput;
}

export interface AnswerTypeCreateWithoutUserInterviewQuestionsInput {
  answerType: String;
}

export interface UserRecordDataByTimeUpdateManyWithWhereNestedInput {
  where: UserRecordDataByTimeScalarWhereInput;
  data: UserRecordDataByTimeUpdateManyDataInput;
}

export interface UserRecordDataByPeriodCreateWithoutUserIdInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userRecordDataByDay?: UserRecordDataByDayCreateManyWithoutRecordPeriodRowIdInput;
}

export interface UserRecordDataByTimeUpdateManyDataInput {
  changeTime?: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput {
  crampsLevel?: Int;
  recordDate: DateTimeInput;
  userRecordDataByTime?: UserRecordDataByTimeCreateManyWithoutRecordDayRowIdInput;
}

export interface UserRecordDataByDayUpsertWithWhereUniqueWithoutRecordPeriodRowIdInput {
  where: UserRecordDataByDayWhereUniqueInput;
  update: UserRecordDataByDayUpdateWithoutRecordPeriodRowIdDataInput;
  create: UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput;
}

export interface UserRecordDataByTimeCreateWithoutRecordDayRowIdInput {
  changeTime: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface UserRecordDataByDayScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  crampsLevel?: Int;
  crampsLevel_not?: Int;
  crampsLevel_in?: Int[] | Int;
  crampsLevel_not_in?: Int[] | Int;
  crampsLevel_lt?: Int;
  crampsLevel_lte?: Int;
  crampsLevel_gt?: Int;
  crampsLevel_gte?: Int;
  recordDate?: DateTimeInput;
  recordDate_not?: DateTimeInput;
  recordDate_in?: DateTimeInput[] | DateTimeInput;
  recordDate_not_in?: DateTimeInput[] | DateTimeInput;
  recordDate_lt?: DateTimeInput;
  recordDate_lte?: DateTimeInput;
  recordDate_gt?: DateTimeInput;
  recordDate_gte?: DateTimeInput;
  AND?:
    | UserRecordDataByDayScalarWhereInput[]
    | UserRecordDataByDayScalarWhereInput;
  OR?:
    | UserRecordDataByDayScalarWhereInput[]
    | UserRecordDataByDayScalarWhereInput;
  NOT?:
    | UserRecordDataByDayScalarWhereInput[]
    | UserRecordDataByDayScalarWhereInput;
}

export interface UserCupCreateWithoutUserIdInput {
  serialNumber?: CupCreateOneWithoutUserCupsInput;
}

export interface UserRecordDataByDayUpdateManyWithWhereNestedInput {
  where: UserRecordDataByDayScalarWhereInput;
  data: UserRecordDataByDayUpdateManyDataInput;
}

export interface CupCreateWithoutUserCupsInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
}

export interface UserRecordDataByDayUpdateManyDataInput {
  crampsLevel?: Int;
  recordDate?: DateTimeInput;
}

export interface CupDataUserRemoveCreateWithoutSerialNumberInput {
  changeTime: DateTimeInput;
  explainId: CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput;
  userId: UserCreateOneWithoutCupDataUserRemoveInput;
}

export interface UserRecordDataByPeriodUpsertWithWhereUniqueWithoutUserIdInput {
  where: UserRecordDataByPeriodWhereUniqueInput;
  update: UserRecordDataByPeriodUpdateWithoutUserIdDataInput;
  create: UserRecordDataByPeriodCreateWithoutUserIdInput;
}

export interface UserCreateWithoutCupDataUserRemoveInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserRecordDataByPeriodScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  coinHistoryRowId?: Int;
  coinHistoryRowId_not?: Int;
  coinHistoryRowId_in?: Int[] | Int;
  coinHistoryRowId_not_in?: Int[] | Int;
  coinHistoryRowId_lt?: Int;
  coinHistoryRowId_lte?: Int;
  coinHistoryRowId_gt?: Int;
  coinHistoryRowId_gte?: Int;
  isTakePill?: Boolean;
  isTakePill_not?: Boolean;
  mensFinish?: DateTimeInput;
  mensFinish_not?: DateTimeInput;
  mensFinish_in?: DateTimeInput[] | DateTimeInput;
  mensFinish_not_in?: DateTimeInput[] | DateTimeInput;
  mensFinish_lt?: DateTimeInput;
  mensFinish_lte?: DateTimeInput;
  mensFinish_gt?: DateTimeInput;
  mensFinish_gte?: DateTimeInput;
  mensStart?: DateTimeInput;
  mensStart_not?: DateTimeInput;
  mensStart_in?: DateTimeInput[] | DateTimeInput;
  mensStart_not_in?: DateTimeInput[] | DateTimeInput;
  mensStart_lt?: DateTimeInput;
  mensStart_lte?: DateTimeInput;
  mensStart_gt?: DateTimeInput;
  mensStart_gte?: DateTimeInput;
  AND?:
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput;
  OR?:
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput;
  NOT?:
    | UserRecordDataByPeriodScalarWhereInput[]
    | UserRecordDataByPeriodScalarWhereInput;
}

export interface CupDataQuestionCreateWithoutCupDataQaResponseInput {
  cupDataAnswer?: CupDataAnswerCreateManyWithoutQuestionIdInput;
  questionText: String;
}

export interface UserRecordDataByPeriodUpdateManyWithWhereNestedInput {
  where: UserRecordDataByPeriodScalarWhereInput;
  data: UserRecordDataByPeriodUpdateManyDataInput;
}

export interface CupDataAnswerCreateWithoutQuestionIdInput {
  answerText: String;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutAnswerIdInput;
}

export interface UserRecordDataByPeriodUpdateManyDataInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
}

export interface CupDataQaResponseCreateWithoutAnswerIdInput {
  qaDate: DateTimeInput;
  questionId: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
  userId: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface UserUpsertWithoutUserCupsInput {
  update: UserUpdateWithoutUserCupsDataInput;
  create: UserCreateWithoutUserCupsInput;
}

export interface UserInterviewQuestionUpdateManyWithoutAnswerTypeIdInput {
  create?:
    | UserInterviewQuestionCreateWithoutAnswerTypeIdInput[]
    | UserInterviewQuestionCreateWithoutAnswerTypeIdInput;
  delete?:
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput;
  connect?:
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput;
  set?:
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput;
  disconnect?:
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput;
  update?:
    | UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeIdInput[]
    | UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeIdInput;
  upsert?:
    | UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeIdInput[]
    | UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeIdInput;
  deleteMany?:
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput;
  updateMany?:
    | UserInterviewQuestionUpdateManyWithWhereNestedInput[]
    | UserInterviewQuestionUpdateManyWithWhereNestedInput;
}

export interface UserCupUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: UserCupWhereUniqueInput;
  update: UserCupUpdateWithoutSerialNumberDataInput;
  create: UserCupCreateWithoutSerialNumberInput;
}

export interface UserInterviewQuestionUpdateWithoutAnswerTypeIdDataInput {
  question?: String;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutQuestionIdInput;
}

export interface UserCupScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  AND?: UserCupScalarWhereInput[] | UserCupScalarWhereInput;
  OR?: UserCupScalarWhereInput[] | UserCupScalarWhereInput;
  NOT?: UserCupScalarWhereInput[] | UserCupScalarWhereInput;
}

export interface UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionIdInput {
  where: UserInterviewDatumWhereUniqueInput;
  data: UserInterviewDatumUpdateWithoutQuestionIdDataInput;
}

export interface CupUpsertWithoutCupDataUserRemoveInput {
  update: CupUpdateWithoutCupDataUserRemoveDataInput;
  create: CupCreateWithoutCupDataUserRemoveInput;
}

export interface UserUpdateOneRequiredWithoutUserInterviewDataInput {
  create?: UserCreateWithoutUserInterviewDataInput;
  update?: UserUpdateWithoutUserInterviewDataDataInput;
  upsert?: UserUpsertWithoutUserInterviewDataInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutUserIdInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutUserIdDataInput;
  create: CupDataUserRemoveCreateWithoutUserIdInput;
}

export interface AppServerSyncUpdateManyWithoutUserIdInput {
  create?:
    | AppServerSyncCreateWithoutUserIdInput[]
    | AppServerSyncCreateWithoutUserIdInput;
  delete?: AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput;
  connect?: AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput;
  set?: AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput;
  disconnect?: AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput;
  update?:
    | AppServerSyncUpdateWithWhereUniqueWithoutUserIdInput[]
    | AppServerSyncUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | AppServerSyncUpsertWithWhereUniqueWithoutUserIdInput[]
    | AppServerSyncUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?: AppServerSyncScalarWhereInput[] | AppServerSyncScalarWhereInput;
  updateMany?:
    | AppServerSyncUpdateManyWithWhereNestedInput[]
    | AppServerSyncUpdateManyWithWhereNestedInput;
}

export interface CupDataUserRemoveScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  changeTime?: DateTimeInput;
  changeTime_not?: DateTimeInput;
  changeTime_in?: DateTimeInput[] | DateTimeInput;
  changeTime_not_in?: DateTimeInput[] | DateTimeInput;
  changeTime_lt?: DateTimeInput;
  changeTime_lte?: DateTimeInput;
  changeTime_gt?: DateTimeInput;
  changeTime_gte?: DateTimeInput;
  AND?: CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput;
  OR?: CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput;
  NOT?: CupDataUserRemoveScalarWhereInput[] | CupDataUserRemoveScalarWhereInput;
}

export interface UserRecordDataByTimeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRecordDataByTimeWhereInput;
  AND?:
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput;
  OR?:
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput;
  NOT?:
    | UserRecordDataByTimeSubscriptionWhereInput[]
    | UserRecordDataByTimeSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpdateManyWithWhereNestedInput {
  where: CupDataUserRemoveScalarWhereInput;
  data: CupDataUserRemoveUpdateManyDataInput;
}

export interface UserInterviewQuestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserInterviewQuestionWhereInput;
  AND?:
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput;
  OR?:
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput;
  NOT?:
    | UserInterviewQuestionSubscriptionWhereInput[]
    | UserInterviewQuestionSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpdateManyDataInput {
  changeTime?: DateTimeInput;
}

export interface UserCupSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserCupWhereInput;
  AND?: UserCupSubscriptionWhereInput[] | UserCupSubscriptionWhereInput;
  OR?: UserCupSubscriptionWhereInput[] | UserCupSubscriptionWhereInput;
  NOT?: UserCupSubscriptionWhereInput[] | UserCupSubscriptionWhereInput;
}

export interface UserCupUpdateManyWithoutUserIdInput {
  create?: UserCupCreateWithoutUserIdInput[] | UserCupCreateWithoutUserIdInput;
  delete?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  connect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  set?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  disconnect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
  update?:
    | UserCupUpdateWithWhereUniqueWithoutUserIdInput[]
    | UserCupUpdateWithWhereUniqueWithoutUserIdInput;
  upsert?:
    | UserCupUpsertWithWhereUniqueWithoutUserIdInput[]
    | UserCupUpsertWithWhereUniqueWithoutUserIdInput;
  deleteMany?: UserCupScalarWhereInput[] | UserCupScalarWhereInput;
}

export interface HardwareWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cup_every?: CupWhereInput;
  cup_some?: CupWhereInput;
  cup_none?: CupWhereInput;
  hwVersion?: String;
  hwVersion_not?: String;
  hwVersion_in?: String[] | String;
  hwVersion_not_in?: String[] | String;
  hwVersion_lt?: String;
  hwVersion_lte?: String;
  hwVersion_gt?: String;
  hwVersion_gte?: String;
  hwVersion_contains?: String;
  hwVersion_not_contains?: String;
  hwVersion_starts_with?: String;
  hwVersion_not_starts_with?: String;
  hwVersion_ends_with?: String;
  hwVersion_not_ends_with?: String;
  AND?: HardwareWhereInput[] | HardwareWhereInput;
  OR?: HardwareWhereInput[] | HardwareWhereInput;
  NOT?: HardwareWhereInput[] | HardwareWhereInput;
}

export interface UserCupUpdateWithWhereUniqueWithoutUserIdInput {
  where: UserCupWhereUniqueInput;
  data: UserCupUpdateWithoutUserIdDataInput;
}

export interface FirmwareSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FirmwareWhereInput;
  AND?: FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput;
  OR?: FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput;
  NOT?: FirmwareSubscriptionWhereInput[] | FirmwareSubscriptionWhereInput;
}

export interface UserCupUpdateWithoutUserIdDataInput {
  serialNumber?: CupUpdateOneWithoutUserCupsInput;
}

export interface CupDatumSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDatumWhereInput;
  AND?: CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput;
  OR?: CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput;
  NOT?: CupDatumSubscriptionWhereInput[] | CupDatumSubscriptionWhereInput;
}

export interface CupUpdateOneWithoutUserCupsInput {
  create?: CupCreateWithoutUserCupsInput;
  update?: CupUpdateWithoutUserCupsDataInput;
  upsert?: CupUpsertWithoutUserCupsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CupWhereUniqueInput;
}

export interface CupDataRejectionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataRejectionWhereInput;
  AND?:
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput;
  OR?:
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput;
  NOT?:
    | CupDataRejectionSubscriptionWhereInput[]
    | CupDataRejectionSubscriptionWhereInput;
}

export interface CupUpdateWithoutUserCupsDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
}

export interface CupDataQuestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataQuestionWhereInput;
  AND?:
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput;
  OR?:
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput;
  NOT?:
    | CupDataQuestionSubscriptionWhereInput[]
    | CupDataQuestionSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpdateManyWithoutSerialNumberInput {
  create?:
    | CupDataUserRemoveCreateWithoutSerialNumberInput[]
    | CupDataUserRemoveCreateWithoutSerialNumberInput;
  delete?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  set?: CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput;
  disconnect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  update?:
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput;
  upsert?:
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput;
  deleteMany?:
    | CupDataUserRemoveScalarWhereInput[]
    | CupDataUserRemoveScalarWhereInput;
  updateMany?:
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput;
}

export interface CupDataProcVolumeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataProcVolumeWhereInput;
  AND?:
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput;
  OR?:
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput;
  NOT?:
    | CupDataProcVolumeSubscriptionWhereInput[]
    | CupDataProcVolumeSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpdateWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataUserRemoveWhereUniqueInput;
  data: CupDataUserRemoveUpdateWithoutSerialNumberDataInput;
}

export interface CupDataProcFlowSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataProcFlowWhereInput;
  AND?:
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput;
  OR?:
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput;
  NOT?:
    | CupDataProcFlowSubscriptionWhereInput[]
    | CupDataProcFlowSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpdateWithoutSerialNumberDataInput {
  changeTime?: DateTimeInput;
  explainId?: CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput;
  userId?: UserUpdateOneRequiredWithoutCupDataUserRemoveInput;
}

export interface CupDataColourCalcSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataColourCalcWhereInput;
  AND?:
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput;
  OR?:
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput;
  NOT?:
    | CupDataColourCalcSubscriptionWhereInput[]
    | CupDataColourCalcSubscriptionWhereInput;
}

export interface UserUpdateOneRequiredWithoutCupDataUserRemoveInput {
  create?: UserCreateWithoutCupDataUserRemoveInput;
  update?: UserUpdateWithoutCupDataUserRemoveDataInput;
  upsert?: UserUpsertWithoutCupDataUserRemoveInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataQuestionWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cupDataAnswer_every?: CupDataAnswerWhereInput;
  cupDataAnswer_some?: CupDataAnswerWhereInput;
  cupDataAnswer_none?: CupDataAnswerWhereInput;
  cupDataQaResponse_every?: CupDataQaResponseWhereInput;
  cupDataQaResponse_some?: CupDataQaResponseWhereInput;
  cupDataQaResponse_none?: CupDataQaResponseWhereInput;
  questionText?: String;
  questionText_not?: String;
  questionText_in?: String[] | String;
  questionText_not_in?: String[] | String;
  questionText_lt?: String;
  questionText_lte?: String;
  questionText_gt?: String;
  questionText_gte?: String;
  questionText_contains?: String;
  questionText_not_contains?: String;
  questionText_starts_with?: String;
  questionText_not_starts_with?: String;
  questionText_ends_with?: String;
  questionText_not_ends_with?: String;
  AND?: CupDataQuestionWhereInput[] | CupDataQuestionWhereInput;
  OR?: CupDataQuestionWhereInput[] | CupDataQuestionWhereInput;
  NOT?: CupDataQuestionWhereInput[] | CupDataQuestionWhereInput;
}

export interface UserUpdateWithoutCupDataUserRemoveDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupDataQaResponseWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerId?: CupDataAnswerWhereInput;
  qaDate?: DateTimeInput;
  qaDate_not?: DateTimeInput;
  qaDate_in?: DateTimeInput[] | DateTimeInput;
  qaDate_not_in?: DateTimeInput[] | DateTimeInput;
  qaDate_lt?: DateTimeInput;
  qaDate_lte?: DateTimeInput;
  qaDate_gt?: DateTimeInput;
  qaDate_gte?: DateTimeInput;
  questionId?: CupDataQuestionWhereInput;
  userId?: UserWhereInput;
  AND?: CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput;
  OR?: CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput;
  NOT?: CupDataQaResponseWhereInput[] | CupDataQaResponseWhereInput;
}

export interface UserUpsertWithoutCupDataUserRemoveInput {
  update: UserUpdateWithoutCupDataUserRemoveDataInput;
  create: UserCreateWithoutCupDataUserRemoveInput;
}

export interface AuthTokenSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AuthTokenWhereInput;
  AND?: AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput;
  OR?: AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput;
  NOT?: AuthTokenSubscriptionWhereInput[] | AuthTokenSubscriptionWhereInput;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutSerialNumberInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutSerialNumberDataInput;
  create: CupDataUserRemoveCreateWithoutSerialNumberInput;
}

export interface UsersDataAnalysisUpdateManyMutationInput {
  email?: String;
  firstName?: String;
  lastName?: String;
  password?: String;
  userId?: String;
}

export interface CupUpsertWithoutUserCupsInput {
  update: CupUpdateWithoutUserCupsDataInput;
  create: CupCreateWithoutUserCupsInput;
}

export interface UserRecordDataByTimeUpdateManyMutationInput {
  changeTime?: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface UserCupUpsertWithWhereUniqueWithoutUserIdInput {
  where: UserCupWhereUniqueInput;
  update: UserCupUpdateWithoutUserIdDataInput;
  create: UserCupCreateWithoutUserIdInput;
}

export interface UserRecordDataByDayUpdateWithoutUserRecordDataByTimeDataInput {
  crampsLevel?: Int;
  recordDate?: DateTimeInput;
  recordPeriodRowId?: UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput;
}

export interface UserUpsertWithoutCupDataProcFlowInput {
  update: UserUpdateWithoutCupDataProcFlowDataInput;
  create: UserCreateWithoutCupDataProcFlowInput;
}

export interface UserRecordDataByTimeUpdateInput {
  changeTime?: DateTimeInput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  recordDayRowId?: UserRecordDataByDayUpdateOneWithoutUserRecordDataByTimeInput;
  startTime?: DateTimeInput;
  volume?: Float;
}

export interface CupDataProcFlowUpsertWithWhereUniqueWithoutMdateRowIdInput {
  where: CupDataProcFlowWhereUniqueInput;
  update: CupDataProcFlowUpdateWithoutMdateRowIdDataInput;
  create: CupDataProcFlowCreateWithoutMdateRowIdInput;
}

export interface CupDataProcFlowWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  hourlyFlow?: Int;
  hourlyFlow_not?: Int;
  hourlyFlow_in?: Int[] | Int;
  hourlyFlow_not_in?: Int[] | Int;
  hourlyFlow_lt?: Int;
  hourlyFlow_lte?: Int;
  hourlyFlow_gt?: Int;
  hourlyFlow_gte?: Int;
  mdateRowId?: CupDataProcMdateWhereInput;
  userId?: UserWhereInput;
  AND?: CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput;
  OR?: CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput;
  NOT?: CupDataProcFlowWhereInput[] | CupDataProcFlowWhereInput;
}

export interface CupDataProcFlowScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  hourlyFlow?: Int;
  hourlyFlow_not?: Int;
  hourlyFlow_in?: Int[] | Int;
  hourlyFlow_not_in?: Int[] | Int;
  hourlyFlow_lt?: Int;
  hourlyFlow_lte?: Int;
  hourlyFlow_gt?: Int;
  hourlyFlow_gte?: Int;
  AND?: CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput;
  OR?: CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput;
  NOT?: CupDataProcFlowScalarWhereInput[] | CupDataProcFlowScalarWhereInput;
}

export type CountryWhereUniqueInput = AtLeastOne<{
  id: Int;
  countryName?: String;
}>;

export interface CupDataProcFlowUpdateManyWithWhereNestedInput {
  where: CupDataProcFlowScalarWhereInput;
  data: CupDataProcFlowUpdateManyDataInput;
}

export interface UserRecordDataByPeriodUpsertWithoutUserRecordDataByDayInput {
  update: UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput;
  create: UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput;
}

export interface CupDataProcFlowUpdateManyDataInput {
  date?: DateTimeInput;
  hourlyFlow?: Int;
}

export interface UserUpdateOneWithoutUserRecordDataByPeriodInput {
  create?: UserCreateWithoutUserRecordDataByPeriodInput;
  update?: UserUpdateWithoutUserRecordDataByPeriodDataInput;
  upsert?: UserUpsertWithoutUserRecordDataByPeriodInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface CupDataProcMdateUpsertWithWhereUniqueWithoutUserIdInput {
  where: CupDataProcMdateWhereUniqueInput;
  update: CupDataProcMdateUpdateWithoutUserIdDataInput;
  create: CupDataProcMdateCreateWithoutUserIdInput;
}

export interface UserRecordDataByDayUpdateInput {
  crampsLevel?: Int;
  recordDate?: DateTimeInput;
  recordPeriodRowId?: UserRecordDataByPeriodUpdateOneWithoutUserRecordDataByDayInput;
  userRecordDataByTime?: UserRecordDataByTimeUpdateManyWithoutRecordDayRowIdInput;
}

export interface CupDataProcMdateScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  dataRejected?: Boolean;
  dataRejected_not?: Boolean;
  dataVerified?: Boolean;
  dataVerified_not?: Boolean;
  menFinish?: DateTimeInput;
  menFinish_not?: DateTimeInput;
  menFinish_in?: DateTimeInput[] | DateTimeInput;
  menFinish_not_in?: DateTimeInput[] | DateTimeInput;
  menFinish_lt?: DateTimeInput;
  menFinish_lte?: DateTimeInput;
  menFinish_gt?: DateTimeInput;
  menFinish_gte?: DateTimeInput;
  menStart?: DateTimeInput;
  menStart_not?: DateTimeInput;
  menStart_in?: DateTimeInput[] | DateTimeInput;
  menStart_not_in?: DateTimeInput[] | DateTimeInput;
  menStart_lt?: DateTimeInput;
  menStart_lte?: DateTimeInput;
  menStart_gt?: DateTimeInput;
  menStart_gte?: DateTimeInput;
  rewardAmount?: Int;
  rewardAmount_not?: Int;
  rewardAmount_in?: Int[] | Int;
  rewardAmount_not_in?: Int[] | Int;
  rewardAmount_lt?: Int;
  rewardAmount_lte?: Int;
  rewardAmount_gt?: Int;
  rewardAmount_gte?: Int;
  AND?: CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput;
  OR?: CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput;
  NOT?: CupDataProcMdateScalarWhereInput[] | CupDataProcMdateScalarWhereInput;
}

export interface UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userId?: UserCreateOneWithoutUserRecordDataByPeriodInput;
}

export interface CupDataProcMdateUpdateManyWithWhereNestedInput {
  where: CupDataProcMdateScalarWhereInput;
  data: CupDataProcMdateUpdateManyDataInput;
}

export interface UserInterviewQuestionUpdateManyMutationInput {
  question?: String;
}

export interface CupDataProcMdateUpdateManyDataInput {
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rewardAmount?: Int;
}

export interface UserInterviewDatumUpdateManyMutationInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date?: DateTimeInput;
}

export interface UserUpsertWithoutCupDataQaResponseInput {
  update: UserUpdateWithoutCupDataQaResponseDataInput;
  create: UserCreateWithoutCupDataQaResponseInput;
}

export interface UserCupUpdateInput {
  serialNumber?: CupUpdateOneWithoutUserCupsInput;
  userId?: UserUpdateOneWithoutUserCupsInput;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutQuestionIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutQuestionIdDataInput;
  create: CupDataQaResponseCreateWithoutQuestionIdInput;
}

export interface UserUpsertWithoutUserCoinHistoryInput {
  update: UserUpdateWithoutUserCoinHistoryDataInput;
  create: UserCreateWithoutUserCoinHistoryInput;
}

export interface CupDataQaResponseScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  qaDate?: DateTimeInput;
  qaDate_not?: DateTimeInput;
  qaDate_in?: DateTimeInput[] | DateTimeInput;
  qaDate_not_in?: DateTimeInput[] | DateTimeInput;
  qaDate_lt?: DateTimeInput;
  qaDate_lte?: DateTimeInput;
  qaDate_gt?: DateTimeInput;
  qaDate_gte?: DateTimeInput;
  AND?: CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput;
  OR?: CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput;
  NOT?: CupDataQaResponseScalarWhereInput[] | CupDataQaResponseScalarWhereInput;
}

export interface UserCoinHistoryUpdateInput {
  category?: String;
  coin?: Int;
  contents?: String;
  date?: DateTimeInput;
  txhash?: String;
  userId?: UserUpdateOneWithoutUserCoinHistoryInput;
}

export interface CupDataQaResponseUpdateManyWithWhereNestedInput {
  where: CupDataQaResponseScalarWhereInput;
  data: CupDataQaResponseUpdateManyDataInput;
}

export interface UserCoinHistoryCreateInput {
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeInput;
  txhash: String;
  userId?: UserCreateOneWithoutUserCoinHistoryInput;
}

export interface CupDataQaResponseUpdateManyDataInput {
  qaDate?: DateTimeInput;
}

export interface UserCreateInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface CupDataQuestionUpsertWithoutCupDataAnswerInput {
  update: CupDataQuestionUpdateWithoutCupDataAnswerDataInput;
  create: CupDataQuestionCreateWithoutCupDataAnswerInput;
}

export interface PlatformCompUpdateInput {
  phoneId?: Int;
  platformId?: Int;
  problemHistory?: Boolean;
  softwareId?: Int;
  successHistory?: Boolean;
}

export interface CupDataAnswerUpsertWithoutCupDataQaResponseInput {
  update: CupDataAnswerUpdateWithoutCupDataQaResponseDataInput;
  create: CupDataAnswerCreateWithoutCupDataQaResponseInput;
}

export interface CupUpsertWithWhereUniqueWithoutHwIdInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutHwIdDataInput;
  create: CupCreateWithoutHwIdInput;
}

export interface CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput {
  create?: CupDataQuestionCreateWithoutCupDataQaResponseInput;
  update?: CupDataQuestionUpdateWithoutCupDataQaResponseDataInput;
  upsert?: CupDataQuestionUpsertWithoutCupDataQaResponseInput;
  connect?: CupDataQuestionWhereUniqueInput;
}

export interface CupUpdateWithWhereUniqueWithoutHwIdInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutHwIdDataInput;
}

export interface CupDataQuestionUpdateWithoutCupDataQaResponseDataInput {
  cupDataAnswer?: CupDataAnswerUpdateManyWithoutQuestionIdInput;
  questionText?: String;
}

export interface CupCreateWithoutHwIdInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface CupDataAnswerUpdateManyWithoutQuestionIdInput {
  create?:
    | CupDataAnswerCreateWithoutQuestionIdInput[]
    | CupDataAnswerCreateWithoutQuestionIdInput;
  delete?: CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput;
  connect?: CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput;
  set?: CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput;
  disconnect?: CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput;
  update?:
    | CupDataAnswerUpdateWithWhereUniqueWithoutQuestionIdInput[]
    | CupDataAnswerUpdateWithWhereUniqueWithoutQuestionIdInput;
  upsert?:
    | CupDataAnswerUpsertWithWhereUniqueWithoutQuestionIdInput[]
    | CupDataAnswerUpsertWithWhereUniqueWithoutQuestionIdInput;
  deleteMany?: CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput;
  updateMany?:
    | CupDataAnswerUpdateManyWithWhereNestedInput[]
    | CupDataAnswerUpdateManyWithWhereNestedInput;
}

export interface FirmwareUpdateManyMutationInput {
  fwVersion?: String;
}

export interface CupDataAnswerUpdateWithWhereUniqueWithoutQuestionIdInput {
  where: CupDataAnswerWhereUniqueInput;
  data: CupDataAnswerUpdateWithoutQuestionIdDataInput;
}

export type CupDatumWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataAnswerUpdateWithoutQuestionIdDataInput {
  answerText?: String;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutAnswerIdInput;
}

export type EthnicityWhereUniqueInput = AtLeastOne<{
  id: Int;
  ethnicity?: String;
}>;

export interface CupDataQaResponseUpdateManyWithoutAnswerIdInput {
  create?:
    | CupDataQaResponseCreateWithoutAnswerIdInput[]
    | CupDataQaResponseCreateWithoutAnswerIdInput;
  delete?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  set?: CupDataQaResponseWhereUniqueInput[] | CupDataQaResponseWhereUniqueInput;
  disconnect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
  update?:
    | CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerIdInput[]
    | CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerIdInput;
  upsert?:
    | CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerIdInput[]
    | CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerIdInput;
  deleteMany?:
    | CupDataQaResponseScalarWhereInput[]
    | CupDataQaResponseScalarWhereInput;
  updateMany?:
    | CupDataQaResponseUpdateManyWithWhereNestedInput[]
    | CupDataQaResponseUpdateManyWithWhereNestedInput;
}

export interface UserUpsertWithWhereUniqueWithoutEthnicityIdInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutEthnicityIdDataInput;
  create: UserCreateWithoutEthnicityIdInput;
}

export interface CupDataQaResponseUpdateWithWhereUniqueWithoutAnswerIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  data: CupDataQaResponseUpdateWithoutAnswerIdDataInput;
}

export interface UserUpdateWithWhereUniqueWithoutEthnicityIdInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutEthnicityIdDataInput;
}

export interface CupDataQaResponseUpdateWithoutAnswerIdDataInput {
  qaDate?: DateTimeInput;
  questionId?: CupDataQuestionUpdateOneRequiredWithoutCupDataQaResponseInput;
  userId?: UserUpdateOneRequiredWithoutCupDataQaResponseInput;
}

export interface EthnicityUpdateInput {
  ethnicity?: String;
  users?: UserUpdateManyWithoutEthnicityIdInput;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutAnswerIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutAnswerIdDataInput;
  create: CupDataQaResponseCreateWithoutAnswerIdInput;
}

export interface EthnicityCreateInput {
  ethnicity: String;
  users?: UserCreateManyWithoutEthnicityIdInput;
}

export interface CupDataAnswerUpsertWithWhereUniqueWithoutQuestionIdInput {
  where: CupDataAnswerWhereUniqueInput;
  update: CupDataAnswerUpdateWithoutQuestionIdDataInput;
  create: CupDataAnswerCreateWithoutQuestionIdInput;
}

export interface CupDatumUpdateInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  cupDataColourCalc?: CupDataColourCalcUpdateManyWithoutCupDataRowIdInput;
  cupDataProcVolume?: CupDataProcVolumeUpdateManyWithoutCupDataRowIdInput;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupUpdateOneWithoutCupDataInput;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export interface CupDataAnswerScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerText?: String;
  answerText_not?: String;
  answerText_in?: String[] | String;
  answerText_not_in?: String[] | String;
  answerText_lt?: String;
  answerText_lte?: String;
  answerText_gt?: String;
  answerText_gte?: String;
  answerText_contains?: String;
  answerText_not_contains?: String;
  answerText_starts_with?: String;
  answerText_not_starts_with?: String;
  answerText_ends_with?: String;
  answerText_not_ends_with?: String;
  AND?: CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput;
  OR?: CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput;
  NOT?: CupDataAnswerScalarWhereInput[] | CupDataAnswerScalarWhereInput;
}

export interface CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainIdInput {
  where: CupDataUserRemoveWhereUniqueInput;
  update: CupDataUserRemoveUpdateWithoutExplainIdDataInput;
  create: CupDataUserRemoveCreateWithoutExplainIdInput;
}

export interface CupDataAnswerUpdateManyWithWhereNestedInput {
  where: CupDataAnswerScalarWhereInput;
  data: CupDataAnswerUpdateManyDataInput;
}

export interface CupDataUserRemoveUpdateManyWithoutExplainIdInput {
  create?:
    | CupDataUserRemoveCreateWithoutExplainIdInput[]
    | CupDataUserRemoveCreateWithoutExplainIdInput;
  delete?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  set?: CupDataUserRemoveWhereUniqueInput[] | CupDataUserRemoveWhereUniqueInput;
  disconnect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
  update?:
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainIdInput[]
    | CupDataUserRemoveUpdateWithWhereUniqueWithoutExplainIdInput;
  upsert?:
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainIdInput[]
    | CupDataUserRemoveUpsertWithWhereUniqueWithoutExplainIdInput;
  deleteMany?:
    | CupDataUserRemoveScalarWhereInput[]
    | CupDataUserRemoveScalarWhereInput;
  updateMany?:
    | CupDataUserRemoveUpdateManyWithWhereNestedInput[]
    | CupDataUserRemoveUpdateManyWithWhereNestedInput;
}

export interface CupDataAnswerUpdateManyDataInput {
  answerText?: String;
}

export interface CupDataUserRemoveCreateManyWithoutExplainIdInput {
  create?:
    | CupDataUserRemoveCreateWithoutExplainIdInput[]
    | CupDataUserRemoveCreateWithoutExplainIdInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
}

export interface CupDataQuestionUpsertWithoutCupDataQaResponseInput {
  update: CupDataQuestionUpdateWithoutCupDataQaResponseDataInput;
  create: CupDataQuestionCreateWithoutCupDataQaResponseInput;
}

export interface CupDataUserRemoveUpdateInput {
  changeTime?: DateTimeInput;
  explainId?: CupDataUserRemoveExplainUpdateOneRequiredWithoutCupDataUserRemoveInput;
  serialNumber?: CupUpdateOneRequiredWithoutCupDataUserRemoveInput;
  userId?: UserUpdateOneRequiredWithoutCupDataUserRemoveInput;
}

export interface CupDataQaResponseUpsertWithWhereUniqueWithoutUserIdInput {
  where: CupDataQaResponseWhereUniqueInput;
  update: CupDataQaResponseUpdateWithoutUserIdDataInput;
  create: CupDataQaResponseCreateWithoutUserIdInput;
}

export interface CupDataProcMdateUpsertWithWhereUniqueWithoutRejectIdInput {
  where: CupDataProcMdateWhereUniqueInput;
  update: CupDataProcMdateUpdateWithoutRejectIdDataInput;
  create: CupDataProcMdateCreateWithoutRejectIdInput;
}

export interface UserUpsertWithoutCupDataProcMdatesInput {
  update: UserUpdateWithoutCupDataProcMdatesDataInput;
  create: UserCreateWithoutCupDataProcMdatesInput;
}

export interface CupDataProcMdateUpdateManyWithoutRejectIdInput {
  create?:
    | CupDataProcMdateCreateWithoutRejectIdInput[]
    | CupDataProcMdateCreateWithoutRejectIdInput;
  delete?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  connect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  set?: CupDataProcMdateWhereUniqueInput[] | CupDataProcMdateWhereUniqueInput;
  disconnect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
  update?:
    | CupDataProcMdateUpdateWithWhereUniqueWithoutRejectIdInput[]
    | CupDataProcMdateUpdateWithWhereUniqueWithoutRejectIdInput;
  upsert?:
    | CupDataProcMdateUpsertWithWhereUniqueWithoutRejectIdInput[]
    | CupDataProcMdateUpsertWithWhereUniqueWithoutRejectIdInput;
  deleteMany?:
    | CupDataProcMdateScalarWhereInput[]
    | CupDataProcMdateScalarWhereInput;
  updateMany?:
    | CupDataProcMdateUpdateManyWithWhereNestedInput[]
    | CupDataProcMdateUpdateManyWithWhereNestedInput;
}

export interface CupDataProcMdateUpsertWithoutCupDataProcFlowInput {
  update: CupDataProcMdateUpdateWithoutCupDataProcFlowDataInput;
  create: CupDataProcMdateCreateWithoutCupDataProcFlowInput;
}

export interface CupDataProcMdateCreateManyWithoutRejectIdInput {
  create?:
    | CupDataProcMdateCreateWithoutRejectIdInput[]
    | CupDataProcMdateCreateWithoutRejectIdInput;
  connect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
}

export interface CupDataProcFlowUpsertWithWhereUniqueWithoutUserIdInput {
  where: CupDataProcFlowWhereUniqueInput;
  update: CupDataProcFlowUpdateWithoutUserIdDataInput;
  create: CupDataProcFlowCreateWithoutUserIdInput;
}

export interface CupUpsertWithoutCupDataRawInput {
  update: CupUpdateWithoutCupDataRawDataInput;
  create: CupCreateWithoutCupDataRawInput;
}

export interface UserUpsertWithoutUserInterviewDataInput {
  update: UserUpdateWithoutUserInterviewDataDataInput;
  create: UserCreateWithoutUserInterviewDataInput;
}

export interface UsersDataAnalysisWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  userId?: String;
  userId_not?: String;
  userId_in?: String[] | String;
  userId_not_in?: String[] | String;
  userId_lt?: String;
  userId_lte?: String;
  userId_gt?: String;
  userId_gte?: String;
  userId_contains?: String;
  userId_not_contains?: String;
  userId_starts_with?: String;
  userId_not_starts_with?: String;
  userId_ends_with?: String;
  userId_not_ends_with?: String;
  AND?: UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput;
  OR?: UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput;
  NOT?: UsersDataAnalysisWhereInput[] | UsersDataAnalysisWhereInput;
}

export interface UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionIdInput {
  where: UserInterviewDatumWhereUniqueInput;
  update: UserInterviewDatumUpdateWithoutQuestionIdDataInput;
  create: UserInterviewDatumCreateWithoutQuestionIdInput;
}

export interface CupDataRawCreateInput {
  pageData: String;
  serialNumber?: CupCreateOneWithoutCupDataRawInput;
}

export interface UserInterviewQuestionUpsertWithWhereUniqueWithoutAnswerTypeIdInput {
  where: UserInterviewQuestionWhereUniqueInput;
  update: UserInterviewQuestionUpdateWithoutAnswerTypeIdDataInput;
  create: UserInterviewQuestionCreateWithoutAnswerTypeIdInput;
}

export interface UserInterviewQuestionCreateManyWithoutAnswerTypeIdInput {
  create?:
    | UserInterviewQuestionCreateWithoutAnswerTypeIdInput[]
    | UserInterviewQuestionCreateWithoutAnswerTypeIdInput;
  connect?:
    | UserInterviewQuestionWhereUniqueInput[]
    | UserInterviewQuestionWhereUniqueInput;
}

export interface UserInterviewQuestionScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  AND?:
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput;
  OR?:
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput;
  NOT?:
    | UserInterviewQuestionScalarWhereInput[]
    | UserInterviewQuestionScalarWhereInput;
}

export interface UserCreateOneWithoutUserInterviewDataInput {
  create?: UserCreateWithoutUserInterviewDataInput;
  connect?: UserWhereUniqueInput;
}

export interface UserInterviewQuestionUpdateManyWithWhereNestedInput {
  where: UserInterviewQuestionScalarWhereInput;
  data: UserInterviewQuestionUpdateManyDataInput;
}

export interface CountryCreateOneWithoutUsersInput {
  create?: CountryCreateWithoutUsersInput;
  connect?: CountryWhereUniqueInput;
}

export interface UserInterviewQuestionUpdateManyDataInput {
  question?: String;
}

export interface CupDataProcMdateCreateOneWithoutCupDataProcFlowInput {
  create?: CupDataProcMdateCreateWithoutCupDataProcFlowInput;
  connect?: CupDataProcMdateWhereUniqueInput;
}

export interface AnswerTypeUpdateManyMutationInput {
  answerType?: String;
}

export interface CupDataRejectionCreateOneWithoutCupDataProcMdatesInput {
  create?: CupDataRejectionCreateWithoutCupDataProcMdatesInput;
  connect?: CupDataRejectionWhereUniqueInput;
}

export interface CupDataQuestionCreateInput {
  cupDataAnswer?: CupDataAnswerCreateManyWithoutQuestionIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutQuestionIdInput;
  questionText: String;
}

export interface CupDataQaResponseCreateManyWithoutUserIdInput {
  create?:
    | CupDataQaResponseCreateWithoutUserIdInput[]
    | CupDataQaResponseCreateWithoutUserIdInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
}

export interface CupDataQaResponseUpdateManyMutationInput {
  qaDate?: DateTimeInput;
}

export interface CupDataQuestionCreateOneWithoutCupDataAnswerInput {
  create?: CupDataQuestionCreateWithoutCupDataAnswerInput;
  connect?: CupDataQuestionWhereUniqueInput;
}

export interface AppServerSyncCreateInput {
  serverSynchTime: DateTimeInput;
  userId: UserCreateOneWithoutAppServerSyncInput;
}

export interface UserCreateOneWithoutCupDataQaResponseInput {
  create?: UserCreateWithoutCupDataQaResponseInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutAppServerSyncInput {
  create?: UserCreateWithoutAppServerSyncInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataProcFlowCreateManyWithoutMdateRowIdInput {
  create?:
    | CupDataProcFlowCreateWithoutMdateRowIdInput[]
    | CupDataProcFlowCreateWithoutMdateRowIdInput;
  connect?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
}

export interface UserCreateWithoutAppServerSyncInput {
  anonUserId?: Int;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface CupDataUserRemoveCreateManyWithoutUserIdInput {
  create?:
    | CupDataUserRemoveCreateWithoutUserIdInput[]
    | CupDataUserRemoveCreateWithoutUserIdInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
}

export interface AppServerSyncUpdateInput {
  serverSynchTime?: DateTimeInput;
  userId?: UserUpdateOneRequiredWithoutAppServerSyncInput;
}

export interface CupCreateOneWithoutCupDataUserRemoveInput {
  create?: CupCreateWithoutCupDataUserRemoveInput;
  connect?: CupWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutAppServerSyncInput {
  create?: UserCreateWithoutAppServerSyncInput;
  update?: UserUpdateWithoutAppServerSyncDataInput;
  upsert?: UserUpsertWithoutAppServerSyncInput;
  connect?: UserWhereUniqueInput;
}

export interface CompanyCreateOneWithoutCupInput {
  create?: CompanyCreateWithoutCupInput;
  connect?: CompanyWhereUniqueInput;
}

export interface UserUpdateWithoutAppServerSyncDataInput {
  anonUserId?: Int;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupDatumCreateManyWithoutSerialNumberInput {
  create?:
    | CupDatumCreateWithoutSerialNumberInput[]
    | CupDatumCreateWithoutSerialNumberInput;
  connect?: CupDatumWhereUniqueInput[] | CupDatumWhereUniqueInput;
}

export interface UserUpsertWithoutAppServerSyncInput {
  update: UserUpdateWithoutAppServerSyncDataInput;
  create: UserCreateWithoutAppServerSyncInput;
}

export interface CupDataProcVolumeCreateManyWithoutCupDataRowIdInput {
  create?:
    | CupDataProcVolumeCreateWithoutCupDataRowIdInput[]
    | CupDataProcVolumeCreateWithoutCupDataRowIdInput;
  connect?:
    | CupDataProcVolumeWhereUniqueInput[]
    | CupDataProcVolumeWhereUniqueInput;
}

export interface AppServerSyncUpdateManyMutationInput {
  serverSynchTime?: DateTimeInput;
}

export interface CupDataRawCreateManyWithoutSerialNumberInput {
  create?:
    | CupDataRawCreateWithoutSerialNumberInput[]
    | CupDataRawCreateWithoutSerialNumberInput;
  connect?: CupDataRawWhereUniqueInput[] | CupDataRawWhereUniqueInput;
}

export interface CalibrationCreateInput {
  calibVersion: String;
  cup?: CupCreateManyWithoutCalibIdInput;
}

export interface HardwareCreateOneWithoutCupInput {
  create?: HardwareCreateWithoutCupInput;
  connect?: HardwareWhereUniqueInput;
}

export interface CupCreateManyWithoutCalibIdInput {
  create?: CupCreateWithoutCalibIdInput[] | CupCreateWithoutCalibIdInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
}

export interface UserCreateOneWithoutUserCupsInput {
  create?: UserCreateWithoutUserCupsInput;
  connect?: UserWhereUniqueInput;
}

export interface CupCreateWithoutCalibIdInput {
  anonSerialNumber: Int;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface UserCoinHistoryCreateManyWithoutUserIdInput {
  create?:
    | UserCoinHistoryCreateWithoutUserIdInput[]
    | UserCoinHistoryCreateWithoutUserIdInput;
  connect?: UserCoinHistoryWhereUniqueInput[] | UserCoinHistoryWhereUniqueInput;
}

export interface CalibrationUpdateInput {
  calibVersion?: String;
  cup?: CupUpdateManyWithoutCalibIdInput;
}

export interface UserInterviewQuestionCreateOneWithoutUserInterviewDataInput {
  create?: UserInterviewQuestionCreateWithoutUserInterviewDataInput;
  connect?: UserInterviewQuestionWhereUniqueInput;
}

export interface CupUpdateManyWithoutCalibIdInput {
  create?: CupCreateWithoutCalibIdInput[] | CupCreateWithoutCalibIdInput;
  delete?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  set?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  disconnect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  update?:
    | CupUpdateWithWhereUniqueWithoutCalibIdInput[]
    | CupUpdateWithWhereUniqueWithoutCalibIdInput;
  upsert?:
    | CupUpsertWithWhereUniqueWithoutCalibIdInput[]
    | CupUpsertWithWhereUniqueWithoutCalibIdInput;
  deleteMany?: CupScalarWhereInput[] | CupScalarWhereInput;
  updateMany?:
    | CupUpdateManyWithWhereNestedInput[]
    | CupUpdateManyWithWhereNestedInput;
}

export interface UserRecordDataByPeriodCreateManyWithoutUserIdInput {
  create?:
    | UserRecordDataByPeriodCreateWithoutUserIdInput[]
    | UserRecordDataByPeriodCreateWithoutUserIdInput;
  connect?:
    | UserRecordDataByPeriodWhereUniqueInput[]
    | UserRecordDataByPeriodWhereUniqueInput;
}

export interface CupUpdateWithWhereUniqueWithoutCalibIdInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutCalibIdDataInput;
}

export interface UserRecordDataByTimeCreateManyWithoutRecordDayRowIdInput {
  create?:
    | UserRecordDataByTimeCreateWithoutRecordDayRowIdInput[]
    | UserRecordDataByTimeCreateWithoutRecordDayRowIdInput;
  connect?:
    | UserRecordDataByTimeWhereUniqueInput[]
    | UserRecordDataByTimeWhereUniqueInput;
}

export interface CupUpdateWithoutCalibIdDataInput {
  anonSerialNumber?: Int;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface CupCreateOneWithoutUserCupsInput {
  create?: CupCreateWithoutUserCupsInput;
  connect?: CupWhereUniqueInput;
}

export interface CupUpsertWithWhereUniqueWithoutCalibIdInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutCalibIdDataInput;
  create: CupCreateWithoutCalibIdInput;
}

export interface UserCreateOneWithoutCupDataUserRemoveInput {
  create?: UserCreateWithoutCupDataUserRemoveInput;
  connect?: UserWhereUniqueInput;
}

export interface CupScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  anonSerialNumber?: Int;
  anonSerialNumber_not?: Int;
  anonSerialNumber_in?: Int[] | Int;
  anonSerialNumber_not_in?: Int[] | Int;
  anonSerialNumber_lt?: Int;
  anonSerialNumber_lte?: Int;
  anonSerialNumber_gt?: Int;
  anonSerialNumber_gte?: Int;
  encryptionKey?: Int;
  encryptionKey_not?: Int;
  encryptionKey_in?: Int[] | Int;
  encryptionKey_not_in?: Int[] | Int;
  encryptionKey_lt?: Int;
  encryptionKey_lte?: Int;
  encryptionKey_gt?: Int;
  encryptionKey_gte?: Int;
  AND?: CupScalarWhereInput[] | CupScalarWhereInput;
  OR?: CupScalarWhereInput[] | CupScalarWhereInput;
  NOT?: CupScalarWhereInput[] | CupScalarWhereInput;
}

export interface CupDataAnswerCreateManyWithoutQuestionIdInput {
  create?:
    | CupDataAnswerCreateWithoutQuestionIdInput[]
    | CupDataAnswerCreateWithoutQuestionIdInput;
  connect?: CupDataAnswerWhereUniqueInput[] | CupDataAnswerWhereUniqueInput;
}

export interface CupUpdateManyWithWhereNestedInput {
  where: CupScalarWhereInput;
  data: CupUpdateManyDataInput;
}

export interface AnswerTypeUpdateInput {
  answerType?: String;
  userInterviewQuestions?: UserInterviewQuestionUpdateManyWithoutAnswerTypeIdInput;
}

export interface CupUpdateManyDataInput {
  anonSerialNumber?: Int;
  encryptionKey?: Int;
}

export interface UserInterviewDatumUpdateManyWithoutQuestionIdInput {
  create?:
    | UserInterviewDatumCreateWithoutQuestionIdInput[]
    | UserInterviewDatumCreateWithoutQuestionIdInput;
  delete?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  connect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  set?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  disconnect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
  update?:
    | UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionIdInput[]
    | UserInterviewDatumUpdateWithWhereUniqueWithoutQuestionIdInput;
  upsert?:
    | UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionIdInput[]
    | UserInterviewDatumUpsertWithWhereUniqueWithoutQuestionIdInput;
  deleteMany?:
    | UserInterviewDatumScalarWhereInput[]
    | UserInterviewDatumScalarWhereInput;
  updateMany?:
    | UserInterviewDatumUpdateManyWithWhereNestedInput[]
    | UserInterviewDatumUpdateManyWithWhereNestedInput;
}

export interface CalibrationUpdateManyMutationInput {
  calibVersion?: String;
}

export interface UserUpdateWithoutUserInterviewDataDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CompanyCreateInput {
  companyName: String;
  cup?: CupCreateManyWithoutCompanyIdInput;
}

export interface UserRecordDataByPeriodWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  coinHistoryRowId?: Int;
  coinHistoryRowId_not?: Int;
  coinHistoryRowId_in?: Int[] | Int;
  coinHistoryRowId_not_in?: Int[] | Int;
  coinHistoryRowId_lt?: Int;
  coinHistoryRowId_lte?: Int;
  coinHistoryRowId_gt?: Int;
  coinHistoryRowId_gte?: Int;
  isTakePill?: Boolean;
  isTakePill_not?: Boolean;
  mensFinish?: DateTimeInput;
  mensFinish_not?: DateTimeInput;
  mensFinish_in?: DateTimeInput[] | DateTimeInput;
  mensFinish_not_in?: DateTimeInput[] | DateTimeInput;
  mensFinish_lt?: DateTimeInput;
  mensFinish_lte?: DateTimeInput;
  mensFinish_gt?: DateTimeInput;
  mensFinish_gte?: DateTimeInput;
  mensStart?: DateTimeInput;
  mensStart_not?: DateTimeInput;
  mensStart_in?: DateTimeInput[] | DateTimeInput;
  mensStart_not_in?: DateTimeInput[] | DateTimeInput;
  mensStart_lt?: DateTimeInput;
  mensStart_lte?: DateTimeInput;
  mensStart_gt?: DateTimeInput;
  mensStart_gte?: DateTimeInput;
  userId?: UserWhereInput;
  userRecordDataByDay_every?: UserRecordDataByDayWhereInput;
  userRecordDataByDay_some?: UserRecordDataByDayWhereInput;
  userRecordDataByDay_none?: UserRecordDataByDayWhereInput;
  AND?: UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput;
  OR?: UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput;
  NOT?: UserRecordDataByPeriodWhereInput[] | UserRecordDataByPeriodWhereInput;
}

export interface CupCreateManyWithoutCompanyIdInput {
  create?: CupCreateWithoutCompanyIdInput[] | CupCreateWithoutCompanyIdInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
}

export interface UserCoinHistorySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserCoinHistoryWhereInput;
  AND?:
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput;
  OR?:
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput;
  NOT?:
    | UserCoinHistorySubscriptionWhereInput[]
    | UserCoinHistorySubscriptionWhereInput;
}

export interface CupCreateWithoutCompanyIdInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface CupDataColourCalibWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  blue?: Int;
  blue_not?: Int;
  blue_in?: Int[] | Int;
  blue_not_in?: Int[] | Int;
  blue_lt?: Int;
  blue_lte?: Int;
  blue_gt?: Int;
  blue_gte?: Int;
  c?: Int;
  c_not?: Int;
  c_in?: Int[] | Int;
  c_not_in?: Int[] | Int;
  c_lt?: Int;
  c_lte?: Int;
  c_gt?: Int;
  c_gte?: Int;
  green?: Int;
  green_not?: Int;
  green_in?: Int[] | Int;
  green_not_in?: Int[] | Int;
  green_lt?: Int;
  green_lte?: Int;
  green_gt?: Int;
  green_gte?: Int;
  red?: Int;
  red_not?: Int;
  red_in?: Int[] | Int;
  red_not_in?: Int[] | Int;
  red_lt?: Int;
  red_lte?: Int;
  red_gt?: Int;
  red_gte?: Int;
  serialNumber?: CupWhereInput;
  AND?: CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput;
  OR?: CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput;
  NOT?: CupDataColourCalibWhereInput[] | CupDataColourCalibWhereInput;
}

export interface CompanyUpdateInput {
  companyName?: String;
  cup?: CupUpdateManyWithoutCompanyIdInput;
}

export interface CupDataRawSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataRawWhereInput;
  AND?: CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput;
  OR?: CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput;
  NOT?: CupDataRawSubscriptionWhereInput[] | CupDataRawSubscriptionWhereInput;
}

export interface CupUpdateManyWithoutCompanyIdInput {
  create?: CupCreateWithoutCompanyIdInput[] | CupCreateWithoutCompanyIdInput;
  delete?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  connect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  set?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  disconnect?: CupWhereUniqueInput[] | CupWhereUniqueInput;
  update?:
    | CupUpdateWithWhereUniqueWithoutCompanyIdInput[]
    | CupUpdateWithWhereUniqueWithoutCompanyIdInput;
  upsert?:
    | CupUpsertWithWhereUniqueWithoutCompanyIdInput[]
    | CupUpsertWithWhereUniqueWithoutCompanyIdInput;
  deleteMany?: CupScalarWhereInput[] | CupScalarWhereInput;
  updateMany?:
    | CupUpdateManyWithWhereNestedInput[]
    | CupUpdateManyWithWhereNestedInput;
}

export interface CupDataProcMdateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataProcMdateWhereInput;
  AND?:
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput;
  OR?:
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput;
  NOT?:
    | CupDataProcMdateSubscriptionWhereInput[]
    | CupDataProcMdateSubscriptionWhereInput;
}

export interface CupUpdateWithWhereUniqueWithoutCompanyIdInput {
  where: CupWhereUniqueInput;
  data: CupUpdateWithoutCompanyIdDataInput;
}

export interface CupDataUserRemoveWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  changeTime?: DateTimeInput;
  changeTime_not?: DateTimeInput;
  changeTime_in?: DateTimeInput[] | DateTimeInput;
  changeTime_not_in?: DateTimeInput[] | DateTimeInput;
  changeTime_lt?: DateTimeInput;
  changeTime_lte?: DateTimeInput;
  changeTime_gt?: DateTimeInput;
  changeTime_gte?: DateTimeInput;
  explainId?: CupDataUserRemoveExplainWhereInput;
  serialNumber?: CupWhereInput;
  userId?: UserWhereInput;
  AND?: CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput;
  OR?: CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput;
  NOT?: CupDataUserRemoveWhereInput[] | CupDataUserRemoveWhereInput;
}

export interface CupUpdateWithoutCompanyIdDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface CupDataRejectionWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  cupDataProcMdates_every?: CupDataProcMdateWhereInput;
  cupDataProcMdates_some?: CupDataProcMdateWhereInput;
  cupDataProcMdates_none?: CupDataProcMdateWhereInput;
  rejectionDescription?: String;
  rejectionDescription_not?: String;
  rejectionDescription_in?: String[] | String;
  rejectionDescription_not_in?: String[] | String;
  rejectionDescription_lt?: String;
  rejectionDescription_lte?: String;
  rejectionDescription_gt?: String;
  rejectionDescription_gte?: String;
  rejectionDescription_contains?: String;
  rejectionDescription_not_contains?: String;
  rejectionDescription_starts_with?: String;
  rejectionDescription_not_starts_with?: String;
  rejectionDescription_ends_with?: String;
  rejectionDescription_not_ends_with?: String;
  AND?: CupDataRejectionWhereInput[] | CupDataRejectionWhereInput;
  OR?: CupDataRejectionWhereInput[] | CupDataRejectionWhereInput;
  NOT?: CupDataRejectionWhereInput[] | CupDataRejectionWhereInput;
}

export interface CupUpsertWithWhereUniqueWithoutCompanyIdInput {
  where: CupWhereUniqueInput;
  update: CupUpdateWithoutCompanyIdDataInput;
  create: CupCreateWithoutCompanyIdInput;
}

export interface UsersDataAnalysisCreateInput {
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface CompanyUpdateManyMutationInput {
  companyName?: String;
}

export type CalibrationWhereUniqueInput = AtLeastOne<{
  id: Int;
  calibVersion?: String;
}>;

export interface CountryCreateInput {
  countryName: String;
  users?: UserCreateManyWithoutCountryIdInput;
}

export interface UserRecordDataByPeriodUpdateManyMutationInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
}

export interface UserCreateManyWithoutCountryIdInput {
  create?: UserCreateWithoutCountryIdInput[] | UserCreateWithoutCountryIdInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpsertWithoutUserRecordDataByPeriodInput {
  update: UserUpdateWithoutUserRecordDataByPeriodDataInput;
  create: UserCreateWithoutUserRecordDataByPeriodInput;
}

export interface UserCreateWithoutCountryIdInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserCreateWithoutUserRecordDataByPeriodInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCoinHistory?: UserCoinHistoryCreateManyWithoutUserIdInput;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
}

export interface CountryUpdateInput {
  countryName?: String;
  users?: UserUpdateManyWithoutCountryIdInput;
}

export interface UserInterviewQuestionUpdateInput {
  answerTypeId?: AnswerTypeUpdateOneRequiredWithoutUserInterviewQuestionsInput;
  question?: String;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutQuestionIdInput;
}

export interface UserUpdateManyWithoutCountryIdInput {
  create?: UserCreateWithoutCountryIdInput[] | UserCreateWithoutCountryIdInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutCountryIdInput[]
    | UserUpdateWithWhereUniqueWithoutCountryIdInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutCountryIdInput[]
    | UserUpsertWithWhereUniqueWithoutCountryIdInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserCupCreateInput {
  serialNumber?: CupCreateOneWithoutUserCupsInput;
  userId?: UserCreateOneWithoutUserCupsInput;
}

export interface UserUpdateWithWhereUniqueWithoutCountryIdInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCountryIdDataInput;
}

export interface UserCreateWithoutUserCoinHistoryInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncCreateManyWithoutUserIdInput;
  countryId?: CountryCreateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateCreateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob: DateTimeInput;
  email: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityCreateOneWithoutUsersInput;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
  userCups?: UserCupCreateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumCreateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodCreateManyWithoutUserIdInput;
}

export interface UserUpdateWithoutCountryIdDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCoinHistory?: UserCoinHistoryUpdateManyWithoutUserIdInput;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface AppServerSyncWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  serverSynchTime?: DateTimeInput;
  serverSynchTime_not?: DateTimeInput;
  serverSynchTime_in?: DateTimeInput[] | DateTimeInput;
  serverSynchTime_not_in?: DateTimeInput[] | DateTimeInput;
  serverSynchTime_lt?: DateTimeInput;
  serverSynchTime_lte?: DateTimeInput;
  serverSynchTime_gt?: DateTimeInput;
  serverSynchTime_gte?: DateTimeInput;
  userId?: UserWhereInput;
  AND?: AppServerSyncWhereInput[] | AppServerSyncWhereInput;
  OR?: AppServerSyncWhereInput[] | AppServerSyncWhereInput;
  NOT?: AppServerSyncWhereInput[] | AppServerSyncWhereInput;
}

export interface UserUpsertWithWhereUniqueWithoutCountryIdInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCountryIdDataInput;
  create: UserCreateWithoutCountryIdInput;
}

export type CupDataRejectionWhereUniqueInput = AtLeastOne<{
  id: Int;
  rejectionDescription?: String;
}>;

export interface UserScalarWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  anonUserId?: Int;
  anonUserId_not?: Int;
  anonUserId_in?: Int[] | Int;
  anonUserId_not_in?: Int[] | Int;
  anonUserId_lt?: Int;
  anonUserId_lte?: Int;
  anonUserId_gt?: Int;
  anonUserId_gte?: Int;
  deleted?: Boolean;
  deleted_not?: Boolean;
  dob?: DateTimeInput;
  dob_not?: DateTimeInput;
  dob_in?: DateTimeInput[] | DateTimeInput;
  dob_not_in?: DateTimeInput[] | DateTimeInput;
  dob_lt?: DateTimeInput;
  dob_lte?: DateTimeInput;
  dob_gt?: DateTimeInput;
  dob_gte?: DateTimeInput;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  encryptSaltString?: String;
  encryptSaltString_not?: String;
  encryptSaltString_in?: String[] | String;
  encryptSaltString_not_in?: String[] | String;
  encryptSaltString_lt?: String;
  encryptSaltString_lte?: String;
  encryptSaltString_gt?: String;
  encryptSaltString_gte?: String;
  encryptSaltString_contains?: String;
  encryptSaltString_not_contains?: String;
  encryptSaltString_starts_with?: String;
  encryptSaltString_not_starts_with?: String;
  encryptSaltString_ends_with?: String;
  encryptSaltString_not_ends_with?: String;
  firstName?: String;
  firstName_not?: String;
  firstName_in?: String[] | String;
  firstName_not_in?: String[] | String;
  firstName_lt?: String;
  firstName_lte?: String;
  firstName_gt?: String;
  firstName_gte?: String;
  firstName_contains?: String;
  firstName_not_contains?: String;
  firstName_starts_with?: String;
  firstName_not_starts_with?: String;
  firstName_ends_with?: String;
  firstName_not_ends_with?: String;
  givenBirth?: Boolean;
  givenBirth_not?: Boolean;
  lastName?: String;
  lastName_not?: String;
  lastName_in?: String[] | String;
  lastName_not_in?: String[] | String;
  lastName_lt?: String;
  lastName_lte?: String;
  lastName_gt?: String;
  lastName_gte?: String;
  lastName_contains?: String;
  lastName_not_contains?: String;
  lastName_starts_with?: String;
  lastName_not_starts_with?: String;
  lastName_ends_with?: String;
  lastName_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface HardwareCreateInput {
  cup?: CupCreateManyWithoutHwIdInput;
  hwVersion: String;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface FirmwareUpdateInput {
  cup?: CupUpdateManyWithoutFwIdInput;
  fwVersion?: String;
}

export interface UserUpdateManyDataInput {
  anonUserId?: Int;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
}

export interface UserInterviewDatumWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerRange?: Int;
  answerRange_not?: Int;
  answerRange_in?: Int[] | Int;
  answerRange_not_in?: Int[] | Int;
  answerRange_lt?: Int;
  answerRange_lte?: Int;
  answerRange_gt?: Int;
  answerRange_gte?: Int;
  answerText?: String;
  answerText_not?: String;
  answerText_in?: String[] | String;
  answerText_not_in?: String[] | String;
  answerText_lt?: String;
  answerText_lte?: String;
  answerText_gt?: String;
  answerText_gte?: String;
  answerText_contains?: String;
  answerText_not_contains?: String;
  answerText_starts_with?: String;
  answerText_not_starts_with?: String;
  answerText_ends_with?: String;
  answerText_not_ends_with?: String;
  answerYn?: Boolean;
  answerYn_not?: Boolean;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  questionId?: UserInterviewQuestionWhereInput;
  userId?: UserWhereInput;
  AND?: UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput;
  OR?: UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput;
  NOT?: UserInterviewDatumWhereInput[] | UserInterviewDatumWhereInput;
}

export interface CountryUpdateManyMutationInput {
  countryName?: String;
}

export interface UserCreateManyWithoutEthnicityIdInput {
  create?:
    | UserCreateWithoutEthnicityIdInput[]
    | UserCreateWithoutEthnicityIdInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CupCreateInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Int;
  anonUserId?: Int;
  email?: String;
}>;

export interface CupUpdateInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export type UserCupWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupUpdateManyMutationInput {
  anonSerialNumber?: Int;
  encryptionKey?: Int;
}

export type UserInterviewQuestionWhereUniqueInput = AtLeastOne<{
  id: Int;
  question?: String;
}>;

export interface CupAppSyncCreateInput {
  appSynchTime: DateTimeInput;
  serialNumber: CupCreateOneWithoutCupAppSyncInput;
}

export type UserRecordDataByPeriodWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupCreateOneWithoutCupAppSyncInput {
  create?: CupCreateWithoutCupAppSyncInput;
  connect?: CupWhereUniqueInput;
}

export type UsersDataAnalysisWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupCreateWithoutCupAppSyncInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface AppServerSyncCreateManyWithoutUserIdInput {
  create?:
    | AppServerSyncCreateWithoutUserIdInput[]
    | AppServerSyncCreateWithoutUserIdInput;
  connect?: AppServerSyncWhereUniqueInput[] | AppServerSyncWhereUniqueInput;
}

export interface CupAppSyncUpdateInput {
  appSynchTime?: DateTimeInput;
  serialNumber?: CupUpdateOneRequiredWithoutCupAppSyncInput;
}

export interface CupDataManMdateCreateManyWithoutMdateRowIdInput {
  create?:
    | CupDataManMdateCreateWithoutMdateRowIdInput[]
    | CupDataManMdateCreateWithoutMdateRowIdInput;
  connect?: CupDataManMdateWhereUniqueInput[] | CupDataManMdateWhereUniqueInput;
}

export interface CupUpdateOneRequiredWithoutCupAppSyncInput {
  create?: CupCreateWithoutCupAppSyncInput;
  update?: CupUpdateWithoutCupAppSyncDataInput;
  upsert?: CupUpsertWithoutCupAppSyncInput;
  connect?: CupWhereUniqueInput;
}

export interface CupDataAnswerCreateOneWithoutCupDataQaResponseInput {
  create?: CupDataAnswerCreateWithoutCupDataQaResponseInput;
  connect?: CupDataAnswerWhereUniqueInput;
}

export interface CupUpdateWithoutCupAppSyncDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface CupDataProcMdateCreateManyWithoutUserIdInput {
  create?:
    | CupDataProcMdateCreateWithoutUserIdInput[]
    | CupDataProcMdateCreateWithoutUserIdInput;
  connect?:
    | CupDataProcMdateWhereUniqueInput[]
    | CupDataProcMdateWhereUniqueInput;
}

export interface CupUpsertWithoutCupAppSyncInput {
  update: CupUpdateWithoutCupAppSyncDataInput;
  create: CupCreateWithoutCupAppSyncInput;
}

export interface CupDataUserRemoveExplainCreateOneWithoutCupDataUserRemoveInput {
  create?: CupDataUserRemoveExplainCreateWithoutCupDataUserRemoveInput;
  connect?: CupDataUserRemoveExplainWhereUniqueInput;
}

export interface CupAppSyncUpdateManyMutationInput {
  appSynchTime?: DateTimeInput;
}

export interface CupAppSyncCreateManyWithoutSerialNumberInput {
  create?:
    | CupAppSyncCreateWithoutSerialNumberInput[]
    | CupAppSyncCreateWithoutSerialNumberInput;
  connect?: CupAppSyncWhereUniqueInput[] | CupAppSyncWhereUniqueInput;
}

export interface CupDataAnswerCreateInput {
  answerText: String;
  cupDataQaResponse?: CupDataQaResponseCreateManyWithoutAnswerIdInput;
  questionId: CupDataQuestionCreateOneWithoutCupDataAnswerInput;
}

export interface CupDataColourCalibCreateManyWithoutSerialNumberInput {
  create?:
    | CupDataColourCalibCreateWithoutSerialNumberInput[]
    | CupDataColourCalibCreateWithoutSerialNumberInput;
  connect?:
    | CupDataColourCalibWhereUniqueInput[]
    | CupDataColourCalibWhereUniqueInput;
}

export interface CupDataAnswerUpdateInput {
  answerText?: String;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutAnswerIdInput;
  questionId?: CupDataQuestionUpdateOneRequiredWithoutCupDataAnswerInput;
}

export interface UserCupCreateManyWithoutSerialNumberInput {
  create?:
    | UserCupCreateWithoutSerialNumberInput[]
    | UserCupCreateWithoutSerialNumberInput;
  connect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
}

export interface CupDataAnswerUpdateManyMutationInput {
  answerText?: String;
}

export interface UserInterviewDatumCreateManyWithoutUserIdInput {
  create?:
    | UserInterviewDatumCreateWithoutUserIdInput[]
    | UserInterviewDatumCreateWithoutUserIdInput;
  connect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
}

export interface CupDataColourCalcCreateInput {
  blue: Int;
  cupDataRowId: CupDatumCreateOneWithoutCupDataColourCalcInput;
  green: Int;
  red: Int;
}

export interface UserRecordDataByDayCreateManyWithoutRecordPeriodRowIdInput {
  create?:
    | UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput[]
    | UserRecordDataByDayCreateWithoutRecordPeriodRowIdInput;
  connect?:
    | UserRecordDataByDayWhereUniqueInput[]
    | UserRecordDataByDayWhereUniqueInput;
}

export interface CupDatumCreateOneWithoutCupDataColourCalcInput {
  create?: CupDatumCreateWithoutCupDataColourCalcInput;
  connect?: CupDatumWhereUniqueInput;
}

export interface CupDataUserRemoveCreateManyWithoutSerialNumberInput {
  create?:
    | CupDataUserRemoveCreateWithoutSerialNumberInput[]
    | CupDataUserRemoveCreateWithoutSerialNumberInput;
  connect?:
    | CupDataUserRemoveWhereUniqueInput[]
    | CupDataUserRemoveWhereUniqueInput;
}

export interface CupDatumCreateWithoutCupDataColourCalcInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataProcVolume?: CupDataProcVolumeCreateManyWithoutCupDataRowIdInput;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupCreateOneWithoutCupDataInput;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDataQaResponseCreateManyWithoutAnswerIdInput {
  create?:
    | CupDataQaResponseCreateWithoutAnswerIdInput[]
    | CupDataQaResponseCreateWithoutAnswerIdInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
}

export interface CupCreateOneWithoutCupDataInput {
  create?: CupCreateWithoutCupDataInput;
  connect?: CupWhereUniqueInput;
}

export interface UserInterviewDatumUpdateWithoutQuestionIdDataInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date?: DateTimeInput;
  userId?: UserUpdateOneRequiredWithoutUserInterviewDataInput;
}

export interface CupCreateWithoutCupDataInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface EthnicityWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  ethnicity?: String;
  ethnicity_not?: String;
  ethnicity_in?: String[] | String;
  ethnicity_not_in?: String[] | String;
  ethnicity_lt?: String;
  ethnicity_lte?: String;
  ethnicity_gt?: String;
  ethnicity_gte?: String;
  ethnicity_contains?: String;
  ethnicity_not_contains?: String;
  ethnicity_starts_with?: String;
  ethnicity_not_starts_with?: String;
  ethnicity_ends_with?: String;
  ethnicity_not_ends_with?: String;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: EthnicityWhereInput[] | EthnicityWhereInput;
  OR?: EthnicityWhereInput[] | EthnicityWhereInput;
  NOT?: EthnicityWhereInput[] | EthnicityWhereInput;
}

export interface CupDataColourCalcUpdateInput {
  blue?: Int;
  cupDataRowId?: CupDatumUpdateOneRequiredWithoutCupDataColourCalcInput;
  green?: Int;
  red?: Int;
}

export interface CupDataUserRemoveSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataUserRemoveWhereInput;
  AND?:
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput;
  OR?:
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput;
  NOT?:
    | CupDataUserRemoveSubscriptionWhereInput[]
    | CupDataUserRemoveSubscriptionWhereInput;
}

export interface CupDatumUpdateOneRequiredWithoutCupDataColourCalcInput {
  create?: CupDatumCreateWithoutCupDataColourCalcInput;
  update?: CupDatumUpdateWithoutCupDataColourCalcDataInput;
  upsert?: CupDatumUpsertWithoutCupDataColourCalcInput;
  connect?: CupDatumWhereUniqueInput;
}

export interface CupDataColourCalibSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataColourCalibWhereInput;
  AND?:
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput;
  OR?:
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput;
  NOT?:
    | CupDataColourCalibSubscriptionWhereInput[]
    | CupDataColourCalibSubscriptionWhereInput;
}

export interface CupDatumUpdateWithoutCupDataColourCalcDataInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  cupDataProcVolume?: CupDataProcVolumeUpdateManyWithoutCupDataRowIdInput;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupUpdateOneWithoutCupDataInput;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export interface AnswerTypeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AnswerTypeWhereInput;
  AND?: AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput;
  OR?: AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput;
  NOT?: AnswerTypeSubscriptionWhereInput[] | AnswerTypeSubscriptionWhereInput;
}

export interface CupUpdateOneWithoutCupDataInput {
  create?: CupCreateWithoutCupDataInput;
  update?: CupUpdateWithoutCupDataDataInput;
  upsert?: CupUpsertWithoutCupDataInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CupWhereUniqueInput;
}

export interface UserRecordDataByDayCreateOneWithoutUserRecordDataByTimeInput {
  create?: UserRecordDataByDayCreateWithoutUserRecordDataByTimeInput;
  connect?: UserRecordDataByDayWhereUniqueInput;
}

export interface CupUpdateWithoutCupDataDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface UserRecordDataByPeriodUpdateWithoutUserRecordDataByDayDataInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userId?: UserUpdateOneWithoutUserRecordDataByPeriodInput;
}

export interface CupUpsertWithoutCupDataInput {
  update: CupUpdateWithoutCupDataDataInput;
  create: CupCreateWithoutCupDataInput;
}

export interface UserInterviewDatumUpdateInput {
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date?: DateTimeInput;
  questionId?: UserInterviewQuestionUpdateOneRequiredWithoutUserInterviewDataInput;
  userId?: UserUpdateOneRequiredWithoutUserInterviewDataInput;
}

export interface CupDatumUpsertWithoutCupDataColourCalcInput {
  update: CupDatumUpdateWithoutCupDataColourCalcDataInput;
  create: CupDatumCreateWithoutCupDataColourCalcInput;
}

export interface UserUpdateManyMutationInput {
  anonUserId?: Int;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
}

export interface CupDataColourCalcUpdateManyMutationInput {
  blue?: Int;
  green?: Int;
  red?: Int;
}

export interface HardwareUpdateInput {
  cup?: CupUpdateManyWithoutHwIdInput;
  hwVersion?: String;
}

export interface CupDataColourCalibCreateInput {
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
  serialNumber: CupCreateOneWithoutCupDataColourCalibInput;
}

export interface FirmwareCreateInput {
  cup?: CupCreateManyWithoutFwIdInput;
  fwVersion: String;
}

export interface CupCreateOneWithoutCupDataColourCalibInput {
  create?: CupCreateWithoutCupDataColourCalibInput;
  connect?: CupWhereUniqueInput;
}

export interface UserInterviewQuestionWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerTypeId?: AnswerTypeWhereInput;
  question?: String;
  question_not?: String;
  question_in?: String[] | String;
  question_not_in?: String[] | String;
  question_lt?: String;
  question_lte?: String;
  question_gt?: String;
  question_gte?: String;
  question_contains?: String;
  question_not_contains?: String;
  question_starts_with?: String;
  question_not_starts_with?: String;
  question_ends_with?: String;
  question_not_ends_with?: String;
  userInterviewData_every?: UserInterviewDatumWhereInput;
  userInterviewData_some?: UserInterviewDatumWhereInput;
  userInterviewData_none?: UserInterviewDatumWhereInput;
  AND?: UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput;
  OR?: UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput;
  NOT?: UserInterviewQuestionWhereInput[] | UserInterviewQuestionWhereInput;
}

export interface CupCreateWithoutCupDataColourCalibInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export type UserInterviewDatumWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataColourCalibUpdateInput {
  blue?: Int;
  c?: Int;
  green?: Int;
  red?: Int;
  serialNumber?: CupUpdateOneRequiredWithoutCupDataColourCalibInput;
}

export type UserRecordDataByTimeWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupUpdateOneRequiredWithoutCupDataColourCalibInput {
  create?: CupCreateWithoutCupDataColourCalibInput;
  update?: CupUpdateWithoutCupDataColourCalibDataInput;
  upsert?: CupUpsertWithoutCupDataColourCalibInput;
  connect?: CupWhereUniqueInput;
}

export interface UserInterviewDatumCreateManyWithoutQuestionIdInput {
  create?:
    | UserInterviewDatumCreateWithoutQuestionIdInput[]
    | UserInterviewDatumCreateWithoutQuestionIdInput;
  connect?:
    | UserInterviewDatumWhereUniqueInput[]
    | UserInterviewDatumWhereUniqueInput;
}

export interface CupUpdateWithoutCupDataColourCalibDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  fwId?: FirmwareUpdateOneWithoutCupInput;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface UserCreateOneWithoutCupDataProcMdatesInput {
  create?: UserCreateWithoutCupDataProcMdatesInput;
  connect?: UserWhereUniqueInput;
}

export interface CupUpsertWithoutCupDataColourCalibInput {
  update: CupUpdateWithoutCupDataColourCalibDataInput;
  create: CupCreateWithoutCupDataColourCalibInput;
}

export interface UserCreateOneWithoutCupDataProcFlowInput {
  create?: UserCreateWithoutCupDataProcFlowInput;
  connect?: UserWhereUniqueInput;
}

export interface CupDataColourCalibUpdateManyMutationInput {
  blue?: Int;
  c?: Int;
  green?: Int;
  red?: Int;
}

export interface CupDataColourCalcCreateManyWithoutCupDataRowIdInput {
  create?:
    | CupDataColourCalcCreateWithoutCupDataRowIdInput[]
    | CupDataColourCalcCreateWithoutCupDataRowIdInput;
  connect?:
    | CupDataColourCalcWhereUniqueInput[]
    | CupDataColourCalcWhereUniqueInput;
}

export interface CupDataManMdateCreateInput {
  mdateRowId: CupDataProcMdateCreateOneWithoutCupDataManMdatesInput;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface EthnicityCreateOneWithoutUsersInput {
  create?: EthnicityCreateWithoutUsersInput;
  connect?: EthnicityWhereUniqueInput;
}

export interface CupDataProcMdateCreateOneWithoutCupDataManMdatesInput {
  create?: CupDataProcMdateCreateWithoutCupDataManMdatesInput;
  connect?: CupDataProcMdateWhereUniqueInput;
}

export interface UserCupCreateManyWithoutUserIdInput {
  create?: UserCupCreateWithoutUserIdInput[] | UserCupCreateWithoutUserIdInput;
  connect?: UserCupWhereUniqueInput[] | UserCupWhereUniqueInput;
}

export interface CupDataProcMdateCreateWithoutCupDataManMdatesInput {
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rejectId?: CupDataRejectionCreateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface UserInterviewQuestionUpdateWithWhereUniqueWithoutAnswerTypeIdInput {
  where: UserInterviewQuestionWhereUniqueInput;
  data: UserInterviewQuestionUpdateWithoutAnswerTypeIdDataInput;
}

export interface CupDataManMdateUpdateInput {
  mdateRowId?: CupDataProcMdateUpdateOneRequiredWithoutCupDataManMdatesInput;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface PlatformCompSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PlatformCompWhereInput;
  AND?:
    | PlatformCompSubscriptionWhereInput[]
    | PlatformCompSubscriptionWhereInput;
  OR?:
    | PlatformCompSubscriptionWhereInput[]
    | PlatformCompSubscriptionWhereInput;
  NOT?:
    | PlatformCompSubscriptionWhereInput[]
    | PlatformCompSubscriptionWhereInput;
}

export interface CupDataProcMdateUpdateOneRequiredWithoutCupDataManMdatesInput {
  create?: CupDataProcMdateCreateWithoutCupDataManMdatesInput;
  update?: CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput;
  upsert?: CupDataProcMdateUpsertWithoutCupDataManMdatesInput;
  connect?: CupDataProcMdateWhereUniqueInput;
}

export interface CupDataAnswerWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  answerText?: String;
  answerText_not?: String;
  answerText_in?: String[] | String;
  answerText_not_in?: String[] | String;
  answerText_lt?: String;
  answerText_lte?: String;
  answerText_gt?: String;
  answerText_gte?: String;
  answerText_contains?: String;
  answerText_not_contains?: String;
  answerText_starts_with?: String;
  answerText_not_starts_with?: String;
  answerText_ends_with?: String;
  answerText_not_ends_with?: String;
  cupDataQaResponse_every?: CupDataQaResponseWhereInput;
  cupDataQaResponse_some?: CupDataQaResponseWhereInput;
  cupDataQaResponse_none?: CupDataQaResponseWhereInput;
  questionId?: CupDataQuestionWhereInput;
  AND?: CupDataAnswerWhereInput[] | CupDataAnswerWhereInput;
  OR?: CupDataAnswerWhereInput[] | CupDataAnswerWhereInput;
  NOT?: CupDataAnswerWhereInput[] | CupDataAnswerWhereInput;
}

export interface CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput {
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rejectId?: CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId?: UserUpdateOneRequiredWithoutCupDataProcMdatesInput;
}

export interface UserRecordDataByPeriodCreateInput {
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeInput;
  mensStart?: DateTimeInput;
  userId?: UserCreateOneWithoutUserRecordDataByPeriodInput;
  userRecordDataByDay?: UserRecordDataByDayCreateManyWithoutRecordPeriodRowIdInput;
}

export interface CupDataProcMdateUpsertWithoutCupDataManMdatesInput {
  update: CupDataProcMdateUpdateWithoutCupDataManMdatesDataInput;
  create: CupDataProcMdateCreateWithoutCupDataManMdatesInput;
}

export interface UserUpdateWithoutUserCoinHistoryDataInput {
  anonUserId?: Int;
  appServerSync?: AppServerSyncUpdateManyWithoutUserIdInput;
  countryId?: CountryUpdateOneWithoutUsersInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutUserIdInput;
  cupDataProcMdates?: CupDataProcMdateUpdateManyWithoutUserIdInput;
  cupDataQaResponse?: CupDataQaResponseUpdateManyWithoutUserIdInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutUserIdInput;
  deleted?: Boolean;
  dob?: DateTimeInput;
  email?: String;
  encryptSaltString?: String;
  ethnicityId?: EthnicityUpdateOneWithoutUsersInput;
  firstName?: String;
  givenBirth?: Boolean;
  lastName?: String;
  password?: String;
  userCups?: UserCupUpdateManyWithoutUserIdInput;
  userInterviewData?: UserInterviewDatumUpdateManyWithoutUserIdInput;
  userRecordDataByPeriod?: UserRecordDataByPeriodUpdateManyWithoutUserIdInput;
}

export interface CupDataManMdateUpdateManyMutationInput {
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
}

export interface CupUpdateWithoutFwIdDataInput {
  anonSerialNumber?: Int;
  calibId?: CalibrationUpdateOneWithoutCupInput;
  companyId?: CompanyUpdateOneWithoutCupInput;
  cupAppSync?: CupAppSyncUpdateManyWithoutSerialNumberInput;
  cupData?: CupDatumUpdateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibUpdateManyWithoutSerialNumberInput;
  cupDataRaw?: CupDataRawUpdateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveUpdateManyWithoutSerialNumberInput;
  encryptionKey?: Int;
  hwId?: HardwareUpdateOneWithoutCupInput;
  userCups?: UserCupUpdateManyWithoutSerialNumberInput;
}

export interface CupDataProcFlowCreateInput {
  date: DateTimeInput;
  hourlyFlow: Int;
  mdateRowId: CupDataProcMdateCreateOneWithoutCupDataProcFlowInput;
  userId: UserCreateOneWithoutCupDataProcFlowInput;
}

export type UserCoinHistoryWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface CupDataProcFlowUpdateInput {
  date?: DateTimeInput;
  hourlyFlow?: Int;
  mdateRowId?: CupDataProcMdateUpdateOneRequiredWithoutCupDataProcFlowInput;
  userId?: UserUpdateOneRequiredWithoutCupDataProcFlowInput;
}

export interface CupCreateWithoutCupDataRawInput {
  anonSerialNumber: Int;
  calibId?: CalibrationCreateOneWithoutCupInput;
  companyId?: CompanyCreateOneWithoutCupInput;
  cupAppSync?: CupAppSyncCreateManyWithoutSerialNumberInput;
  cupData?: CupDatumCreateManyWithoutSerialNumberInput;
  cupDataColourCalib?: CupDataColourCalibCreateManyWithoutSerialNumberInput;
  cupDataUserRemove?: CupDataUserRemoveCreateManyWithoutSerialNumberInput;
  encryptionKey: Int;
  fwId?: FirmwareCreateOneWithoutCupInput;
  hwId?: HardwareCreateOneWithoutCupInput;
  userCups?: UserCupCreateManyWithoutSerialNumberInput;
}

export interface CupDataProcFlowUpdateManyMutationInput {
  date?: DateTimeInput;
  hourlyFlow?: Int;
}

export interface CupDataQaResponseCreateManyWithoutQuestionIdInput {
  create?:
    | CupDataQaResponseCreateWithoutQuestionIdInput[]
    | CupDataQaResponseCreateWithoutQuestionIdInput;
  connect?:
    | CupDataQaResponseWhereUniqueInput[]
    | CupDataQaResponseWhereUniqueInput;
}

export interface CupDataProcMdateCreateInput {
  cupDataManMdates?: CupDataManMdateCreateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowCreateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeInput;
  menStart: DateTimeInput;
  rejectId?: CupDataRejectionCreateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId: UserCreateOneWithoutCupDataProcMdatesInput;
}

export interface FirmwareCreateOneWithoutCupInput {
  create?: FirmwareCreateWithoutCupInput;
  connect?: FirmwareWhereUniqueInput;
}

export interface CupDataProcMdateUpdateInput {
  cupDataManMdates?: CupDataManMdateUpdateManyWithoutMdateRowIdInput;
  cupDataProcFlow?: CupDataProcFlowUpdateManyWithoutMdateRowIdInput;
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rejectId?: CupDataRejectionUpdateOneWithoutCupDataProcMdatesInput;
  rewardAmount?: Int;
  userId?: UserUpdateOneRequiredWithoutCupDataProcMdatesInput;
}

export interface CupDataQuestionCreateOneWithoutCupDataQaResponseInput {
  create?: CupDataQuestionCreateWithoutCupDataQaResponseInput;
  connect?: CupDataQuestionWhereUniqueInput;
}

export interface CupDataProcMdateUpdateManyMutationInput {
  dataRejected?: Boolean;
  dataVerified?: Boolean;
  menFinish?: DateTimeInput;
  menStart?: DateTimeInput;
  rewardAmount?: Int;
}

export interface CupDataQaResponseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CupDataQaResponseWhereInput;
  AND?:
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput;
  OR?:
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput;
  NOT?:
    | CupDataQaResponseSubscriptionWhereInput[]
    | CupDataQaResponseSubscriptionWhereInput;
}

export interface CupDataProcVolumeCreateInput {
  confidenceL?: Int;
  confidenceR?: Int;
  cupDataRowId: CupDatumCreateOneWithoutCupDataProcVolumeInput;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface UserRecordDataByPeriodCreateOneWithoutUserRecordDataByDayInput {
  create?: UserRecordDataByPeriodCreateWithoutUserRecordDataByDayInput;
  connect?: UserRecordDataByPeriodWhereUniqueInput;
}

export interface CupDatumCreateOneWithoutCupDataProcVolumeInput {
  create?: CupDatumCreateWithoutCupDataProcVolumeInput;
  connect?: CupDatumWhereUniqueInput;
}

export type HardwareWhereUniqueInput = AtLeastOne<{
  id: Int;
  hwVersion?: String;
}>;

export interface CupDatumCreateWithoutCupDataProcVolumeInput {
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  cupDataColourCalc?: CupDataColourCalcCreateManyWithoutCupDataRowIdInput;
  date: DateTimeInput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupCreateOneWithoutCupDataInput;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDataProcFlowCreateManyWithoutUserIdInput {
  create?:
    | CupDataProcFlowCreateWithoutUserIdInput[]
    | CupDataProcFlowCreateWithoutUserIdInput;
  connect?: CupDataProcFlowWhereUniqueInput[] | CupDataProcFlowWhereUniqueInput;
}

export interface CupDataProcVolumeUpdateInput {
  confidenceL?: Int;
  confidenceR?: Int;
  cupDataRowId?: CupDatumUpdateOneRequiredWithoutCupDataProcVolumeInput;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface AnswerTypeCreateOneWithoutUserInterviewQuestionsInput {
  create?: AnswerTypeCreateWithoutUserInterviewQuestionsInput;
  connect?: AnswerTypeWhereUniqueInput;
}

export interface CupDatumUpdateOneRequiredWithoutCupDataProcVolumeInput {
  create?: CupDatumCreateWithoutCupDataProcVolumeInput;
  update?: CupDatumUpdateWithoutCupDataProcVolumeDataInput;
  upsert?: CupDatumUpsertWithoutCupDataProcVolumeInput;
  connect?: CupDatumWhereUniqueInput;
}

export interface CupDataManMdateWhereInput {
  id?: Int;
  id_not?: Int;
  id_in?: Int[] | Int;
  id_not_in?: Int[] | Int;
  id_lt?: Int;
  id_lte?: Int;
  id_gt?: Int;
  id_gte?: Int;
  mdateRowId?: CupDataProcMdateWhereInput;
  menFinish?: DateTimeInput;
  menFinish_not?: DateTimeInput;
  menFinish_in?: DateTimeInput[] | DateTimeInput;
  menFinish_not_in?: DateTimeInput[] | DateTimeInput;
  menFinish_lt?: DateTimeInput;
  menFinish_lte?: DateTimeInput;
  menFinish_gt?: DateTimeInput;
  menFinish_gte?: DateTimeInput;
  menStart?: DateTimeInput;
  menStart_not?: DateTimeInput;
  menStart_in?: DateTimeInput[] | DateTimeInput;
  menStart_not_in?: DateTimeInput[] | DateTimeInput;
  menStart_lt?: DateTimeInput;
  menStart_lte?: DateTimeInput;
  menStart_gt?: DateTimeInput;
  menStart_gte?: DateTimeInput;
  AND?: CupDataManMdateWhereInput[] | CupDataManMdateWhereInput;
  OR?: CupDataManMdateWhereInput[] | CupDataManMdateWhereInput;
  NOT?: CupDataManMdateWhereInput[] | CupDataManMdateWhereInput;
}

export interface CupDataQaResponseCreateInput {
  answerId: CupDataAnswerCreateOneWithoutCupDataQaResponseInput;
  qaDate: DateTimeInput;
  questionId: CupDataQuestionCreateOneWithoutCupDataQaResponseInput;
  userId: UserCreateOneWithoutCupDataQaResponseInput;
}

export interface CupDataProcVolumeUpdateManyMutationInput {
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro?: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface CupDatumUpsertWithoutCupDataProcVolumeInput {
  update: CupDatumUpdateWithoutCupDataProcVolumeDataInput;
  create: CupDatumCreateWithoutCupDataProcVolumeInput;
}

export interface CupDatumUpdateWithoutCupDataProcVolumeDataInput {
  battery?: Int;
  calibFlag?: Boolean;
  ch1?: Int;
  ch10?: Int;
  ch11?: Int;
  ch12?: Int;
  ch13?: Int;
  ch14?: Int;
  ch2?: Int;
  ch3?: Int;
  ch4?: Int;
  ch5?: Int;
  ch6?: Int;
  ch7?: Int;
  ch8?: Int;
  ch9?: Int;
  colourB?: Int;
  colourC?: Int;
  colourG?: Int;
  colourR?: Int;
  cupDataColourCalc?: CupDataColourCalcUpdateManyWithoutCupDataRowIdInput;
  date?: DateTimeInput;
  day?: Int;
  hour?: Int;
  line?: Int;
  minute?: Int;
  month?: Int;
  page?: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  serialNumber?: CupUpdateOneWithoutCupDataInput;
  temperature?: Int;
  x?: Int;
  y?: Int;
  year?: Int;
  z?: Int;
}

export type CupDataRawWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface UsersDataAnalysisSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UsersDataAnalysisWhereInput;
  AND?:
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput;
  OR?:
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput;
  NOT?:
    | UsersDataAnalysisSubscriptionWhereInput[]
    | UsersDataAnalysisSubscriptionWhereInput;
}

export interface CalibrationCreateOneWithoutCupInput {
  create?: CalibrationCreateWithoutCupInput;
  connect?: CalibrationWhereUniqueInput;
}

export type UserRecordDataByDayWhereUniqueInput = AtLeastOne<{
  id: Int;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UsersDataAnalysisPreviousValues {
  id: Int;
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface UsersDataAnalysisPreviousValuesPromise
  extends Promise<UsersDataAnalysisPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface UsersDataAnalysisPreviousValuesSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface AuthTokenEdge {
  node: AuthToken;
  cursor: String;
}

export interface AuthTokenEdgePromise
  extends Promise<AuthTokenEdge>,
    Fragmentable {
  node: <T = AuthTokenPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthTokenEdgeSubscription
  extends Promise<AsyncIterator<AuthTokenEdge>>,
    Fragmentable {
  node: <T = AuthTokenSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByPeriodPreviousValues {
  id: Int;
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeOutput;
  mensStart?: DateTimeOutput;
}

export interface UserRecordDataByPeriodPreviousValuesPromise
  extends Promise<UserRecordDataByPeriodPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  coinHistoryRowId: () => Promise<Int>;
  isTakePill: () => Promise<Boolean>;
  mensFinish: () => Promise<DateTimeOutput>;
  mensStart: () => Promise<DateTimeOutput>;
}

export interface UserRecordDataByPeriodPreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  coinHistoryRowId: () => Promise<AsyncIterator<Int>>;
  isTakePill: () => Promise<AsyncIterator<Boolean>>;
  mensFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  mensStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AuthTokenConnection {
  pageInfo: PageInfo;
  edges: AuthTokenEdge[];
}

export interface AuthTokenConnectionPromise
  extends Promise<AuthTokenConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthTokenEdge>>() => T;
  aggregate: <T = AggregateAuthTokenPromise>() => T;
}

export interface AuthTokenConnectionSubscription
  extends Promise<AsyncIterator<AuthTokenConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthTokenEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthTokenSubscription>() => T;
}

export interface AggregateAppServerSync {
  count: Int;
}

export interface AggregateAppServerSyncPromise
  extends Promise<AggregateAppServerSync>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppServerSyncSubscription
  extends Promise<AsyncIterator<AggregateAppServerSync>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthToken {
  id: Int;
}

export interface AuthTokenPromise extends Promise<AuthToken>, Fragmentable {
  id: () => Promise<Int>;
}

export interface AuthTokenSubscription
  extends Promise<AsyncIterator<AuthToken>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
}

export interface UserInterviewQuestion {
  id: Int;
  question: String;
}

export interface UserInterviewQuestionPromise
  extends Promise<UserInterviewQuestion>,
    Fragmentable {
  id: () => Promise<Int>;
  answerTypeId: <T = AnswerTypePromise>() => T;
  question: () => Promise<String>;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserInterviewQuestionSubscription
  extends Promise<AsyncIterator<UserInterviewQuestion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerTypeId: <T = AnswerTypeSubscription>() => T;
  question: () => Promise<AsyncIterator<String>>;
  userInterviewData: <
    T = Promise<AsyncIterator<UserInterviewDatumSubscription>>
  >(
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UsersDataAnalysisEdge {
  node: UsersDataAnalysis;
  cursor: String;
}

export interface UsersDataAnalysisEdgePromise
  extends Promise<UsersDataAnalysisEdge>,
    Fragmentable {
  node: <T = UsersDataAnalysisPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UsersDataAnalysisEdgeSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisEdge>>,
    Fragmentable {
  node: <T = UsersDataAnalysisSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppServerSyncEdge {
  node: AppServerSync;
  cursor: String;
}

export interface AppServerSyncEdgePromise
  extends Promise<AppServerSyncEdge>,
    Fragmentable {
  node: <T = AppServerSyncPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppServerSyncEdgeSubscription
  extends Promise<AsyncIterator<AppServerSyncEdge>>,
    Fragmentable {
  node: <T = AppServerSyncSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AnswerType {
  id: Int;
  answerType: String;
}

export interface AnswerTypePromise extends Promise<AnswerType>, Fragmentable {
  id: () => Promise<Int>;
  answerType: () => Promise<String>;
  userInterviewQuestions: <T = FragmentableArray<UserInterviewQuestion>>(
    args?: {
      where?: UserInterviewQuestionWhereInput;
      orderBy?: UserInterviewQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AnswerTypeSubscription
  extends Promise<AsyncIterator<AnswerType>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerType: () => Promise<AsyncIterator<String>>;
  userInterviewQuestions: <
    T = Promise<AsyncIterator<UserInterviewQuestionSubscription>>
  >(
    args?: {
      where?: UserInterviewQuestionWhereInput;
      orderBy?: UserInterviewQuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AppServerSyncConnection {
  pageInfo: PageInfo;
  edges: AppServerSyncEdge[];
}

export interface AppServerSyncConnectionPromise
  extends Promise<AppServerSyncConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppServerSyncEdge>>() => T;
  aggregate: <T = AggregateAppServerSyncPromise>() => T;
}

export interface AppServerSyncConnectionSubscription
  extends Promise<AsyncIterator<AppServerSyncConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppServerSyncEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppServerSyncSubscription>() => T;
}

export interface AggregateUserRecordDataByTime {
  count: Int;
}

export interface AggregateUserRecordDataByTimePromise
  extends Promise<AggregateUserRecordDataByTime>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByTimeSubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByTime>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateAnswerType {
  count: Int;
}

export interface AggregateAnswerTypePromise
  extends Promise<AggregateAnswerType>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAnswerTypeSubscription
  extends Promise<AsyncIterator<AggregateAnswerType>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByTimeConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByTimeEdge[];
}

export interface UserRecordDataByTimeConnectionPromise
  extends Promise<UserRecordDataByTimeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByTimeEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByTimePromise>() => T;
}

export interface UserRecordDataByTimeConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByTimeEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByTimeSubscription>() => T;
}

export interface UserInterviewDatum {
  id: Int;
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeOutput;
}

export interface UserInterviewDatumPromise
  extends Promise<UserInterviewDatum>,
    Fragmentable {
  id: () => Promise<Int>;
  answerRange: () => Promise<Int>;
  answerText: () => Promise<String>;
  answerYn: () => Promise<Boolean>;
  date: () => Promise<DateTimeOutput>;
  questionId: <T = UserInterviewQuestionPromise>() => T;
  userId: <T = UserPromise>() => T;
}

export interface UserInterviewDatumSubscription
  extends Promise<AsyncIterator<UserInterviewDatum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerRange: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  answerYn: () => Promise<AsyncIterator<Boolean>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  questionId: <T = UserInterviewQuestionSubscription>() => T;
  userId: <T = UserSubscription>() => T;
}

export interface UserRecordDataByPeriodEdge {
  node: UserRecordDataByPeriod;
  cursor: String;
}

export interface UserRecordDataByPeriodEdgePromise
  extends Promise<UserRecordDataByPeriodEdge>,
    Fragmentable {
  node: <T = UserRecordDataByPeriodPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByPeriodEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByPeriodSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AnswerTypeSubscriptionPayload {
  mutation: MutationType;
  node: AnswerType;
  updatedFields: String[];
  previousValues: AnswerTypePreviousValues;
}

export interface AnswerTypeSubscriptionPayloadPromise
  extends Promise<AnswerTypeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AnswerTypePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AnswerTypePreviousValuesPromise>() => T;
}

export interface AnswerTypeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AnswerTypeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AnswerTypeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AnswerTypePreviousValuesSubscription>() => T;
}

export interface AggregateUserRecordDataByDay {
  count: Int;
}

export interface AggregateUserRecordDataByDayPromise
  extends Promise<AggregateUserRecordDataByDay>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByDaySubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByDay>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AnswerTypePreviousValues {
  id: Int;
  answerType: String;
}

export interface AnswerTypePreviousValuesPromise
  extends Promise<AnswerTypePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  answerType: () => Promise<String>;
}

export interface AnswerTypePreviousValuesSubscription
  extends Promise<AsyncIterator<AnswerTypePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerType: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByDayConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByDayEdge[];
}

export interface UserRecordDataByDayConnectionPromise
  extends Promise<UserRecordDataByDayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByDayEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByDayPromise>() => T;
}

export interface UserRecordDataByDayConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByDayEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByDaySubscription>() => T;
}

export interface AnswerTypeEdge {
  node: AnswerType;
  cursor: String;
}

export interface AnswerTypeEdgePromise
  extends Promise<AnswerTypeEdge>,
    Fragmentable {
  node: <T = AnswerTypePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AnswerTypeEdgeSubscription
  extends Promise<AsyncIterator<AnswerTypeEdge>>,
    Fragmentable {
  node: <T = AnswerTypeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserInterviewQuestionEdge {
  node: UserInterviewQuestion;
  cursor: String;
}

export interface UserInterviewQuestionEdgePromise
  extends Promise<UserInterviewQuestionEdge>,
    Fragmentable {
  node: <T = UserInterviewQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserInterviewQuestionEdgeSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionEdge>>,
    Fragmentable {
  node: <T = UserInterviewQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AppServerSyncSubscriptionPayload {
  mutation: MutationType;
  node: AppServerSync;
  updatedFields: String[];
  previousValues: AppServerSyncPreviousValues;
}

export interface AppServerSyncSubscriptionPayloadPromise
  extends Promise<AppServerSyncSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppServerSyncPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppServerSyncPreviousValuesPromise>() => T;
}

export interface AppServerSyncSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppServerSyncSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppServerSyncSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppServerSyncPreviousValuesSubscription>() => T;
}

export interface AggregateUserInterviewDatum {
  count: Int;
}

export interface AggregateUserInterviewDatumPromise
  extends Promise<AggregateUserInterviewDatum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserInterviewDatumSubscription
  extends Promise<AsyncIterator<AggregateUserInterviewDatum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppServerSyncPreviousValues {
  id: Int;
  serverSynchTime: DateTimeOutput;
}

export interface AppServerSyncPreviousValuesPromise
  extends Promise<AppServerSyncPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  serverSynchTime: () => Promise<DateTimeOutput>;
}

export interface AppServerSyncPreviousValuesSubscription
  extends Promise<AsyncIterator<AppServerSyncPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  serverSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserInterviewDatumConnection {
  pageInfo: PageInfo;
  edges: UserInterviewDatumEdge[];
}

export interface UserInterviewDatumConnectionPromise
  extends Promise<UserInterviewDatumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserInterviewDatumEdge>>() => T;
  aggregate: <T = AggregateUserInterviewDatumPromise>() => T;
}

export interface UserInterviewDatumConnectionSubscription
  extends Promise<AsyncIterator<UserInterviewDatumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserInterviewDatumEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserInterviewDatumSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserCupEdge {
  node: UserCup;
  cursor: String;
}

export interface UserCupEdgePromise extends Promise<UserCupEdge>, Fragmentable {
  node: <T = UserCupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCupEdgeSubscription
  extends Promise<AsyncIterator<UserCupEdge>>,
    Fragmentable {
  node: <T = UserCupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AuthTokenSubscriptionPayload {
  mutation: MutationType;
  node: AuthToken;
  updatedFields: String[];
  previousValues: AuthTokenPreviousValues;
}

export interface AuthTokenSubscriptionPayloadPromise
  extends Promise<AuthTokenSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthTokenPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthTokenPreviousValuesPromise>() => T;
}

export interface AuthTokenSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthTokenSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthTokenSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthTokenPreviousValuesSubscription>() => T;
}

export interface AggregateUserCoinHistory {
  count: Int;
}

export interface AggregateUserCoinHistoryPromise
  extends Promise<AggregateUserCoinHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCoinHistorySubscription
  extends Promise<AsyncIterator<AggregateUserCoinHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AuthTokenPreviousValues {
  id: Int;
}

export interface AuthTokenPreviousValuesPromise
  extends Promise<AuthTokenPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
}

export interface AuthTokenPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthTokenPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
}

export interface UserCoinHistoryConnection {
  pageInfo: PageInfo;
  edges: UserCoinHistoryEdge[];
}

export interface UserCoinHistoryConnectionPromise
  extends Promise<UserCoinHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCoinHistoryEdge>>() => T;
  aggregate: <T = AggregateUserCoinHistoryPromise>() => T;
}

export interface UserCoinHistoryConnectionSubscription
  extends Promise<AsyncIterator<UserCoinHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserCoinHistoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserCoinHistorySubscription>() => T;
}

export interface AnswerTypeConnection {
  pageInfo: PageInfo;
  edges: AnswerTypeEdge[];
}

export interface AnswerTypeConnectionPromise
  extends Promise<AnswerTypeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AnswerTypeEdge>>() => T;
  aggregate: <T = AggregateAnswerTypePromise>() => T;
}

export interface AnswerTypeConnectionSubscription
  extends Promise<AsyncIterator<AnswerTypeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AnswerTypeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAnswerTypeSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CalibrationSubscriptionPayload {
  mutation: MutationType;
  node: Calibration;
  updatedFields: String[];
  previousValues: CalibrationPreviousValues;
}

export interface CalibrationSubscriptionPayloadPromise
  extends Promise<CalibrationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CalibrationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CalibrationPreviousValuesPromise>() => T;
}

export interface CalibrationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CalibrationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CalibrationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CalibrationPreviousValuesSubscription>() => T;
}

export interface AggregatePlatformComp {
  count: Int;
}

export interface AggregatePlatformCompPromise
  extends Promise<AggregatePlatformComp>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePlatformCompSubscription
  extends Promise<AsyncIterator<AggregatePlatformComp>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CalibrationPreviousValues {
  id: Int;
  calibVersion: String;
}

export interface CalibrationPreviousValuesPromise
  extends Promise<CalibrationPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  calibVersion: () => Promise<String>;
}

export interface CalibrationPreviousValuesSubscription
  extends Promise<AsyncIterator<CalibrationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  calibVersion: () => Promise<AsyncIterator<String>>;
}

export interface PlatformCompConnection {
  pageInfo: PageInfo;
  edges: PlatformCompEdge[];
}

export interface PlatformCompConnectionPromise
  extends Promise<PlatformCompConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PlatformCompEdge>>() => T;
  aggregate: <T = AggregatePlatformCompPromise>() => T;
}

export interface PlatformCompConnectionSubscription
  extends Promise<AsyncIterator<PlatformCompConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PlatformCompEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePlatformCompSubscription>() => T;
}

export interface UserRecordDataByTime {
  id: Int;
  changeTime: DateTimeOutput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeOutput;
  volume?: Float;
}

export interface UserRecordDataByTimePromise
  extends Promise<UserRecordDataByTime>,
    Fragmentable {
  id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  colorB: () => Promise<Int>;
  colorG: () => Promise<Int>;
  colorR: () => Promise<Int>;
  leakage: () => Promise<String>;
  recordDayRowId: <T = UserRecordDataByDayPromise>() => T;
  startTime: () => Promise<DateTimeOutput>;
  volume: () => Promise<Float>;
}

export interface UserRecordDataByTimeSubscription
  extends Promise<AsyncIterator<UserRecordDataByTime>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  colorB: () => Promise<AsyncIterator<Int>>;
  colorG: () => Promise<AsyncIterator<Int>>;
  colorR: () => Promise<AsyncIterator<Int>>;
  leakage: () => Promise<AsyncIterator<String>>;
  recordDayRowId: <T = UserRecordDataByDaySubscription>() => T;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface AggregateHardware {
  count: Int;
}

export interface AggregateHardwarePromise
  extends Promise<AggregateHardware>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHardwareSubscription
  extends Promise<AsyncIterator<AggregateHardware>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface HardwareConnection {
  pageInfo: PageInfo;
  edges: HardwareEdge[];
}

export interface HardwareConnectionPromise
  extends Promise<HardwareConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HardwareEdge>>() => T;
  aggregate: <T = AggregateHardwarePromise>() => T;
}

export interface HardwareConnectionSubscription
  extends Promise<AsyncIterator<HardwareConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HardwareEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHardwareSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: Int;
  companyName: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  companyName: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  companyName: () => Promise<AsyncIterator<String>>;
}

export interface FirmwareEdge {
  node: Firmware;
  cursor: String;
}

export interface FirmwareEdgePromise
  extends Promise<FirmwareEdge>,
    Fragmentable {
  node: <T = FirmwarePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FirmwareEdgeSubscription
  extends Promise<AsyncIterator<FirmwareEdge>>,
    Fragmentable {
  node: <T = FirmwareSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByDay {
  id: Int;
  crampsLevel?: Int;
  recordDate: DateTimeOutput;
}

export interface UserRecordDataByDayPromise
  extends Promise<UserRecordDataByDay>,
    Fragmentable {
  id: () => Promise<Int>;
  crampsLevel: () => Promise<Int>;
  recordDate: () => Promise<DateTimeOutput>;
  recordPeriodRowId: <T = UserRecordDataByPeriodPromise>() => T;
  userRecordDataByTime: <T = FragmentableArray<UserRecordDataByTime>>(
    args?: {
      where?: UserRecordDataByTimeWhereInput;
      orderBy?: UserRecordDataByTimeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserRecordDataByDaySubscription
  extends Promise<AsyncIterator<UserRecordDataByDay>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  crampsLevel: () => Promise<AsyncIterator<Int>>;
  recordDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  recordPeriodRowId: <T = UserRecordDataByPeriodSubscription>() => T;
  userRecordDataByTime: <
    T = Promise<AsyncIterator<UserRecordDataByTimeSubscription>>
  >(
    args?: {
      where?: UserRecordDataByTimeWhereInput;
      orderBy?: UserRecordDataByTimeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateEthnicity {
  count: Int;
}

export interface AggregateEthnicityPromise
  extends Promise<AggregateEthnicity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEthnicitySubscription
  extends Promise<AsyncIterator<AggregateEthnicity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CountrySubscriptionPayload {
  mutation: MutationType;
  node: Country;
  updatedFields: String[];
  previousValues: CountryPreviousValues;
}

export interface CountrySubscriptionPayloadPromise
  extends Promise<CountrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CountryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CountryPreviousValuesPromise>() => T;
}

export interface CountrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CountrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CountrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CountryPreviousValuesSubscription>() => T;
}

export interface EthnicityConnection {
  pageInfo: PageInfo;
  edges: EthnicityEdge[];
}

export interface EthnicityConnectionPromise
  extends Promise<EthnicityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EthnicityEdge>>() => T;
  aggregate: <T = AggregateEthnicityPromise>() => T;
}

export interface EthnicityConnectionSubscription
  extends Promise<AsyncIterator<EthnicityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EthnicityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEthnicitySubscription>() => T;
}

export interface CountryPreviousValues {
  id: Int;
  countryName: String;
}

export interface CountryPreviousValuesPromise
  extends Promise<CountryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  countryName: () => Promise<String>;
}

export interface CountryPreviousValuesSubscription
  extends Promise<AsyncIterator<CountryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  countryName: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDatum {
  count: Int;
}

export interface AggregateCupDatumPromise
  extends Promise<AggregateCupDatum>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDatumSubscription
  extends Promise<AsyncIterator<AggregateCupDatum>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByPeriod {
  id: Int;
  coinHistoryRowId?: Int;
  isTakePill?: Boolean;
  mensFinish?: DateTimeOutput;
  mensStart?: DateTimeOutput;
}

export interface UserRecordDataByPeriodPromise
  extends Promise<UserRecordDataByPeriod>,
    Fragmentable {
  id: () => Promise<Int>;
  coinHistoryRowId: () => Promise<Int>;
  isTakePill: () => Promise<Boolean>;
  mensFinish: () => Promise<DateTimeOutput>;
  mensStart: () => Promise<DateTimeOutput>;
  userId: <T = UserPromise>() => T;
  userRecordDataByDay: <T = FragmentableArray<UserRecordDataByDay>>(
    args?: {
      where?: UserRecordDataByDayWhereInput;
      orderBy?: UserRecordDataByDayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserRecordDataByPeriodSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriod>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  coinHistoryRowId: () => Promise<AsyncIterator<Int>>;
  isTakePill: () => Promise<AsyncIterator<Boolean>>;
  mensFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  mensStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: <T = UserSubscription>() => T;
  userRecordDataByDay: <
    T = Promise<AsyncIterator<UserRecordDataByDaySubscription>>
  >(
    args?: {
      where?: UserRecordDataByDayWhereInput;
      orderBy?: UserRecordDataByDayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CupDatumConnection {
  pageInfo: PageInfo;
  edges: CupDatumEdge[];
}

export interface CupDatumConnectionPromise
  extends Promise<CupDatumConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDatumEdge>>() => T;
  aggregate: <T = AggregateCupDatumPromise>() => T;
}

export interface CupDatumConnectionSubscription
  extends Promise<AsyncIterator<CupDatumConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDatumEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDatumSubscription>() => T;
}

export interface CupSubscriptionPayload {
  mutation: MutationType;
  node: Cup;
  updatedFields: String[];
  previousValues: CupPreviousValues;
}

export interface CupSubscriptionPayloadPromise
  extends Promise<CupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupPreviousValuesPromise>() => T;
}

export interface CupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupPreviousValuesSubscription>() => T;
}

export interface CupDataUserRemoveExplainEdge {
  node: CupDataUserRemoveExplain;
  cursor: String;
}

export interface CupDataUserRemoveExplainEdgePromise
  extends Promise<CupDataUserRemoveExplainEdge>,
    Fragmentable {
  node: <T = CupDataUserRemoveExplainPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataUserRemoveExplainEdgeSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainEdge>>,
    Fragmentable {
  node: <T = CupDataUserRemoveExplainSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupPreviousValues {
  id: Int;
  anonSerialNumber: Int;
  encryptionKey: Int;
}

export interface CupPreviousValuesPromise
  extends Promise<CupPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  anonSerialNumber: () => Promise<Int>;
  encryptionKey: () => Promise<Int>;
}

export interface CupPreviousValuesSubscription
  extends Promise<AsyncIterator<CupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  anonSerialNumber: () => Promise<AsyncIterator<Int>>;
  encryptionKey: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByTimeSubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByTime;
  updatedFields: String[];
  previousValues: UserRecordDataByTimePreviousValues;
}

export interface UserRecordDataByTimeSubscriptionPayloadPromise
  extends Promise<UserRecordDataByTimeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByTimePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByTimePreviousValuesPromise>() => T;
}

export interface UserRecordDataByTimeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByTimeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByTimePreviousValuesSubscription>() => T;
}

export interface UserCoinHistory {
  id: Int;
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeOutput;
  txhash: String;
}

export interface UserCoinHistoryPromise
  extends Promise<UserCoinHistory>,
    Fragmentable {
  id: () => Promise<Int>;
  category: () => Promise<String>;
  coin: () => Promise<Int>;
  contents: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  txhash: () => Promise<String>;
  userId: <T = UserPromise>() => T;
}

export interface UserCoinHistorySubscription
  extends Promise<AsyncIterator<UserCoinHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  coin: () => Promise<AsyncIterator<Int>>;
  contents: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  txhash: () => Promise<AsyncIterator<String>>;
  userId: <T = UserSubscription>() => T;
}

export interface CupDataUserRemoveEdge {
  node: CupDataUserRemove;
  cursor: String;
}

export interface CupDataUserRemoveEdgePromise
  extends Promise<CupDataUserRemoveEdge>,
    Fragmentable {
  node: <T = CupDataUserRemovePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataUserRemoveEdgeSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveEdge>>,
    Fragmentable {
  node: <T = CupDataUserRemoveSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupAppSyncSubscriptionPayload {
  mutation: MutationType;
  node: CupAppSync;
  updatedFields: String[];
  previousValues: CupAppSyncPreviousValues;
}

export interface CupAppSyncSubscriptionPayloadPromise
  extends Promise<CupAppSyncSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupAppSyncPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupAppSyncPreviousValuesPromise>() => T;
}

export interface CupAppSyncSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupAppSyncSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupAppSyncSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupAppSyncPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataRejection {
  count: Int;
}

export interface AggregateCupDataRejectionPromise
  extends Promise<AggregateCupDataRejection>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataRejectionSubscription
  extends Promise<AsyncIterator<AggregateCupDataRejection>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupAppSyncPreviousValues {
  id: Int;
  appSynchTime: DateTimeOutput;
}

export interface CupAppSyncPreviousValuesPromise
  extends Promise<CupAppSyncPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  appSynchTime: () => Promise<DateTimeOutput>;
}

export interface CupAppSyncPreviousValuesSubscription
  extends Promise<AsyncIterator<CupAppSyncPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  appSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataRejectionConnection {
  pageInfo: PageInfo;
  edges: CupDataRejectionEdge[];
}

export interface CupDataRejectionConnectionPromise
  extends Promise<CupDataRejectionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataRejectionEdge>>() => T;
  aggregate: <T = AggregateCupDataRejectionPromise>() => T;
}

export interface CupDataRejectionConnectionSubscription
  extends Promise<AsyncIterator<CupDataRejectionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataRejectionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataRejectionSubscription>() => T;
}

export interface Ethnicity {
  id: Int;
  ethnicity: String;
}

export interface EthnicityPromise extends Promise<Ethnicity>, Fragmentable {
  id: () => Promise<Int>;
  ethnicity: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EthnicitySubscription
  extends Promise<AsyncIterator<Ethnicity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  ethnicity: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CupDataRawEdge {
  node: CupDataRaw;
  cursor: String;
}

export interface CupDataRawEdgePromise
  extends Promise<CupDataRawEdge>,
    Fragmentable {
  node: <T = CupDataRawPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataRawEdgeSubscription
  extends Promise<AsyncIterator<CupDataRawEdge>>,
    Fragmentable {
  node: <T = CupDataRawSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataAnswerSubscriptionPayload {
  mutation: MutationType;
  node: CupDataAnswer;
  updatedFields: String[];
  previousValues: CupDataAnswerPreviousValues;
}

export interface CupDataAnswerSubscriptionPayloadPromise
  extends Promise<CupDataAnswerSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataAnswerPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataAnswerPreviousValuesPromise>() => T;
}

export interface CupDataAnswerSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataAnswerSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataAnswerSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataAnswerPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataQuestion {
  count: Int;
}

export interface AggregateCupDataQuestionPromise
  extends Promise<AggregateCupDataQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataQuestionSubscription
  extends Promise<AsyncIterator<AggregateCupDataQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataAnswerPreviousValues {
  id: Int;
  answerText: String;
}

export interface CupDataAnswerPreviousValuesPromise
  extends Promise<CupDataAnswerPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  answerText: () => Promise<String>;
}

export interface CupDataAnswerPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataAnswerPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestionConnection {
  pageInfo: PageInfo;
  edges: CupDataQuestionEdge[];
}

export interface CupDataQuestionConnectionPromise
  extends Promise<CupDataQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataQuestionEdge>>() => T;
  aggregate: <T = AggregateCupDataQuestionPromise>() => T;
}

export interface CupDataQuestionConnectionSubscription
  extends Promise<AsyncIterator<CupDataQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataQuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataQuestionSubscription>() => T;
}

export interface UserCup {
  id: Int;
}

export interface UserCupPromise extends Promise<UserCup>, Fragmentable {
  id: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  userId: <T = UserPromise>() => T;
}

export interface UserCupSubscription
  extends Promise<AsyncIterator<UserCup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
  userId: <T = UserSubscription>() => T;
}

export interface CupDataQaResponseEdge {
  node: CupDataQaResponse;
  cursor: String;
}

export interface CupDataQaResponseEdgePromise
  extends Promise<CupDataQaResponseEdge>,
    Fragmentable {
  node: <T = CupDataQaResponsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataQaResponseEdgeSubscription
  extends Promise<AsyncIterator<CupDataQaResponseEdge>>,
    Fragmentable {
  node: <T = CupDataQaResponseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataColourCalcSubscriptionPayload {
  mutation: MutationType;
  node: CupDataColourCalc;
  updatedFields: String[];
  previousValues: CupDataColourCalcPreviousValues;
}

export interface CupDataColourCalcSubscriptionPayloadPromise
  extends Promise<CupDataColourCalcSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataColourCalcPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataColourCalcPreviousValuesPromise>() => T;
}

export interface CupDataColourCalcSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataColourCalcSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataColourCalcSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataColourCalcPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataProcVolume {
  count: Int;
}

export interface AggregateCupDataProcVolumePromise
  extends Promise<AggregateCupDataProcVolume>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcVolumeSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcVolume>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalcPreviousValues {
  id: Int;
  blue: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalcPreviousValuesPromise
  extends Promise<CupDataColourCalcPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  blue: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalcPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataColourCalcPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcVolumeConnection {
  pageInfo: PageInfo;
  edges: CupDataProcVolumeEdge[];
}

export interface CupDataProcVolumeConnectionPromise
  extends Promise<CupDataProcVolumeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcVolumeEdge>>() => T;
  aggregate: <T = AggregateCupDataProcVolumePromise>() => T;
}

export interface CupDataProcVolumeConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcVolumeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcVolumeSubscription>() => T;
}

export interface Hardware {
  id: Int;
  hwVersion: String;
}

export interface HardwarePromise extends Promise<Hardware>, Fragmentable {
  id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hwVersion: () => Promise<String>;
}

export interface HardwareSubscription
  extends Promise<AsyncIterator<Hardware>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  hwVersion: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcMdateEdge {
  node: CupDataProcMdate;
  cursor: String;
}

export interface CupDataProcMdateEdgePromise
  extends Promise<CupDataProcMdateEdge>,
    Fragmentable {
  node: <T = CupDataProcMdatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcMdateEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcMdateEdge>>,
    Fragmentable {
  node: <T = CupDataProcMdateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataColourCalibSubscriptionPayload {
  mutation: MutationType;
  node: CupDataColourCalib;
  updatedFields: String[];
  previousValues: CupDataColourCalibPreviousValues;
}

export interface CupDataColourCalibSubscriptionPayloadPromise
  extends Promise<CupDataColourCalibSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataColourCalibPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataColourCalibPreviousValuesPromise>() => T;
}

export interface CupDataColourCalibSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataColourCalibSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataColourCalibSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataColourCalibPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataProcFlow {
  count: Int;
}

export interface AggregateCupDataProcFlowPromise
  extends Promise<AggregateCupDataProcFlow>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcFlowSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcFlow>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataColourCalibPreviousValues {
  id: Int;
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalibPreviousValuesPromise
  extends Promise<CupDataColourCalibPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  blue: () => Promise<Int>;
  c: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalibPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataColourCalibPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  c: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcFlowConnection {
  pageInfo: PageInfo;
  edges: CupDataProcFlowEdge[];
}

export interface CupDataProcFlowConnectionPromise
  extends Promise<CupDataProcFlowConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcFlowEdge>>() => T;
  aggregate: <T = AggregateCupDataProcFlowPromise>() => T;
}

export interface CupDataProcFlowConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcFlowConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcFlowEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcFlowSubscription>() => T;
}

export interface Firmware {
  id: Int;
  fwVersion: String;
}

export interface FirmwarePromise extends Promise<Firmware>, Fragmentable {
  id: () => Promise<Int>;
  cup: <T = FragmentableArray<Cup>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fwVersion: () => Promise<String>;
}

export interface FirmwareSubscription
  extends Promise<AsyncIterator<Firmware>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  fwVersion: () => Promise<AsyncIterator<String>>;
}

export interface CupDataManMdateEdge {
  node: CupDataManMdate;
  cursor: String;
}

export interface CupDataManMdateEdgePromise
  extends Promise<CupDataManMdateEdge>,
    Fragmentable {
  node: <T = CupDataManMdatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataManMdateEdgeSubscription
  extends Promise<AsyncIterator<CupDataManMdateEdge>>,
    Fragmentable {
  node: <T = CupDataManMdateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataManMdateSubscriptionPayload {
  mutation: MutationType;
  node: CupDataManMdate;
  updatedFields: String[];
  previousValues: CupDataManMdatePreviousValues;
}

export interface CupDataManMdateSubscriptionPayloadPromise
  extends Promise<CupDataManMdateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataManMdatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataManMdatePreviousValuesPromise>() => T;
}

export interface CupDataManMdateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataManMdateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataManMdateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataManMdatePreviousValuesSubscription>() => T;
}

export interface AggregateCupDataColourCalib {
  count: Int;
}

export interface AggregateCupDataColourCalibPromise
  extends Promise<AggregateCupDataColourCalib>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataColourCalibSubscription
  extends Promise<AsyncIterator<AggregateCupDataColourCalib>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataManMdatePreviousValues {
  id: Int;
  menFinish?: DateTimeOutput;
  menStart?: DateTimeOutput;
}

export interface CupDataManMdatePreviousValuesPromise
  extends Promise<CupDataManMdatePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
}

export interface CupDataManMdatePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataManMdatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataColourCalibConnection {
  pageInfo: PageInfo;
  edges: CupDataColourCalibEdge[];
}

export interface CupDataColourCalibConnectionPromise
  extends Promise<CupDataColourCalibConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataColourCalibEdge>>() => T;
  aggregate: <T = AggregateCupDataColourCalibPromise>() => T;
}

export interface CupDataColourCalibConnectionSubscription
  extends Promise<AsyncIterator<CupDataColourCalibConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CupDataColourCalibEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCupDataColourCalibSubscription>() => T;
}

export interface CupDataRaw {
  id: Int;
  pageData: String;
}

export interface CupDataRawPromise extends Promise<CupDataRaw>, Fragmentable {
  id: () => Promise<Int>;
  pageData: () => Promise<String>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataRawSubscription
  extends Promise<AsyncIterator<CupDataRaw>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  pageData: () => Promise<AsyncIterator<String>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface CupDataColourCalcEdge {
  node: CupDataColourCalc;
  cursor: String;
}

export interface CupDataColourCalcEdgePromise
  extends Promise<CupDataColourCalcEdge>,
    Fragmentable {
  node: <T = CupDataColourCalcPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataColourCalcEdgeSubscription
  extends Promise<AsyncIterator<CupDataColourCalcEdge>>,
    Fragmentable {
  node: <T = CupDataColourCalcSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcFlowSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcFlow;
  updatedFields: String[];
  previousValues: CupDataProcFlowPreviousValues;
}

export interface CupDataProcFlowSubscriptionPayloadPromise
  extends Promise<CupDataProcFlowSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcFlowPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcFlowPreviousValuesPromise>() => T;
}

export interface CupDataProcFlowSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcFlowSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcFlowSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcFlowPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataAnswer {
  count: Int;
}

export interface AggregateCupDataAnswerPromise
  extends Promise<AggregateCupDataAnswer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataAnswerSubscription
  extends Promise<AsyncIterator<AggregateCupDataAnswer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcFlowPreviousValues {
  id: Int;
  date: DateTimeOutput;
  hourlyFlow: Int;
}

export interface CupDataProcFlowPreviousValuesPromise
  extends Promise<CupDataProcFlowPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  hourlyFlow: () => Promise<Int>;
}

export interface CupDataProcFlowPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcFlowPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  hourlyFlow: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataAnswerConnection {
  pageInfo: PageInfo;
  edges: CupDataAnswerEdge[];
}

export interface CupDataAnswerConnectionPromise
  extends Promise<CupDataAnswerConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataAnswerEdge>>() => T;
  aggregate: <T = AggregateCupDataAnswerPromise>() => T;
}

export interface CupDataAnswerConnectionSubscription
  extends Promise<AsyncIterator<CupDataAnswerConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataAnswerEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataAnswerSubscription>() => T;
}

export interface CupDataColourCalib {
  id: Int;
  blue: Int;
  c: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalibPromise
  extends Promise<CupDataColourCalib>,
    Fragmentable {
  id: () => Promise<Int>;
  blue: () => Promise<Int>;
  c: () => Promise<Int>;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupDataColourCalibSubscription
  extends Promise<AsyncIterator<CupDataColourCalib>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  c: () => Promise<AsyncIterator<Int>>;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface CupAppSyncEdge {
  node: CupAppSync;
  cursor: String;
}

export interface CupAppSyncEdgePromise
  extends Promise<CupAppSyncEdge>,
    Fragmentable {
  node: <T = CupAppSyncPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupAppSyncEdgeSubscription
  extends Promise<AsyncIterator<CupAppSyncEdge>>,
    Fragmentable {
  node: <T = CupAppSyncSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcMdateSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcMdate;
  updatedFields: String[];
  previousValues: CupDataProcMdatePreviousValues;
}

export interface CupDataProcMdateSubscriptionPayloadPromise
  extends Promise<CupDataProcMdateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcMdatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcMdatePreviousValuesPromise>() => T;
}

export interface CupDataProcMdateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcMdateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcMdateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcMdatePreviousValuesSubscription>() => T;
}

export interface AggregateCup {
  count: Int;
}

export interface AggregateCupPromise
  extends Promise<AggregateCup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupSubscription
  extends Promise<AsyncIterator<AggregateCup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcMdatePreviousValues {
  id: Int;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeOutput;
  menStart: DateTimeOutput;
  rewardAmount?: Int;
}

export interface CupDataProcMdatePreviousValuesPromise
  extends Promise<CupDataProcMdatePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  dataRejected: () => Promise<Boolean>;
  dataVerified: () => Promise<Boolean>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
  rewardAmount: () => Promise<Int>;
}

export interface CupDataProcMdatePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcMdatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  dataRejected: () => Promise<AsyncIterator<Boolean>>;
  dataVerified: () => Promise<AsyncIterator<Boolean>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  rewardAmount: () => Promise<AsyncIterator<Int>>;
}

export interface CupConnection {
  pageInfo: PageInfo;
  edges: CupEdge[];
}

export interface CupConnectionPromise
  extends Promise<CupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupEdge>>() => T;
  aggregate: <T = AggregateCupPromise>() => T;
}

export interface CupConnectionSubscription
  extends Promise<AsyncIterator<CupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupSubscription>() => T;
}

export interface CupDataProcVolume {
  id: Int;
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface CupDataProcVolumePromise
  extends Promise<CupDataProcVolume>,
    Fragmentable {
  id: () => Promise<Int>;
  confidenceL: () => Promise<Int>;
  confidenceR: () => Promise<Int>;
  cupDataRowId: <T = CupDatumPromise>() => T;
  inVitro: () => Promise<Boolean>;
  volume: () => Promise<Int>;
  volumeAdj: () => Promise<Int>;
  volumeL: () => Promise<Int>;
  volumeR: () => Promise<Int>;
}

export interface CupDataProcVolumeSubscription
  extends Promise<AsyncIterator<CupDataProcVolume>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  confidenceL: () => Promise<AsyncIterator<Int>>;
  confidenceR: () => Promise<AsyncIterator<Int>>;
  cupDataRowId: <T = CupDatumSubscription>() => T;
  inVitro: () => Promise<AsyncIterator<Boolean>>;
  volume: () => Promise<AsyncIterator<Int>>;
  volumeAdj: () => Promise<AsyncIterator<Int>>;
  volumeL: () => Promise<AsyncIterator<Int>>;
  volumeR: () => Promise<AsyncIterator<Int>>;
}

export interface CountryEdge {
  node: Country;
  cursor: String;
}

export interface CountryEdgePromise extends Promise<CountryEdge>, Fragmentable {
  node: <T = CountryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CountryEdgeSubscription
  extends Promise<AsyncIterator<CountryEdge>>,
    Fragmentable {
  node: <T = CountrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcVolumeSubscriptionPayload {
  mutation: MutationType;
  node: CupDataProcVolume;
  updatedFields: String[];
  previousValues: CupDataProcVolumePreviousValues;
}

export interface CupDataProcVolumeSubscriptionPayloadPromise
  extends Promise<CupDataProcVolumeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataProcVolumePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataProcVolumePreviousValuesPromise>() => T;
}

export interface CupDataProcVolumeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataProcVolumeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataProcVolumePreviousValuesSubscription>() => T;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcVolumePreviousValues {
  id: Int;
  confidenceL?: Int;
  confidenceR?: Int;
  inVitro: Boolean;
  volume?: Int;
  volumeAdj?: Int;
  volumeL?: Int;
  volumeR?: Int;
}

export interface CupDataProcVolumePreviousValuesPromise
  extends Promise<CupDataProcVolumePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  confidenceL: () => Promise<Int>;
  confidenceR: () => Promise<Int>;
  inVitro: () => Promise<Boolean>;
  volume: () => Promise<Int>;
  volumeAdj: () => Promise<Int>;
  volumeL: () => Promise<Int>;
  volumeR: () => Promise<Int>;
}

export interface CupDataProcVolumePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataProcVolumePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  confidenceL: () => Promise<AsyncIterator<Int>>;
  confidenceR: () => Promise<AsyncIterator<Int>>;
  inVitro: () => Promise<AsyncIterator<Boolean>>;
  volume: () => Promise<AsyncIterator<Int>>;
  volumeAdj: () => Promise<AsyncIterator<Int>>;
  volumeL: () => Promise<AsyncIterator<Int>>;
  volumeR: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CupDataColourCalc {
  id: Int;
  blue: Int;
  green: Int;
  red: Int;
}

export interface CupDataColourCalcPromise
  extends Promise<CupDataColourCalc>,
    Fragmentable {
  id: () => Promise<Int>;
  blue: () => Promise<Int>;
  cupDataRowId: <T = CupDatumPromise>() => T;
  green: () => Promise<Int>;
  red: () => Promise<Int>;
}

export interface CupDataColourCalcSubscription
  extends Promise<AsyncIterator<CupDataColourCalc>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  blue: () => Promise<AsyncIterator<Int>>;
  cupDataRowId: <T = CupDatumSubscription>() => T;
  green: () => Promise<AsyncIterator<Int>>;
  red: () => Promise<AsyncIterator<Int>>;
}

export interface CalibrationEdge {
  node: Calibration;
  cursor: String;
}

export interface CalibrationEdgePromise
  extends Promise<CalibrationEdge>,
    Fragmentable {
  node: <T = CalibrationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CalibrationEdgeSubscription
  extends Promise<AsyncIterator<CalibrationEdge>>,
    Fragmentable {
  node: <T = CalibrationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQaResponseSubscriptionPayload {
  mutation: MutationType;
  node: CupDataQaResponse;
  updatedFields: String[];
  previousValues: CupDataQaResponsePreviousValues;
}

export interface CupDataQaResponseSubscriptionPayloadPromise
  extends Promise<CupDataQaResponseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataQaResponsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataQaResponsePreviousValuesPromise>() => T;
}

export interface CupDataQaResponseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataQaResponseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataQaResponseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataQaResponsePreviousValuesSubscription>() => T;
}

export interface AggregateAuthToken {
  count: Int;
}

export interface AggregateAuthTokenPromise
  extends Promise<AggregateAuthToken>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthTokenSubscription
  extends Promise<AsyncIterator<AggregateAuthToken>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataQaResponsePreviousValues {
  id: Int;
  qaDate: DateTimeOutput;
}

export interface CupDataQaResponsePreviousValuesPromise
  extends Promise<CupDataQaResponsePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  qaDate: () => Promise<DateTimeOutput>;
}

export interface CupDataQaResponsePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataQaResponsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  qaDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUsersDataAnalysis {
  count: Int;
}

export interface AggregateUsersDataAnalysisPromise
  extends Promise<AggregateUsersDataAnalysis>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUsersDataAnalysisSubscription
  extends Promise<AsyncIterator<AggregateUsersDataAnalysis>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDatum {
  id: Int;
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  date: DateTimeOutput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDatumPromise extends Promise<CupDatum>, Fragmentable {
  id: () => Promise<Int>;
  battery: () => Promise<Int>;
  calibFlag: () => Promise<Boolean>;
  ch1: () => Promise<Int>;
  ch10: () => Promise<Int>;
  ch11: () => Promise<Int>;
  ch12: () => Promise<Int>;
  ch13: () => Promise<Int>;
  ch14: () => Promise<Int>;
  ch2: () => Promise<Int>;
  ch3: () => Promise<Int>;
  ch4: () => Promise<Int>;
  ch5: () => Promise<Int>;
  ch6: () => Promise<Int>;
  ch7: () => Promise<Int>;
  ch8: () => Promise<Int>;
  ch9: () => Promise<Int>;
  colourB: () => Promise<Int>;
  colourC: () => Promise<Int>;
  colourG: () => Promise<Int>;
  colourR: () => Promise<Int>;
  cupDataColourCalc: <T = FragmentableArray<CupDataColourCalc>>(
    args?: {
      where?: CupDataColourCalcWhereInput;
      orderBy?: CupDataColourCalcOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcVolume: <T = FragmentableArray<CupDataProcVolume>>(
    args?: {
      where?: CupDataProcVolumeWhereInput;
      orderBy?: CupDataProcVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  date: () => Promise<DateTimeOutput>;
  day: () => Promise<Int>;
  hour: () => Promise<Int>;
  line: () => Promise<Int>;
  minute: () => Promise<Int>;
  month: () => Promise<Int>;
  page: () => Promise<Int>;
  rawTotalVolume: () => Promise<Int>;
  rawVolumeL: () => Promise<Int>;
  rawVolumeR: () => Promise<Int>;
  serialNumber: <T = CupPromise>() => T;
  temperature: () => Promise<Int>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  year: () => Promise<Int>;
  z: () => Promise<Int>;
}

export interface CupDatumSubscription
  extends Promise<AsyncIterator<CupDatum>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  battery: () => Promise<AsyncIterator<Int>>;
  calibFlag: () => Promise<AsyncIterator<Boolean>>;
  ch1: () => Promise<AsyncIterator<Int>>;
  ch10: () => Promise<AsyncIterator<Int>>;
  ch11: () => Promise<AsyncIterator<Int>>;
  ch12: () => Promise<AsyncIterator<Int>>;
  ch13: () => Promise<AsyncIterator<Int>>;
  ch14: () => Promise<AsyncIterator<Int>>;
  ch2: () => Promise<AsyncIterator<Int>>;
  ch3: () => Promise<AsyncIterator<Int>>;
  ch4: () => Promise<AsyncIterator<Int>>;
  ch5: () => Promise<AsyncIterator<Int>>;
  ch6: () => Promise<AsyncIterator<Int>>;
  ch7: () => Promise<AsyncIterator<Int>>;
  ch8: () => Promise<AsyncIterator<Int>>;
  ch9: () => Promise<AsyncIterator<Int>>;
  colourB: () => Promise<AsyncIterator<Int>>;
  colourC: () => Promise<AsyncIterator<Int>>;
  colourG: () => Promise<AsyncIterator<Int>>;
  colourR: () => Promise<AsyncIterator<Int>>;
  cupDataColourCalc: <
    T = Promise<AsyncIterator<CupDataColourCalcSubscription>>
  >(
    args?: {
      where?: CupDataColourCalcWhereInput;
      orderBy?: CupDataColourCalcOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcVolume: <
    T = Promise<AsyncIterator<CupDataProcVolumeSubscription>>
  >(
    args?: {
      where?: CupDataProcVolumeWhereInput;
      orderBy?: CupDataProcVolumeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  day: () => Promise<AsyncIterator<Int>>;
  hour: () => Promise<AsyncIterator<Int>>;
  line: () => Promise<AsyncIterator<Int>>;
  minute: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  page: () => Promise<AsyncIterator<Int>>;
  rawTotalVolume: () => Promise<AsyncIterator<Int>>;
  rawVolumeL: () => Promise<AsyncIterator<Int>>;
  rawVolumeR: () => Promise<AsyncIterator<Int>>;
  serialNumber: <T = CupSubscription>() => T;
  temperature: () => Promise<AsyncIterator<Int>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
}

export interface UsersDataAnalysis {
  id: Int;
  email: String;
  firstName: String;
  lastName: String;
  password: String;
  userId: String;
}

export interface UsersDataAnalysisPromise
  extends Promise<UsersDataAnalysis>,
    Fragmentable {
  id: () => Promise<Int>;
  email: () => Promise<String>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userId: () => Promise<String>;
}

export interface UsersDataAnalysisSubscription
  extends Promise<AsyncIterator<UsersDataAnalysis>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  email: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userId: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestionSubscriptionPayload {
  mutation: MutationType;
  node: CupDataQuestion;
  updatedFields: String[];
  previousValues: CupDataQuestionPreviousValues;
}

export interface CupDataQuestionSubscriptionPayloadPromise
  extends Promise<CupDataQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataQuestionPreviousValuesPromise>() => T;
}

export interface CupDataQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataQuestionPreviousValuesSubscription>() => T;
}

export interface AggregateUserRecordDataByPeriod {
  count: Int;
}

export interface AggregateUserRecordDataByPeriodPromise
  extends Promise<AggregateUserRecordDataByPeriod>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRecordDataByPeriodSubscription
  extends Promise<AsyncIterator<AggregateUserRecordDataByPeriod>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataQuestionPreviousValues {
  id: Int;
  questionText: String;
}

export interface CupDataQuestionPreviousValuesPromise
  extends Promise<CupDataQuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  questionText: () => Promise<String>;
}

export interface CupDataQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataQuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  questionText: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByDayEdge {
  node: UserRecordDataByDay;
  cursor: String;
}

export interface UserRecordDataByDayEdgePromise
  extends Promise<UserRecordDataByDayEdge>,
    Fragmentable {
  node: <T = UserRecordDataByDayPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByDayEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByDaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupAppSync {
  id: Int;
  appSynchTime: DateTimeOutput;
}

export interface CupAppSyncPromise extends Promise<CupAppSync>, Fragmentable {
  id: () => Promise<Int>;
  appSynchTime: () => Promise<DateTimeOutput>;
  serialNumber: <T = CupPromise>() => T;
}

export interface CupAppSyncSubscription
  extends Promise<AsyncIterator<CupAppSync>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  appSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  serialNumber: <T = CupSubscription>() => T;
}

export interface UserInterviewQuestionConnection {
  pageInfo: PageInfo;
  edges: UserInterviewQuestionEdge[];
}

export interface UserInterviewQuestionConnectionPromise
  extends Promise<UserInterviewQuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserInterviewQuestionEdge>>() => T;
  aggregate: <T = AggregateUserInterviewQuestionPromise>() => T;
}

export interface UserInterviewQuestionConnectionSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserInterviewQuestionEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserInterviewQuestionSubscription>() => T;
}

export interface CupDataRawSubscriptionPayload {
  mutation: MutationType;
  node: CupDataRaw;
  updatedFields: String[];
  previousValues: CupDataRawPreviousValues;
}

export interface CupDataRawSubscriptionPayloadPromise
  extends Promise<CupDataRawSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataRawPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataRawPreviousValuesPromise>() => T;
}

export interface CupDataRawSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataRawSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataRawSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataRawPreviousValuesSubscription>() => T;
}

export interface AggregateUserCup {
  count: Int;
}

export interface AggregateUserCupPromise
  extends Promise<AggregateUserCup>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserCupSubscription
  extends Promise<AsyncIterator<AggregateUserCup>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataRawPreviousValues {
  id: Int;
  pageData: String;
}

export interface CupDataRawPreviousValuesPromise
  extends Promise<CupDataRawPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  pageData: () => Promise<String>;
}

export interface CupDataRawPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataRawPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  pageData: () => Promise<AsyncIterator<String>>;
}

export interface UserCoinHistoryEdge {
  node: UserCoinHistory;
  cursor: String;
}

export interface UserCoinHistoryEdgePromise
  extends Promise<UserCoinHistoryEdge>,
    Fragmentable {
  node: <T = UserCoinHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserCoinHistoryEdgeSubscription
  extends Promise<AsyncIterator<UserCoinHistoryEdge>>,
    Fragmentable {
  node: <T = UserCoinHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Company {
  id: Int;
  companyName: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<Int>;
  companyName: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  companyName: () => Promise<AsyncIterator<String>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface CupDataRejectionSubscriptionPayload {
  mutation: MutationType;
  node: CupDataRejection;
  updatedFields: String[];
  previousValues: CupDataRejectionPreviousValues;
}

export interface CupDataRejectionSubscriptionPayloadPromise
  extends Promise<CupDataRejectionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataRejectionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataRejectionPreviousValuesPromise>() => T;
}

export interface CupDataRejectionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataRejectionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataRejectionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataRejectionPreviousValuesSubscription>() => T;
}

export interface PlatformComp {
  id: Int;
  phoneId: Int;
  platformId: Int;
  problemHistory?: Boolean;
  softwareId: Int;
  successHistory?: Boolean;
}

export interface PlatformCompPromise
  extends Promise<PlatformComp>,
    Fragmentable {
  id: () => Promise<Int>;
  phoneId: () => Promise<Int>;
  platformId: () => Promise<Int>;
  problemHistory: () => Promise<Boolean>;
  softwareId: () => Promise<Int>;
  successHistory: () => Promise<Boolean>;
}

export interface PlatformCompSubscription
  extends Promise<AsyncIterator<PlatformComp>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  phoneId: () => Promise<AsyncIterator<Int>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  problemHistory: () => Promise<AsyncIterator<Boolean>>;
  softwareId: () => Promise<AsyncIterator<Int>>;
  successHistory: () => Promise<AsyncIterator<Boolean>>;
}

export interface CupDataRejectionPreviousValues {
  id: Int;
  rejectionDescription: String;
}

export interface CupDataRejectionPreviousValuesPromise
  extends Promise<CupDataRejectionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  rejectionDescription: () => Promise<String>;
}

export interface CupDataRejectionPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataRejectionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  rejectionDescription: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFirmware {
  count: Int;
}

export interface AggregateFirmwarePromise
  extends Promise<AggregateFirmware>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFirmwareSubscription
  extends Promise<AsyncIterator<AggregateFirmware>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Calibration {
  id: Int;
  calibVersion: String;
}

export interface CalibrationPromise extends Promise<Calibration>, Fragmentable {
  id: () => Promise<Int>;
  calibVersion: () => Promise<String>;
  cup: <T = FragmentableArray<Cup>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CalibrationSubscription
  extends Promise<AsyncIterator<Calibration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  calibVersion: () => Promise<AsyncIterator<String>>;
  cup: <T = Promise<AsyncIterator<CupSubscription>>>(
    args?: {
      where?: CupWhereInput;
      orderBy?: CupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EthnicityEdge {
  node: Ethnicity;
  cursor: String;
}

export interface EthnicityEdgePromise
  extends Promise<EthnicityEdge>,
    Fragmentable {
  node: <T = EthnicityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EthnicityEdgeSubscription
  extends Promise<AsyncIterator<EthnicityEdge>>,
    Fragmentable {
  node: <T = EthnicitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemoveSubscriptionPayload {
  mutation: MutationType;
  node: CupDataUserRemove;
  updatedFields: String[];
  previousValues: CupDataUserRemovePreviousValues;
}

export interface CupDataUserRemoveSubscriptionPayloadPromise
  extends Promise<CupDataUserRemoveSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataUserRemovePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataUserRemovePreviousValuesPromise>() => T;
}

export interface CupDataUserRemoveSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataUserRemoveSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDataUserRemovePreviousValuesSubscription>() => T;
}

export interface CupDatumEdge {
  node: CupDatum;
  cursor: String;
}

export interface CupDatumEdgePromise
  extends Promise<CupDatumEdge>,
    Fragmentable {
  node: <T = CupDatumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDatumEdgeSubscription
  extends Promise<AsyncIterator<CupDatumEdge>>,
    Fragmentable {
  node: <T = CupDatumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemovePreviousValues {
  id: Int;
  changeTime: DateTimeOutput;
}

export interface CupDataUserRemovePreviousValuesPromise
  extends Promise<CupDataUserRemovePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
}

export interface CupDataUserRemovePreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataUserRemovePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataUserRemoveExplainConnection {
  pageInfo: PageInfo;
  edges: CupDataUserRemoveExplainEdge[];
}

export interface CupDataUserRemoveExplainConnectionPromise
  extends Promise<CupDataUserRemoveExplainConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataUserRemoveExplainEdge>>() => T;
  aggregate: <T = AggregateCupDataUserRemoveExplainPromise>() => T;
}

export interface CupDataUserRemoveExplainConnectionSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CupDataUserRemoveExplainEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCupDataUserRemoveExplainSubscription>() => T;
}

export interface Cup {
  id: Int;
  anonSerialNumber: Int;
  encryptionKey: Int;
}

export interface CupPromise extends Promise<Cup>, Fragmentable {
  id: () => Promise<Int>;
  anonSerialNumber: () => Promise<Int>;
  calibId: <T = CalibrationPromise>() => T;
  companyId: <T = CompanyPromise>() => T;
  cupAppSync: <T = FragmentableArray<CupAppSync>>(
    args?: {
      where?: CupAppSyncWhereInput;
      orderBy?: CupAppSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupData: <T = FragmentableArray<CupDatum>>(
    args?: {
      where?: CupDatumWhereInput;
      orderBy?: CupDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataColourCalib: <T = FragmentableArray<CupDataColourCalib>>(
    args?: {
      where?: CupDataColourCalibWhereInput;
      orderBy?: CupDataColourCalibOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataRaw: <T = FragmentableArray<CupDataRaw>>(
    args?: {
      where?: CupDataRawWhereInput;
      orderBy?: CupDataRawOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  encryptionKey: () => Promise<Int>;
  fwId: <T = FirmwarePromise>() => T;
  hwId: <T = HardwarePromise>() => T;
  userCups: <T = FragmentableArray<UserCup>>(
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CupSubscription
  extends Promise<AsyncIterator<Cup>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  anonSerialNumber: () => Promise<AsyncIterator<Int>>;
  calibId: <T = CalibrationSubscription>() => T;
  companyId: <T = CompanySubscription>() => T;
  cupAppSync: <T = Promise<AsyncIterator<CupAppSyncSubscription>>>(
    args?: {
      where?: CupAppSyncWhereInput;
      orderBy?: CupAppSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupData: <T = Promise<AsyncIterator<CupDatumSubscription>>>(
    args?: {
      where?: CupDatumWhereInput;
      orderBy?: CupDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataColourCalib: <
    T = Promise<AsyncIterator<CupDataColourCalibSubscription>>
  >(
    args?: {
      where?: CupDataColourCalibWhereInput;
      orderBy?: CupDataColourCalibOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataRaw: <T = Promise<AsyncIterator<CupDataRawSubscription>>>(
    args?: {
      where?: CupDataRawWhereInput;
      orderBy?: CupDataRawOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  encryptionKey: () => Promise<AsyncIterator<Int>>;
  fwId: <T = FirmwareSubscription>() => T;
  hwId: <T = HardwareSubscription>() => T;
  userCups: <T = Promise<AsyncIterator<UserCupSubscription>>>(
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CupDataUserRemoveConnection {
  pageInfo: PageInfo;
  edges: CupDataUserRemoveEdge[];
}

export interface CupDataUserRemoveConnectionPromise
  extends Promise<CupDataUserRemoveConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataUserRemoveEdge>>() => T;
  aggregate: <T = AggregateCupDataUserRemovePromise>() => T;
}

export interface CupDataUserRemoveConnectionSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataUserRemoveEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataUserRemoveSubscription>() => T;
}

export interface CupDataUserRemoveExplainSubscriptionPayload {
  mutation: MutationType;
  node: CupDataUserRemoveExplain;
  updatedFields: String[];
  previousValues: CupDataUserRemoveExplainPreviousValues;
}

export interface CupDataUserRemoveExplainSubscriptionPayloadPromise
  extends Promise<CupDataUserRemoveExplainSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDataUserRemoveExplainPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDataUserRemoveExplainPreviousValuesPromise>() => T;
}

export interface CupDataUserRemoveExplainSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDataUserRemoveExplainSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = CupDataUserRemoveExplainPreviousValuesSubscription
  >() => T;
}

export interface AggregateCupDataRaw {
  count: Int;
}

export interface AggregateCupDataRawPromise
  extends Promise<AggregateCupDataRaw>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataRawSubscription
  extends Promise<AsyncIterator<AggregateCupDataRaw>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataUserRemoveExplainPreviousValues {
  id: Int;
  explain: String;
}

export interface CupDataUserRemoveExplainPreviousValuesPromise
  extends Promise<CupDataUserRemoveExplainPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  explain: () => Promise<String>;
}

export interface CupDataUserRemoveExplainPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplainPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  explain: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestionEdge {
  node: CupDataQuestion;
  cursor: String;
}

export interface CupDataQuestionEdgePromise
  extends Promise<CupDataQuestionEdge>,
    Fragmentable {
  node: <T = CupDataQuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataQuestionEdgeSubscription
  extends Promise<AsyncIterator<CupDataQuestionEdge>>,
    Fragmentable {
  node: <T = CupDataQuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemoveExplain {
  id: Int;
  explain: String;
}

export interface CupDataUserRemoveExplainPromise
  extends Promise<CupDataUserRemoveExplain>,
    Fragmentable {
  id: () => Promise<Int>;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  explain: () => Promise<String>;
}

export interface CupDataUserRemoveExplainSubscription
  extends Promise<AsyncIterator<CupDataUserRemoveExplain>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  explain: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQaResponseConnection {
  pageInfo: PageInfo;
  edges: CupDataQaResponseEdge[];
}

export interface CupDataQaResponseConnectionPromise
  extends Promise<CupDataQaResponseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataQaResponseEdge>>() => T;
  aggregate: <T = AggregateCupDataQaResponsePromise>() => T;
}

export interface CupDataQaResponseConnectionSubscription
  extends Promise<AsyncIterator<CupDataQaResponseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataQaResponseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataQaResponseSubscription>() => T;
}

export interface CupDatumSubscriptionPayload {
  mutation: MutationType;
  node: CupDatum;
  updatedFields: String[];
  previousValues: CupDatumPreviousValues;
}

export interface CupDatumSubscriptionPayloadPromise
  extends Promise<CupDatumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CupDatumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CupDatumPreviousValuesPromise>() => T;
}

export interface CupDatumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CupDatumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CupDatumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CupDatumPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataProcMdate {
  count: Int;
}

export interface AggregateCupDataProcMdatePromise
  extends Promise<AggregateCupDataProcMdate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataProcMdateSubscription
  extends Promise<AsyncIterator<AggregateCupDataProcMdate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CupDatumPreviousValues {
  id: Int;
  battery: Int;
  calibFlag: Boolean;
  ch1: Int;
  ch10: Int;
  ch11: Int;
  ch12: Int;
  ch13: Int;
  ch14: Int;
  ch2: Int;
  ch3: Int;
  ch4: Int;
  ch5: Int;
  ch6: Int;
  ch7: Int;
  ch8: Int;
  ch9: Int;
  colourB: Int;
  colourC: Int;
  colourG: Int;
  colourR: Int;
  date: DateTimeOutput;
  day: Int;
  hour: Int;
  line: Int;
  minute: Int;
  month: Int;
  page: Int;
  rawTotalVolume?: Int;
  rawVolumeL?: Int;
  rawVolumeR?: Int;
  temperature: Int;
  x: Int;
  y: Int;
  year: Int;
  z: Int;
}

export interface CupDatumPreviousValuesPromise
  extends Promise<CupDatumPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  battery: () => Promise<Int>;
  calibFlag: () => Promise<Boolean>;
  ch1: () => Promise<Int>;
  ch10: () => Promise<Int>;
  ch11: () => Promise<Int>;
  ch12: () => Promise<Int>;
  ch13: () => Promise<Int>;
  ch14: () => Promise<Int>;
  ch2: () => Promise<Int>;
  ch3: () => Promise<Int>;
  ch4: () => Promise<Int>;
  ch5: () => Promise<Int>;
  ch6: () => Promise<Int>;
  ch7: () => Promise<Int>;
  ch8: () => Promise<Int>;
  ch9: () => Promise<Int>;
  colourB: () => Promise<Int>;
  colourC: () => Promise<Int>;
  colourG: () => Promise<Int>;
  colourR: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  day: () => Promise<Int>;
  hour: () => Promise<Int>;
  line: () => Promise<Int>;
  minute: () => Promise<Int>;
  month: () => Promise<Int>;
  page: () => Promise<Int>;
  rawTotalVolume: () => Promise<Int>;
  rawVolumeL: () => Promise<Int>;
  rawVolumeR: () => Promise<Int>;
  temperature: () => Promise<Int>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  year: () => Promise<Int>;
  z: () => Promise<Int>;
}

export interface CupDatumPreviousValuesSubscription
  extends Promise<AsyncIterator<CupDatumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  battery: () => Promise<AsyncIterator<Int>>;
  calibFlag: () => Promise<AsyncIterator<Boolean>>;
  ch1: () => Promise<AsyncIterator<Int>>;
  ch10: () => Promise<AsyncIterator<Int>>;
  ch11: () => Promise<AsyncIterator<Int>>;
  ch12: () => Promise<AsyncIterator<Int>>;
  ch13: () => Promise<AsyncIterator<Int>>;
  ch14: () => Promise<AsyncIterator<Int>>;
  ch2: () => Promise<AsyncIterator<Int>>;
  ch3: () => Promise<AsyncIterator<Int>>;
  ch4: () => Promise<AsyncIterator<Int>>;
  ch5: () => Promise<AsyncIterator<Int>>;
  ch6: () => Promise<AsyncIterator<Int>>;
  ch7: () => Promise<AsyncIterator<Int>>;
  ch8: () => Promise<AsyncIterator<Int>>;
  ch9: () => Promise<AsyncIterator<Int>>;
  colourB: () => Promise<AsyncIterator<Int>>;
  colourC: () => Promise<AsyncIterator<Int>>;
  colourG: () => Promise<AsyncIterator<Int>>;
  colourR: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  day: () => Promise<AsyncIterator<Int>>;
  hour: () => Promise<AsyncIterator<Int>>;
  line: () => Promise<AsyncIterator<Int>>;
  minute: () => Promise<AsyncIterator<Int>>;
  month: () => Promise<AsyncIterator<Int>>;
  page: () => Promise<AsyncIterator<Int>>;
  rawTotalVolume: () => Promise<AsyncIterator<Int>>;
  rawVolumeL: () => Promise<AsyncIterator<Int>>;
  rawVolumeR: () => Promise<AsyncIterator<Int>>;
  temperature: () => Promise<AsyncIterator<Int>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  year: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
}

export interface CupDataProcFlowEdge {
  node: CupDataProcFlow;
  cursor: String;
}

export interface CupDataProcFlowEdgePromise
  extends Promise<CupDataProcFlowEdge>,
    Fragmentable {
  node: <T = CupDataProcFlowPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcFlowEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcFlowEdge>>,
    Fragmentable {
  node: <T = CupDataProcFlowSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataUserRemove {
  id: Int;
  changeTime: DateTimeOutput;
}

export interface CupDataUserRemovePromise
  extends Promise<CupDataUserRemove>,
    Fragmentable {
  id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  explainId: <T = CupDataUserRemoveExplainPromise>() => T;
  serialNumber: <T = CupPromise>() => T;
  userId: <T = UserPromise>() => T;
}

export interface CupDataUserRemoveSubscription
  extends Promise<AsyncIterator<CupDataUserRemove>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  explainId: <T = CupDataUserRemoveExplainSubscription>() => T;
  serialNumber: <T = CupSubscription>() => T;
  userId: <T = UserSubscription>() => T;
}

export interface CupDataManMdateConnection {
  pageInfo: PageInfo;
  edges: CupDataManMdateEdge[];
}

export interface CupDataManMdateConnectionPromise
  extends Promise<CupDataManMdateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataManMdateEdge>>() => T;
  aggregate: <T = AggregateCupDataManMdatePromise>() => T;
}

export interface CupDataManMdateConnectionSubscription
  extends Promise<AsyncIterator<CupDataManMdateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataManMdateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataManMdateSubscription>() => T;
}

export interface EthnicitySubscriptionPayload {
  mutation: MutationType;
  node: Ethnicity;
  updatedFields: String[];
  previousValues: EthnicityPreviousValues;
}

export interface EthnicitySubscriptionPayloadPromise
  extends Promise<EthnicitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EthnicityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EthnicityPreviousValuesPromise>() => T;
}

export interface EthnicitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EthnicitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EthnicitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EthnicityPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataColourCalc {
  count: Int;
}

export interface AggregateCupDataColourCalcPromise
  extends Promise<AggregateCupDataColourCalc>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataColourCalcSubscription
  extends Promise<AsyncIterator<AggregateCupDataColourCalc>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EthnicityPreviousValues {
  id: Int;
  ethnicity: String;
}

export interface EthnicityPreviousValuesPromise
  extends Promise<EthnicityPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  ethnicity: () => Promise<String>;
}

export interface EthnicityPreviousValuesSubscription
  extends Promise<AsyncIterator<EthnicityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  ethnicity: () => Promise<AsyncIterator<String>>;
}

export interface CupDataAnswerEdge {
  node: CupDataAnswer;
  cursor: String;
}

export interface CupDataAnswerEdgePromise
  extends Promise<CupDataAnswerEdge>,
    Fragmentable {
  node: <T = CupDataAnswerPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataAnswerEdgeSubscription
  extends Promise<AsyncIterator<CupDataAnswerEdge>>,
    Fragmentable {
  node: <T = CupDataAnswerSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataQuestion {
  id: Int;
  questionText: String;
}

export interface CupDataQuestionPromise
  extends Promise<CupDataQuestion>,
    Fragmentable {
  id: () => Promise<Int>;
  cupDataAnswer: <T = FragmentableArray<CupDataAnswer>>(
    args?: {
      where?: CupDataAnswerWhereInput;
      orderBy?: CupDataAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  questionText: () => Promise<String>;
}

export interface CupDataQuestionSubscription
  extends Promise<AsyncIterator<CupDataQuestion>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cupDataAnswer: <T = Promise<AsyncIterator<CupDataAnswerSubscription>>>(
    args?: {
      where?: CupDataAnswerWhereInput;
      orderBy?: CupDataAnswerOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  questionText: () => Promise<AsyncIterator<String>>;
}

export interface CupAppSyncConnection {
  pageInfo: PageInfo;
  edges: CupAppSyncEdge[];
}

export interface CupAppSyncConnectionPromise
  extends Promise<CupAppSyncConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupAppSyncEdge>>() => T;
  aggregate: <T = AggregateCupAppSyncPromise>() => T;
}

export interface CupAppSyncConnectionSubscription
  extends Promise<AsyncIterator<CupAppSyncConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupAppSyncEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupAppSyncSubscription>() => T;
}

export interface FirmwareSubscriptionPayload {
  mutation: MutationType;
  node: Firmware;
  updatedFields: String[];
  previousValues: FirmwarePreviousValues;
}

export interface FirmwareSubscriptionPayloadPromise
  extends Promise<FirmwareSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FirmwarePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FirmwarePreviousValuesPromise>() => T;
}

export interface FirmwareSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FirmwareSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FirmwareSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FirmwarePreviousValuesSubscription>() => T;
}

export interface AggregateCountry {
  count: Int;
}

export interface AggregateCountryPromise
  extends Promise<AggregateCountry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCountrySubscription
  extends Promise<AsyncIterator<AggregateCountry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FirmwarePreviousValues {
  id: Int;
  fwVersion: String;
}

export interface FirmwarePreviousValuesPromise
  extends Promise<FirmwarePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  fwVersion: () => Promise<String>;
}

export interface FirmwarePreviousValuesSubscription
  extends Promise<AsyncIterator<FirmwarePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  fwVersion: () => Promise<AsyncIterator<String>>;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataAnswer {
  id: Int;
  answerText: String;
}

export interface CupDataAnswerPromise
  extends Promise<CupDataAnswer>,
    Fragmentable {
  id: () => Promise<Int>;
  answerText: () => Promise<String>;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  questionId: <T = CupDataQuestionPromise>() => T;
}

export interface CupDataAnswerSubscription
  extends Promise<AsyncIterator<CupDataAnswer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  questionId: <T = CupDataQuestionSubscription>() => T;
}

export interface CalibrationConnection {
  pageInfo: PageInfo;
  edges: CalibrationEdge[];
}

export interface CalibrationConnectionPromise
  extends Promise<CalibrationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CalibrationEdge>>() => T;
  aggregate: <T = AggregateCalibrationPromise>() => T;
}

export interface CalibrationConnectionSubscription
  extends Promise<AsyncIterator<CalibrationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CalibrationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCalibrationSubscription>() => T;
}

export interface HardwareSubscriptionPayload {
  mutation: MutationType;
  node: Hardware;
  updatedFields: String[];
  previousValues: HardwarePreviousValues;
}

export interface HardwareSubscriptionPayloadPromise
  extends Promise<HardwareSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HardwarePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HardwarePreviousValuesPromise>() => T;
}

export interface HardwareSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HardwareSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HardwareSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HardwarePreviousValuesSubscription>() => T;
}

export interface UsersDataAnalysisConnection {
  pageInfo: PageInfo;
  edges: UsersDataAnalysisEdge[];
}

export interface UsersDataAnalysisConnectionPromise
  extends Promise<UsersDataAnalysisConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UsersDataAnalysisEdge>>() => T;
  aggregate: <T = AggregateUsersDataAnalysisPromise>() => T;
}

export interface UsersDataAnalysisConnectionSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UsersDataAnalysisEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUsersDataAnalysisSubscription>() => T;
}

export interface HardwarePreviousValues {
  id: Int;
  hwVersion: String;
}

export interface HardwarePreviousValuesPromise
  extends Promise<HardwarePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  hwVersion: () => Promise<String>;
}

export interface HardwarePreviousValuesSubscription
  extends Promise<AsyncIterator<HardwarePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  hwVersion: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByPeriodConnection {
  pageInfo: PageInfo;
  edges: UserRecordDataByPeriodEdge[];
}

export interface UserRecordDataByPeriodConnectionPromise
  extends Promise<UserRecordDataByPeriodConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRecordDataByPeriodEdge>>() => T;
  aggregate: <T = AggregateUserRecordDataByPeriodPromise>() => T;
}

export interface UserRecordDataByPeriodConnectionSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<UserRecordDataByPeriodEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateUserRecordDataByPeriodSubscription>() => T;
}

export interface CupDataQaResponse {
  id: Int;
  qaDate: DateTimeOutput;
}

export interface CupDataQaResponsePromise
  extends Promise<CupDataQaResponse>,
    Fragmentable {
  id: () => Promise<Int>;
  answerId: <T = CupDataAnswerPromise>() => T;
  qaDate: () => Promise<DateTimeOutput>;
  questionId: <T = CupDataQuestionPromise>() => T;
  userId: <T = UserPromise>() => T;
}

export interface CupDataQaResponseSubscription
  extends Promise<AsyncIterator<CupDataQaResponse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerId: <T = CupDataAnswerSubscription>() => T;
  qaDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  questionId: <T = CupDataQuestionSubscription>() => T;
  userId: <T = UserSubscription>() => T;
}

export interface UserInterviewDatumEdge {
  node: UserInterviewDatum;
  cursor: String;
}

export interface UserInterviewDatumEdgePromise
  extends Promise<UserInterviewDatumEdge>,
    Fragmentable {
  node: <T = UserInterviewDatumPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserInterviewDatumEdgeSubscription
  extends Promise<AsyncIterator<UserInterviewDatumEdge>>,
    Fragmentable {
  node: <T = UserInterviewDatumSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PlatformCompSubscriptionPayload {
  mutation: MutationType;
  node: PlatformComp;
  updatedFields: String[];
  previousValues: PlatformCompPreviousValues;
}

export interface PlatformCompSubscriptionPayloadPromise
  extends Promise<PlatformCompSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PlatformCompPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PlatformCompPreviousValuesPromise>() => T;
}

export interface PlatformCompSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PlatformCompSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PlatformCompSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PlatformCompPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PlatformCompPreviousValues {
  id: Int;
  phoneId: Int;
  platformId: Int;
  problemHistory?: Boolean;
  softwareId: Int;
  successHistory?: Boolean;
}

export interface PlatformCompPreviousValuesPromise
  extends Promise<PlatformCompPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  phoneId: () => Promise<Int>;
  platformId: () => Promise<Int>;
  problemHistory: () => Promise<Boolean>;
  softwareId: () => Promise<Int>;
  successHistory: () => Promise<Boolean>;
}

export interface PlatformCompPreviousValuesSubscription
  extends Promise<AsyncIterator<PlatformCompPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  phoneId: () => Promise<AsyncIterator<Int>>;
  platformId: () => Promise<AsyncIterator<Int>>;
  problemHistory: () => Promise<AsyncIterator<Boolean>>;
  softwareId: () => Promise<AsyncIterator<Int>>;
  successHistory: () => Promise<AsyncIterator<Boolean>>;
}

export interface HardwareEdge {
  node: Hardware;
  cursor: String;
}

export interface HardwareEdgePromise
  extends Promise<HardwareEdge>,
    Fragmentable {
  node: <T = HardwarePromise>() => T;
  cursor: () => Promise<String>;
}

export interface HardwareEdgeSubscription
  extends Promise<AsyncIterator<HardwareEdge>>,
    Fragmentable {
  node: <T = HardwareSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataRejection {
  id: Int;
  rejectionDescription: String;
}

export interface CupDataRejectionPromise
  extends Promise<CupDataRejection>,
    Fragmentable {
  id: () => Promise<Int>;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rejectionDescription: () => Promise<String>;
}

export interface CupDataRejectionSubscription
  extends Promise<AsyncIterator<CupDataRejection>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cupDataProcMdates: <T = Promise<AsyncIterator<CupDataProcMdateSubscription>>>(
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  rejectionDescription: () => Promise<AsyncIterator<String>>;
}

export interface UserRecordDataByTimePreviousValues {
  id: Int;
  changeTime: DateTimeOutput;
  colorB?: Int;
  colorG?: Int;
  colorR?: Int;
  leakage?: String;
  startTime?: DateTimeOutput;
  volume?: Float;
}

export interface UserRecordDataByTimePreviousValuesPromise
  extends Promise<UserRecordDataByTimePreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  changeTime: () => Promise<DateTimeOutput>;
  colorB: () => Promise<Int>;
  colorG: () => Promise<Int>;
  colorR: () => Promise<Int>;
  leakage: () => Promise<String>;
  startTime: () => Promise<DateTimeOutput>;
  volume: () => Promise<Float>;
}

export interface UserRecordDataByTimePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  changeTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  colorB: () => Promise<AsyncIterator<Int>>;
  colorG: () => Promise<AsyncIterator<Int>>;
  colorR: () => Promise<AsyncIterator<Int>>;
  leakage: () => Promise<AsyncIterator<String>>;
  startTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  volume: () => Promise<AsyncIterator<Float>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataUserRemove {
  count: Int;
}

export interface AggregateCupDataUserRemovePromise
  extends Promise<AggregateCupDataUserRemove>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataUserRemoveSubscription
  extends Promise<AsyncIterator<AggregateCupDataUserRemove>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserPreviousValues {
  id: Int;
  anonUserId?: Int;
  deleted: Boolean;
  dob: DateTimeOutput;
  email: String;
  encryptSaltString?: String;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  anonUserId: () => Promise<Int>;
  deleted: () => Promise<Boolean>;
  dob: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  encryptSaltString: () => Promise<String>;
  firstName: () => Promise<String>;
  givenBirth: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  anonUserId: () => Promise<AsyncIterator<Int>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptSaltString: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  givenBirth: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface CupDataRawConnection {
  pageInfo: PageInfo;
  edges: CupDataRawEdge[];
}

export interface CupDataRawConnectionPromise
  extends Promise<CupDataRawConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataRawEdge>>() => T;
  aggregate: <T = AggregateCupDataRawPromise>() => T;
}

export interface CupDataRawConnectionSubscription
  extends Promise<AsyncIterator<CupDataRawConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataRawEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataRawSubscription>() => T;
}

export interface CupDataManMdate {
  id: Int;
  menFinish?: DateTimeOutput;
  menStart?: DateTimeOutput;
}

export interface CupDataManMdatePromise
  extends Promise<CupDataManMdate>,
    Fragmentable {
  id: () => Promise<Int>;
  mdateRowId: <T = CupDataProcMdatePromise>() => T;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
}

export interface CupDataManMdateSubscription
  extends Promise<AsyncIterator<CupDataManMdate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  mdateRowId: <T = CupDataProcMdateSubscription>() => T;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataProcVolumeEdge {
  node: CupDataProcVolume;
  cursor: String;
}

export interface CupDataProcVolumeEdgePromise
  extends Promise<CupDataProcVolumeEdge>,
    Fragmentable {
  node: <T = CupDataProcVolumePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataProcVolumeEdgeSubscription
  extends Promise<AsyncIterator<CupDataProcVolumeEdge>>,
    Fragmentable {
  node: <T = CupDataProcVolumeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserCoinHistorySubscriptionPayload {
  mutation: MutationType;
  node: UserCoinHistory;
  updatedFields: String[];
  previousValues: UserCoinHistoryPreviousValues;
}

export interface UserCoinHistorySubscriptionPayloadPromise
  extends Promise<UserCoinHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCoinHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCoinHistoryPreviousValuesPromise>() => T;
}

export interface UserCoinHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCoinHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCoinHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserCoinHistoryPreviousValuesSubscription>() => T;
}

export interface AggregateCupDataManMdate {
  count: Int;
}

export interface AggregateCupDataManMdatePromise
  extends Promise<AggregateCupDataManMdate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataManMdateSubscription
  extends Promise<AsyncIterator<AggregateCupDataManMdate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCoinHistoryPreviousValues {
  id: Int;
  category: String;
  coin: Int;
  contents: String;
  date: DateTimeOutput;
  txhash: String;
}

export interface UserCoinHistoryPreviousValuesPromise
  extends Promise<UserCoinHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  category: () => Promise<String>;
  coin: () => Promise<Int>;
  contents: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  txhash: () => Promise<String>;
}

export interface UserCoinHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCoinHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  category: () => Promise<AsyncIterator<String>>;
  coin: () => Promise<AsyncIterator<Int>>;
  contents: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  txhash: () => Promise<AsyncIterator<String>>;
}

export interface CupDataColourCalcConnection {
  pageInfo: PageInfo;
  edges: CupDataColourCalcEdge[];
}

export interface CupDataColourCalcConnectionPromise
  extends Promise<CupDataColourCalcConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataColourCalcEdge>>() => T;
  aggregate: <T = AggregateCupDataColourCalcPromise>() => T;
}

export interface CupDataColourCalcConnectionSubscription
  extends Promise<AsyncIterator<CupDataColourCalcConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataColourCalcEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataColourCalcSubscription>() => T;
}

export interface CupDataProcMdate {
  id: Int;
  dataRejected?: Boolean;
  dataVerified: Boolean;
  menFinish: DateTimeOutput;
  menStart: DateTimeOutput;
  rewardAmount?: Int;
}

export interface CupDataProcMdatePromise
  extends Promise<CupDataProcMdate>,
    Fragmentable {
  id: () => Promise<Int>;
  cupDataManMdates: <T = FragmentableArray<CupDataManMdate>>(
    args?: {
      where?: CupDataManMdateWhereInput;
      orderBy?: CupDataManMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dataRejected: () => Promise<Boolean>;
  dataVerified: () => Promise<Boolean>;
  menFinish: () => Promise<DateTimeOutput>;
  menStart: () => Promise<DateTimeOutput>;
  rejectId: <T = CupDataRejectionPromise>() => T;
  rewardAmount: () => Promise<Int>;
  userId: <T = UserPromise>() => T;
}

export interface CupDataProcMdateSubscription
  extends Promise<AsyncIterator<CupDataProcMdate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  cupDataManMdates: <T = Promise<AsyncIterator<CupDataManMdateSubscription>>>(
    args?: {
      where?: CupDataManMdateWhereInput;
      orderBy?: CupDataManMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcFlow: <T = Promise<AsyncIterator<CupDataProcFlowSubscription>>>(
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dataRejected: () => Promise<AsyncIterator<Boolean>>;
  dataVerified: () => Promise<AsyncIterator<Boolean>>;
  menFinish: () => Promise<AsyncIterator<DateTimeOutput>>;
  menStart: () => Promise<AsyncIterator<DateTimeOutput>>;
  rejectId: <T = CupDataRejectionSubscription>() => T;
  rewardAmount: () => Promise<AsyncIterator<Int>>;
  userId: <T = UserSubscription>() => T;
}

export interface CupEdge {
  node: Cup;
  cursor: String;
}

export interface CupEdgePromise extends Promise<CupEdge>, Fragmentable {
  node: <T = CupPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupEdgeSubscription
  extends Promise<AsyncIterator<CupEdge>>,
    Fragmentable {
  node: <T = CupSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserCupSubscriptionPayload {
  mutation: MutationType;
  node: UserCup;
  updatedFields: String[];
  previousValues: UserCupPreviousValues;
}

export interface UserCupSubscriptionPayloadPromise
  extends Promise<UserCupSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserCupPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserCupPreviousValuesPromise>() => T;
}

export interface UserCupSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserCupSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserCupSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserCupPreviousValuesSubscription>() => T;
}

export interface AggregateCalibration {
  count: Int;
}

export interface AggregateCalibrationPromise
  extends Promise<AggregateCalibration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCalibrationSubscription
  extends Promise<AsyncIterator<AggregateCalibration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserCupPreviousValues {
  id: Int;
}

export interface UserCupPreviousValuesPromise
  extends Promise<UserCupPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
}

export interface UserCupPreviousValuesSubscription
  extends Promise<AsyncIterator<UserCupPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByTimeEdge {
  node: UserRecordDataByTime;
  cursor: String;
}

export interface UserRecordDataByTimeEdgePromise
  extends Promise<UserRecordDataByTimeEdge>,
    Fragmentable {
  node: <T = UserRecordDataByTimePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRecordDataByTimeEdgeSubscription
  extends Promise<AsyncIterator<UserRecordDataByTimeEdge>>,
    Fragmentable {
  node: <T = UserRecordDataByTimeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CupDataProcFlow {
  id: Int;
  date: DateTimeOutput;
  hourlyFlow: Int;
}

export interface CupDataProcFlowPromise
  extends Promise<CupDataProcFlow>,
    Fragmentable {
  id: () => Promise<Int>;
  date: () => Promise<DateTimeOutput>;
  hourlyFlow: () => Promise<Int>;
  mdateRowId: <T = CupDataProcMdatePromise>() => T;
  userId: <T = UserPromise>() => T;
}

export interface CupDataProcFlowSubscription
  extends Promise<AsyncIterator<CupDataProcFlow>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  hourlyFlow: () => Promise<AsyncIterator<Int>>;
  mdateRowId: <T = CupDataProcMdateSubscription>() => T;
  userId: <T = UserSubscription>() => T;
}

export interface UserCupConnection {
  pageInfo: PageInfo;
  edges: UserCupEdge[];
}

export interface UserCupConnectionPromise
  extends Promise<UserCupConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserCupEdge>>() => T;
  aggregate: <T = AggregateUserCupPromise>() => T;
}

export interface UserCupConnectionSubscription
  extends Promise<AsyncIterator<UserCupConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserCupEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserCupSubscription>() => T;
}

export interface UserInterviewDatumSubscriptionPayload {
  mutation: MutationType;
  node: UserInterviewDatum;
  updatedFields: String[];
  previousValues: UserInterviewDatumPreviousValues;
}

export interface UserInterviewDatumSubscriptionPayloadPromise
  extends Promise<UserInterviewDatumSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserInterviewDatumPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserInterviewDatumPreviousValuesPromise>() => T;
}

export interface UserInterviewDatumSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserInterviewDatumSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserInterviewDatumSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserInterviewDatumPreviousValuesSubscription>() => T;
}

export interface FirmwareConnection {
  pageInfo: PageInfo;
  edges: FirmwareEdge[];
}

export interface FirmwareConnectionPromise
  extends Promise<FirmwareConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FirmwareEdge>>() => T;
  aggregate: <T = AggregateFirmwarePromise>() => T;
}

export interface FirmwareConnectionSubscription
  extends Promise<AsyncIterator<FirmwareConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FirmwareEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFirmwareSubscription>() => T;
}

export interface UserInterviewDatumPreviousValues {
  id: Int;
  answerRange?: Int;
  answerText?: String;
  answerYn?: Boolean;
  date: DateTimeOutput;
}

export interface UserInterviewDatumPreviousValuesPromise
  extends Promise<UserInterviewDatumPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  answerRange: () => Promise<Int>;
  answerText: () => Promise<String>;
  answerYn: () => Promise<Boolean>;
  date: () => Promise<DateTimeOutput>;
}

export interface UserInterviewDatumPreviousValuesSubscription
  extends Promise<AsyncIterator<UserInterviewDatumPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  answerRange: () => Promise<AsyncIterator<Int>>;
  answerText: () => Promise<AsyncIterator<String>>;
  answerYn: () => Promise<AsyncIterator<Boolean>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CupDataRejectionEdge {
  node: CupDataRejection;
  cursor: String;
}

export interface CupDataRejectionEdgePromise
  extends Promise<CupDataRejectionEdge>,
    Fragmentable {
  node: <T = CupDataRejectionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataRejectionEdgeSubscription
  extends Promise<AsyncIterator<CupDataRejectionEdge>>,
    Fragmentable {
  node: <T = CupDataRejectionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Country {
  id: Int;
  countryName: String;
}

export interface CountryPromise extends Promise<Country>, Fragmentable {
  id: () => Promise<Int>;
  countryName: () => Promise<String>;
  users: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CountrySubscription
  extends Promise<AsyncIterator<Country>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  countryName: () => Promise<AsyncIterator<String>>;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CupDataProcMdateConnection {
  pageInfo: PageInfo;
  edges: CupDataProcMdateEdge[];
}

export interface CupDataProcMdateConnectionPromise
  extends Promise<CupDataProcMdateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CupDataProcMdateEdge>>() => T;
  aggregate: <T = AggregateCupDataProcMdatePromise>() => T;
}

export interface CupDataProcMdateConnectionSubscription
  extends Promise<AsyncIterator<CupDataProcMdateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CupDataProcMdateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCupDataProcMdateSubscription>() => T;
}

export interface UserInterviewQuestionSubscriptionPayload {
  mutation: MutationType;
  node: UserInterviewQuestion;
  updatedFields: String[];
  previousValues: UserInterviewQuestionPreviousValues;
}

export interface UserInterviewQuestionSubscriptionPayloadPromise
  extends Promise<UserInterviewQuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserInterviewQuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserInterviewQuestionPreviousValuesPromise>() => T;
}

export interface UserInterviewQuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserInterviewQuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserInterviewQuestionPreviousValuesSubscription>() => T;
}

export interface AggregateCupAppSync {
  count: Int;
}

export interface AggregateCupAppSyncPromise
  extends Promise<AggregateCupAppSync>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupAppSyncSubscription
  extends Promise<AsyncIterator<AggregateCupAppSync>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserInterviewQuestionPreviousValues {
  id: Int;
  question: String;
}

export interface UserInterviewQuestionPreviousValuesPromise
  extends Promise<UserInterviewQuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  question: () => Promise<String>;
}

export interface UserInterviewQuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<UserInterviewQuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  question: () => Promise<AsyncIterator<String>>;
}

export interface UsersDataAnalysisSubscriptionPayload {
  mutation: MutationType;
  node: UsersDataAnalysis;
  updatedFields: String[];
  previousValues: UsersDataAnalysisPreviousValues;
}

export interface UsersDataAnalysisSubscriptionPayloadPromise
  extends Promise<UsersDataAnalysisSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UsersDataAnalysisPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UsersDataAnalysisPreviousValuesPromise>() => T;
}

export interface UsersDataAnalysisSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UsersDataAnalysisSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UsersDataAnalysisSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UsersDataAnalysisPreviousValuesSubscription>() => T;
}

export interface AppServerSync {
  id: Int;
  serverSynchTime: DateTimeOutput;
}

export interface AppServerSyncPromise
  extends Promise<AppServerSync>,
    Fragmentable {
  id: () => Promise<Int>;
  serverSynchTime: () => Promise<DateTimeOutput>;
  userId: <T = UserPromise>() => T;
}

export interface AppServerSyncSubscription
  extends Promise<AsyncIterator<AppServerSync>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  serverSynchTime: () => Promise<AsyncIterator<DateTimeOutput>>;
  userId: <T = UserSubscription>() => T;
}

export interface PlatformCompEdge {
  node: PlatformComp;
  cursor: String;
}

export interface PlatformCompEdgePromise
  extends Promise<PlatformCompEdge>,
    Fragmentable {
  node: <T = PlatformCompPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PlatformCompEdgeSubscription
  extends Promise<AsyncIterator<PlatformCompEdge>>,
    Fragmentable {
  node: <T = PlatformCompSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDataQaResponse {
  count: Int;
}

export interface AggregateCupDataQaResponsePromise
  extends Promise<AggregateCupDataQaResponse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataQaResponseSubscription
  extends Promise<AsyncIterator<AggregateCupDataQaResponse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRecordDataByPeriodSubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByPeriod;
  updatedFields: String[];
  previousValues: UserRecordDataByPeriodPreviousValues;
}

export interface UserRecordDataByPeriodSubscriptionPayloadPromise
  extends Promise<UserRecordDataByPeriodSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByPeriodPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByPeriodPreviousValuesPromise>() => T;
}

export interface UserRecordDataByPeriodSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByPeriodSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByPeriodSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByPeriodPreviousValuesSubscription>() => T;
}

export interface User {
  id: Int;
  anonUserId?: Int;
  deleted: Boolean;
  dob: DateTimeOutput;
  email: String;
  encryptSaltString?: String;
  firstName: String;
  givenBirth: Boolean;
  lastName: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<Int>;
  anonUserId: () => Promise<Int>;
  appServerSync: <T = FragmentableArray<AppServerSync>>(
    args?: {
      where?: AppServerSyncWhereInput;
      orderBy?: AppServerSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  countryId: <T = CountryPromise>() => T;
  cupDataProcFlow: <T = FragmentableArray<CupDataProcFlow>>(
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcMdates: <T = FragmentableArray<CupDataProcMdate>>(
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataQaResponse: <T = FragmentableArray<CupDataQaResponse>>(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataUserRemove: <T = FragmentableArray<CupDataUserRemove>>(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  deleted: () => Promise<Boolean>;
  dob: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  encryptSaltString: () => Promise<String>;
  ethnicityId: <T = EthnicityPromise>() => T;
  firstName: () => Promise<String>;
  givenBirth: () => Promise<Boolean>;
  lastName: () => Promise<String>;
  password: () => Promise<String>;
  userCoinHistory: <T = FragmentableArray<UserCoinHistory>>(
    args?: {
      where?: UserCoinHistoryWhereInput;
      orderBy?: UserCoinHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userCups: <T = FragmentableArray<UserCup>>(
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userInterviewData: <T = FragmentableArray<UserInterviewDatum>>(
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userRecordDataByPeriod: <T = FragmentableArray<UserRecordDataByPeriod>>(
    args?: {
      where?: UserRecordDataByPeriodWhereInput;
      orderBy?: UserRecordDataByPeriodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  anonUserId: () => Promise<AsyncIterator<Int>>;
  appServerSync: <T = Promise<AsyncIterator<AppServerSyncSubscription>>>(
    args?: {
      where?: AppServerSyncWhereInput;
      orderBy?: AppServerSyncOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  countryId: <T = CountrySubscription>() => T;
  cupDataProcFlow: <T = Promise<AsyncIterator<CupDataProcFlowSubscription>>>(
    args?: {
      where?: CupDataProcFlowWhereInput;
      orderBy?: CupDataProcFlowOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataProcMdates: <T = Promise<AsyncIterator<CupDataProcMdateSubscription>>>(
    args?: {
      where?: CupDataProcMdateWhereInput;
      orderBy?: CupDataProcMdateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataQaResponse: <
    T = Promise<AsyncIterator<CupDataQaResponseSubscription>>
  >(
    args?: {
      where?: CupDataQaResponseWhereInput;
      orderBy?: CupDataQaResponseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  cupDataUserRemove: <
    T = Promise<AsyncIterator<CupDataUserRemoveSubscription>>
  >(
    args?: {
      where?: CupDataUserRemoveWhereInput;
      orderBy?: CupDataUserRemoveOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  deleted: () => Promise<AsyncIterator<Boolean>>;
  dob: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  encryptSaltString: () => Promise<AsyncIterator<String>>;
  ethnicityId: <T = EthnicitySubscription>() => T;
  firstName: () => Promise<AsyncIterator<String>>;
  givenBirth: () => Promise<AsyncIterator<Boolean>>;
  lastName: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  userCoinHistory: <T = Promise<AsyncIterator<UserCoinHistorySubscription>>>(
    args?: {
      where?: UserCoinHistoryWhereInput;
      orderBy?: UserCoinHistoryOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userCups: <T = Promise<AsyncIterator<UserCupSubscription>>>(
    args?: {
      where?: UserCupWhereInput;
      orderBy?: UserCupOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userInterviewData: <
    T = Promise<AsyncIterator<UserInterviewDatumSubscription>>
  >(
    args?: {
      where?: UserInterviewDatumWhereInput;
      orderBy?: UserInterviewDatumOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  userRecordDataByPeriod: <
    T = Promise<AsyncIterator<UserRecordDataByPeriodSubscription>>
  >(
    args?: {
      where?: UserRecordDataByPeriodWhereInput;
      orderBy?: UserRecordDataByPeriodOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserRecordDataByDayPreviousValues {
  id: Int;
  crampsLevel?: Int;
  recordDate: DateTimeOutput;
}

export interface UserRecordDataByDayPreviousValuesPromise
  extends Promise<UserRecordDataByDayPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  crampsLevel: () => Promise<Int>;
  recordDate: () => Promise<DateTimeOutput>;
}

export interface UserRecordDataByDayPreviousValuesSubscription
  extends Promise<AsyncIterator<UserRecordDataByDayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  crampsLevel: () => Promise<AsyncIterator<Int>>;
  recordDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRecordDataByDaySubscriptionPayload {
  mutation: MutationType;
  node: UserRecordDataByDay;
  updatedFields: String[];
  previousValues: UserRecordDataByDayPreviousValues;
}

export interface UserRecordDataByDaySubscriptionPayloadPromise
  extends Promise<UserRecordDataByDaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRecordDataByDayPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRecordDataByDayPreviousValuesPromise>() => T;
}

export interface UserRecordDataByDaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRecordDataByDaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRecordDataByDaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRecordDataByDayPreviousValuesSubscription>() => T;
}

export interface CupDataColourCalibEdge {
  node: CupDataColourCalib;
  cursor: String;
}

export interface CupDataColourCalibEdgePromise
  extends Promise<CupDataColourCalibEdge>,
    Fragmentable {
  node: <T = CupDataColourCalibPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CupDataColourCalibEdgeSubscription
  extends Promise<AsyncIterator<CupDataColourCalibEdge>>,
    Fragmentable {
  node: <T = CupDataColourCalibSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCupDataUserRemoveExplain {
  count: Int;
}

export interface AggregateCupDataUserRemoveExplainPromise
  extends Promise<AggregateCupDataUserRemoveExplain>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCupDataUserRemoveExplainSubscription
  extends Promise<AsyncIterator<AggregateCupDataUserRemoveExplain>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUserInterviewQuestion {
  count: Int;
}

export interface AggregateUserInterviewQuestionPromise
  extends Promise<AggregateUserInterviewQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserInterviewQuestionSubscription
  extends Promise<AsyncIterator<AggregateUserInterviewQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CountryConnection {
  pageInfo: PageInfo;
  edges: CountryEdge[];
}

export interface CountryConnectionPromise
  extends Promise<CountryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CountryEdge>>() => T;
  aggregate: <T = AggregateCountryPromise>() => T;
}

export interface CountryConnectionSubscription
  extends Promise<AsyncIterator<CountryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CountryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCountrySubscription>() => T;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "AnswerType",
    embedded: false
  },
  {
    name: "AppServerSync",
    embedded: false
  },
  {
    name: "AuthToken",
    embedded: false
  },
  {
    name: "Calibration",
    embedded: false
  },
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "Cup",
    embedded: false
  },
  {
    name: "CupAppSync",
    embedded: false
  },
  {
    name: "CupDataAnswer",
    embedded: false
  },
  {
    name: "CupDataColourCalc",
    embedded: false
  },
  {
    name: "CupDataColourCalib",
    embedded: false
  },
  {
    name: "CupDataManMdate",
    embedded: false
  },
  {
    name: "CupDataProcFlow",
    embedded: false
  },
  {
    name: "CupDataProcMdate",
    embedded: false
  },
  {
    name: "CupDataProcVolume",
    embedded: false
  },
  {
    name: "CupDataQaResponse",
    embedded: false
  },
  {
    name: "CupDataQuestion",
    embedded: false
  },
  {
    name: "CupDataRaw",
    embedded: false
  },
  {
    name: "CupDataRejection",
    embedded: false
  },
  {
    name: "CupDataUserRemove",
    embedded: false
  },
  {
    name: "CupDataUserRemoveExplain",
    embedded: false
  },
  {
    name: "CupDatum",
    embedded: false
  },
  {
    name: "Ethnicity",
    embedded: false
  },
  {
    name: "Firmware",
    embedded: false
  },
  {
    name: "Hardware",
    embedded: false
  },
  {
    name: "PlatformComp",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserCoinHistory",
    embedded: false
  },
  {
    name: "UserCup",
    embedded: false
  },
  {
    name: "UserInterviewDatum",
    embedded: false
  },
  {
    name: "UserInterviewQuestion",
    embedded: false
  },
  {
    name: "UserRecordDataByDay",
    embedded: false
  },
  {
    name: "UserRecordDataByPeriod",
    embedded: false
  },
  {
    name: "UserRecordDataByTime",
    embedded: false
  },
  {
    name: "UsersDataAnalysis",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
